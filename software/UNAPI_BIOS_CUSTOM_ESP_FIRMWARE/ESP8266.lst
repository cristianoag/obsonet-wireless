0001   0000             ; ESP8266 TCP/IP UNAPI BIOS v.1.2
0002   0000             ; MSX-SM / SM-X UART version
0003   0000             ; Oduvaldo Pavan Junior
0004   0000             ; ducasp@gmail.com
0005   0000             ;    This code implements TCP/IP UNAPI Specification for MSX-SM
0006   0000             ;
0007   0000             ; Pieces of this code were based on DENYOTCP.ASM (Denyonet ROM)
0008   0000             ; made by Konamiman
0009   0000             ;
0010   0000             ; This code also has contributions from KdL, most specifically in the Wi-Fi
0011   0000             ; setup menus and functionality, he has helped quite a lot to get it to the
0012   0000             ; final format and functionality, thanks!
0013   0000             ;
0014   0000             ; Note: this implementation depends upon ESP8266 having the UNAPI
0015   0000             ; firmware flashed. This firmware has been developed by me as well.
0016   0000             ;
0017   0000             ; Comercial usage of this code or derivative works of this code are
0018   0000             ; allowed ONLY upon agreement with the author.
0019   0000             ; Non-comercial usage is free as long as you publish your code changes
0020   0000             ;
0021   0000             ; Design details:
0022   0000             ; There are three instances of this ROM
0023   0000             ;
0024   0000             ; 1 - If configured as disabled in set-up menu item 4, it won't load at all
0025   0000             ; 2 - F1 is pressed during boot, it will show a setup menu, ESC resume boot
0026   0000             ; 3 - No key is pressed during boot or setup is done, it is enabled (default),
0027   0000             ;     EXTBIO HOOK for UNAPI calls is installed and HTIM_I hook for internal
0028   0000             ;     usage and a few bytes at top of TPA are reserved upon the first UNAPI
0029   0000             ;     function being called
0030   0000             ;
0031   0000             ; As a ROM, our segment is read only, so for RAM needs we need to use RAM not
0032   0000             ; in our page. This ROM will do the following:
0033   0000             ;
0034   0000             ; If running the SETUP menu, we are going to "borrow" BASIC program area, that
0035   0000             ; is saved at TXTTAB. We can't allocate memory at this point as any possible
0036   0000             ; disk rom might be sitting on a slot that has not been initialized and results
0037   0000             ; could be bad. The BASIC program area trick should be safe, unless some other
0038   0000             ; cartridge runs a BASIC software for something (i.e.: wait disks be initialized
0039   0000             ; ), in such case, that BASIC software or trick will most likely be corrupted
0040   0000             ; after running our setup.
0041   0000             ;
0042   0000             ; After boot, we need RAM in the 4th page. We have the SLOT WORK AREA for free,
0043   0000             ; it is 8 bytes reserved for our slot, and that is certainly not enough, just
0044   0000             ; the EXTBIOS HOOK backup cost us 5 bytes, so we have three bytes remaining. Of
0045   0000             ; those, we use two to indicate the bottom of the memory reserved in the 4th
0046   0000             ; page. Whenever more memory is needed, HIMEM_RESERVED_SIZE must change, just
0047   0000             ; remember that more memory reserved means less memory available to
0048   0000             ; applications and BASIC, so use it wisely
0049   0000             ;
0050   0000             ; Slot Work Area Details
0051   0000             ; 0000 - 0004	: EXTBIO hook backup
0052   0000             ; 0005 - 0006	: HIMEM Allocated area (starts with 00 xx, once allocated goes
0053   0000             ;				  to Fxxx or Exxx so checking 0005 if 00 is enough)
0054   0000             ; 007			: Unused
0055   0000             ;
0056   0000             ; Current HIMEM mapping offset related to the address stored in the 6th and 7th
0057   0000             ; bytes of our slot work area:
0058   0000             ;
0059   0000             ; 0000 - 0004 	: HTIM_I hook backup
0060   0000             ; 0005 - 0006	: Counter that our HTIM_I hook updates
0061   0000             ; 0007			: Store Single Byte some functions need
0062   0000             ; 0008			: Stores whether DNS is ready or not
0063   0000             ; 0009 - 000A	: Stores last DNS result
0064   0000             ; 000B - 000C	: Stores a 16 bits value
0065   0000             ; 000D - 0012	: Store a backup of BC / DE / HL
0066   0000             ;	000D - 000E	: C and B
0067   0000             ;	000F - 0010	: D and E
0068   0000             ;	0011 - 0012	: H and L
0069   0000             ; 0013 - 001D	: Unused
0070   0000             ;
0071   0000             ; As this is sitting on a slot, there is a resoanable chance that this is initialized
0072   0000             ; before any disk controllers. If that is the case, allocating memory at HIMEM is bad
0073   0000             ; and might have two bad behaviors:
0074   0000             ;
0075   0000             ; 1 - Disk Controller is smart enough to determine HIMEM was moved and simply do not
0076   0000             ; initialize. No disk available...
0077   0000             ; 2 - Disk Controller doesn't care and simply wipe-out memory below original HIMEM at
0078   0000             ; boot to create the disk interfaces static work area, thus, causing our allocated
0079   0000             ; memory to be overwritten and MSX will most likely crash on ther first VDP interrupt
0080   0000             ; after that...
0081   0000             ;
0082   0000             ; So, allocating memory at cartridge startup will make MSX freeze or misbehave or not
0083   0000             ; have the disk available if our ROM is sitting in a slot lower than the disk. There
0084   0000             ; are a few possibilities:
0085   0000             ;
0086   0000             ; 1 - Hook to H_STKE, it is called once all slots have been initialized... But, using
0087   0000             ; this hook will make ESE SCSI to not work and halt with a "No enough memory" message,
0088   0000             ; so I do not consider it a good option as the intention is to re-use code for other
0089   0000             ; adapters
0090   0000             ; 2 - On any UNAPI call check the slot work area if the allocated area is other than 00
0091   0000             ; and if it is, execute, otherwise, first execute our allocation routine. This has an
0092   0000             ; overhead of a dozen instructions at every UNAPI function we execute, does not seem to
0093   0000             ; impact performance compared to the UNAPI RAM driver that doesn't has it
0094   0000             ; 3 - Try to go crazy and check for dos roms on slots above us, initialize those first
0095   0000             ; if found... Too much trouble for a dozen instructions
0096   0000             ;
0097   0000             ; So, for the moment the design decision is option #2
0098   0000             ;
0099   0000             
0100   0000             ;*************************
0101   0000             ;***  BUILD DEFINITIONS **
0102   0000             ;*************************
0103   0000             
0104   0000             ;--- SM-X ROM is less verbose...
0105   0000             SMX_ROM:				equ	0
0106   0000             ;--- Non-FPGA versions do not check OCM hardware...
0107   0000             CHECK_OCM_HW:			equ	0
0108   0000             ;--- FPGA Version can have the Turbo-R logo incorporated or not...
0109   0000             TURBO_R_LOGO:			equ	0
0110   0000             
0111   0000             ;*******************
0112   0000             ;***  CONSTANTS  ***
0113   0000             ;*******************
0114   0000             
0115   0000             ;--- System variables and routines:
0116   0000             CHSNS:					equ	#009C
0117   0000             CHGET:					equ	#009F
0118   0000             CHPUT:					equ	#00A2
0119   0000             BEEP:					equ	#00C0
0120   0000             SNSMAT:					equ	#0141
0121   0000             KILBUF:					equ	#0156
0122   0000             LINLEN:					equ	#F3B0
0123   0000             CLIKSW:					equ	#F3DB
0124   0000             TXTTAB:					equ	#F676
0125   0000             ARG:					equ	#F847
0126   0000             HOKVLD:					equ	#FB20
0127   0000             HIMEM:					equ	#FC4A
0128   0000             EXPTBL:					equ	#FCC1
0129   0000             SLTWRK:					equ	#FD09
0130   0000             H_TIMI:					equ	#FD9F
0131   0000             H_CLEA:					equ	#FED0
0132   0000             EXTBIO:					equ	#FFCA
0133   0000             
0134   0000             ;--- I/O ports:
0135   0000             OUT_CMD_PORT:			equ	#06
0136   0000             OUT_TX_PORT:			equ	#07
0137   0000             IN_DATA_PORT:			equ	#06
0138   0000             IN_STS_PORT:			equ	#07
0139   0000             PORT_F2:				equ	#F2
0140   0000             
0141   0000             ;--- API version and implementation version:
0142   0000             API_V_P:				equ	1
0143   0000             API_V_S:				equ	2
0144   0000             ROM_V_P:				equ	1
0145   0000             ROM_V_S:				equ	2
0146   0000             
0147   0000             ;--- Size of memory to reserve in upper TPA:
0148   0000             HIMEM_RESERVED_SIZE		equ	30
0149   0000             
0150   0000             ;--- Layout of our TPA area:
0151   0000             H_TIM_BACKUP_OFFSET		equ	0
0152   0000             MEMORY_COUNTER_OFFSET	equ	5
0153   0000             MEMORY_SB_VAR_OFFSET	equ	7
0154   0000             MEMORY_DNS_READY_OFFSET	equ	8
0155   0000             MEMORY_DNS_RES_OFFSET	equ	9
0156   0000             MEMORY_DB_VAR_OFFSET	equ	#0B
0157   0000             MEMORY_REGBACKUP_OFFSET	equ	#0D
0158   0000             MEMORY_BCBACKUP_OFFSET	equ	#0D
0159   0000             MEMORY_DEBACKUP_OFFSET	equ	#0F
0160   0000             MEMORY_HLBACKUP_OFFSET	equ	#11
0161   0000             
0162   0000             ;--- Scan Page Size
0163   0000             SCAN_MAX_PAGE_SIZE		equ	8
0164   0000             
0165   0000             ;--- Maximum number of available standard and implementation-specific function
0166   0000             ;--- numbers. Must be 0 to 127.
0167   0000             MAX_FN:					equ	29
0168   0000             
0169   0000             ;--- Must be either zero (if no implementation-specific functions available),
0170   0000             ;--- or 128 to 254.
0171   0000             MAX_IMPFN:				equ	0
0172   0000             
0173   0000             ;--- TCP/IP UNAPI error codes:
0174   0000             ERR_OK:					equ	0
0175   0000             ERR_NOT_IMP:			equ	1
0176   0000             ERR_NO_NETWORK:			equ	2
0177   0000             ERR_NO_DATA:			equ	3
0178   0000             ERR_INV_PARAM:			equ	4
0179   0000             ERR_QUERY_EXISTS:		equ	5
0180   0000             ERR_INV_IP:				equ	6
0181   0000             ERR_NO_DNS:				equ	7
0182   0000             ERR_DNS:				equ	8
0183   0000             ERR_NO_FREE_CONN:		equ	9
0184   0000             ERR_CONN_EXISTS:		equ	10
0185   0000             ERR_NO_CONN:			equ	11
0186   0000             ERR_CONN_STATE:			equ	12
0187   0000             ERR_BUFFER:				equ	13
0188   0000             ERR_LARGE_DGRAM:		equ	14
0189   0000             ERR_INV_OPER:			equ	15
0190   0000             
0191   0000             ;--- TCP/IP UNAPI connection Status
0192   0000             UNAPI_TCPIP_NS_CLOSED	equ	0
0193   0000             UNAPI_TCPIP_NS_OPENING	equ	1
0194   0000             UNAPI_TCPIP_NS_OPEN		equ	2
0195   0000             UNAPI_TCPIP_NS_UNKNOWN	equ	255
0196   0000             
0197   0000             ;************************
0198   0000             ;***  MSX ROM HEADER  ***
0199   0000             ;************************
0200   0000             	org	#4000
0201   4000 41 42       	db					#41,#42
0202   4002 10 40       	dw					INIT		; Initialize ESP, if not found, won't install hook
0203   4004 00 00       	dw					0			; Statement
0204   4006 00 00       	dw					0			; Device
0205   4008 00 00       	dw					0			; Text
0206   400A 00          	ds					6			; Reserved
0207   4010             
0208   4010             ;==================
0209   4010             ;===  Start-up  ===
0210   4010             ;==================
0211   4010             
0212   4010             INIT:
0213   4010 7C          	ld	a,h							; Let's test if we are mirrored and being executed in wrong page
0214   4011 FE 40       	cp	#40							; is MSB 0x40?
0215   4013 C0          	ret	nz							; if not, return, it is a mirror
0216   4014             	if	CHECK_OCM_HW = 1
0217   4014~            	; Below code has been kindly provided by KdL
0218   4014~            	ld	a,#d4						; set OCM ID = 212
0219   4014~            	out	(#40),a
0220   4014~            	in	a,(#49)						; Let's test the Machine Type ID
0221   4014~            	and	%00111100
0222   4014~            	rra
0223   4014~            	rra
0224   4014~            	cp	0							; is the ID = 0?
0225   4014~            	ret	z							; if yes, return, it is 1chipMSX
0226   4014~            	cp	1							; is the ID = 1?
0227   4014~            	ret	z							; if yes, return, it is Zemmix Neo
0228   4014~            	; ### Remove the next line to use the ROM with the emulators ###
0229   4014~            	cp	15							; is the ID = 15?
0230   4014~            	ret	z							; if yes, return, it is Unknown or a generic MSX system
0231   4014~            	; Ok, ID = 2 "SM-X" or ID > 2 "Newer Machines"
0232   4014             	endif
0233   4014 3E 1D       	ld	a,29						; ensures width 29
0234   4016 32 B0 F3    	ld	(LINLEN),a					; for the current text mode
0235   4019 AF          	xor	a							; A = 0
0236   401A 32 DB F3    	ld	(CLIKSW),a					; when key press, click disabled
0237   401D 3E 06       	ld	a,6
0238   401F CD 41 01    	call	SNSMAT
0239   4022 CB 6F       	bit	5,a							; Test [F1]
0240   4024 CA D7 41    	jp	z,ENTERING_ESPSETUP			; If F1 is pressed, let's execute our setup menu
0241   4027 CB 77       	bit	6,a							; Test [F2]
0242   4029 28 3C       	jr	z,BOOT_FROM_POWER_OFF		; If F2 is pressed, let's proceed as "boot from power off"
0243   402B 3E 08       	ld	a,8
0244   402D CD 41 01    	call	SNSMAT
0245   4030 CB 5F       	bit	3,a							; Test [DEL]
0246   4032 C8          	ret	z							; If DEL is pressed, UNAPI driver is not loaded and exits
0247   4033             	; We check if the Port F2 device is available
0248   4033 DB F2       	in	a,(PORT_F2)					; a = #FF, default value if it comes from power off or hard reset
0249   4035 2F          	cpl								; a = #FF - a
0250   4036 4F          	ld	c,a							; c = #00
0251   4037 D3 F2       	out	(PORT_F2),a					; a = #00
0252   4039 06 0C       	ld	b,12
0253   403B             WAIT_200MS:
0254   403B 76          	halt							; Wait 200ms to ensure a successful hard reset
0255   403C 10 FD       	djnz	WAIT_200MS
0256   403E DB F2       	in	a,(PORT_F2)					; a = #00?
0257   4040 2F          	cpl								; a = #FF - a
0258   4041 D3 F2       	out	(PORT_F2),a					; a = #FF?
0259   4043 B9          	cp	c							; If not a = c, port #F2 is writable and available
0260   4044 28 21       	jr	z,BOOT_FROM_POWER_OFF		; If a = c, port #F2 is not available, let's proceed as "boot from power off"
0261   4046             	; Ok, Port F2 device available
0262   4046 FE EF       	cp	#EF							; ESP Not Found
0263   4048 C8          	ret	z							; If yes, UNAPI driver is not loaded and exits
0264   4049 FE F0       	cp	#F0							; UNAPI driver has been loaded at least once
0265   404B CA 42 41    	jp	z,INIT_NOCLOCKUPDAT2		; If yes, proceed without affecting the connection or the date and time
0266   404E FE F1       	cp	#F1							; User requested to go directly to Wi-Fi Setup
0267   4050 CA D7 41    	jp	z,ENTERING_ESPSETUP			; If yes, let's execute our setup menu
0268   4053 FE FE       	cp	#FE							; Unexpected error from the previous reboot
0269   4055 20 10       	jr  nz,BOOT_FROM_POWER_OFF		; If no one is confirmed, let's proceed as "boot from power off"
0270   4057             	; Oops! An unexpected error occurred on the last reboot
0271   4057 21 67 66    	ld	hl,STR_OOPS					; Print Oops! An unexpected error message
0272   405A CD BF 4B    	call	PRINTHL					; and let's proceed as "boot from power off"
0273   405D 06 78       	ld	b,120						; Wait 2 seconds with message on screen
0274   405F             WAIT_2S:
0275   405F 76          	halt
0276   4060 10 FD       	djnz	WAIT_2S					; If not zero, our time out has not elapsed
0277   4062 3E 0C       	ld	a,CLS
0278   4064 CD A2 00    	call	CHPUT
0279   4067             BOOT_FROM_POWER_OFF:
0280   4067 3E FE       	ld	a,#FE						; Preset #FE, unexpected error
0281   4069 D3 F2       	out	(PORT_F2),a					; on port #F2
0282   406B             	if	SMX_ROM = 0
0283   406B 21 9B 5A    	ld	hl,WELCOME
0284   406E CD BF 4B    	call	PRINTHL
0285   4071 21 10 5B    	ld	hl,WELCOME_S
0286   4074 CD BF 4B    	call	PRINTHL
0287   4077             	endif
0288   4077 CD 75 59    	call	RESET_ESP
0289   407A B7          	or	a
0290   407B CA 95 40    	jp	z,INIT_UNAPI				; Well, if reset successful, continue
0291   407E             ESP_NOT_FOUND:
0292   407E             	; If here, ESP was not found, so, exit with an error message
0293   407E 78          	ld	a,b
0294   407F B7          	or	a
0295   4080 21 DC 65    	ld	hl,FAIL_S					; If 0, non responsive
0296   4083 28 03       	jr	z,INIT_F_ERRMSG
0297   4085 21 2A 66    	ld	hl,FAIL_F					; Otherwise, firmware is old
0298   4088             INIT_F_ERRMSG:
0299   4088 CD BF 4B    	call	PRINTHL
0300   408B             INIT_F_WAIT:
0301   408B 06 F0       	ld	b,240						; 4s
0302   408D             INIT_F_LOOP_WAIT:
0303   408D 76          	halt
0304   408E 10 FD       	djnz	INIT_F_LOOP_WAIT
0305   4090             AND_DONE:
0306   4090 3E EF       	ld	a,#EF						; Set #EF, ESP Not Found
0307   4092 D3 F2       	out	(PORT_F2),a					; on port #F2
0308   4094 C9          	ret								; And done
0309   4095             INIT_UNAPI:
0310   4095 3E 14       	ld	a,20
0311   4097 D3 06       	out	(OUT_CMD_PORT),a			; Clear UART
0312   4099 3E 63       	ld	a,CMD_QUERY_ACLK_SETTINGS
0313   409B D3 07       	out	(OUT_TX_PORT),a
0314   409D 21 3C 00    	ld	hl,60						; Wait Up To 1s
0315   40A0 ED 5B 76 F6 	ld	de,(TXTTAB)					; We will borrow Basic Program memory area for now...
0316   40A4 DD 6B       	ld	ixl,e
0317   40A6 DD 62       	ld	ixh,d						; Address in IX
0318   40A8 CD BB 4A    	call	WAIT_MENU_CMD_RESPONSE
0319   40AB CA 3A 41    	jp	z,INIT_NOCLOCKUPDATE		; If error, just skip
0320   40AE             	; Response received, IX+0 and IX+1 has Auto Clock and GMT
0321   40AE 3E 03       	ld	a,3
0322   40B0 DD BE 00    	cp	(ix+0)
0323   40B3 20 09       	jr	nz,INIT_UNAPI2				; If not disabled continue on INIT_UNAPI2
0324   40B5             	; Disabled, ok, so let's ensure connection is not locked (just in case it was setup as disabled right now)
0325   40B5 3E 14       	ld	a,20
0326   40B7 D3 06       	out	(OUT_CMD_PORT),a			; Clear UART
0327   40B9 3E 68       	ld	a,CMD_WIFIRELEASE_ESP
0328   40BB D3 07       	out	(OUT_TX_PORT),a				; Just send, no need to wait response
0329   40BD C9          	ret
0330   40BE             INIT_UNAPI2:
0331   40BE 3A 2D 00    	ld	a,(#002D)					; Check MSX Version
0332   40C1 B7          	or	a
0333   40C2 28 76       	jr	z,INIT_NOCLOCKUPDATE		; If zero, MSX1, can't set clock
0334   40C4 AF          	xor	a
0335   40C5 DD B6 00    	or	(ix+0)
0336   40C8 28 70       	jr	z,INIT_NOCLOCKUPDATE		; if turned off, skip
0337   40CA             	; Ok, not zero, so we are going to simply request the time, it might take up to 10s
0338   40CA DD 23       	inc	ix
0339   40CC DD 23       	inc	ix							; ok, leave IX+0 and IX+1 intact
0340   40CE             	; b = number of response check attempts
0341   40CE 06 05       	ld	b,5							; 5 * 2s = 10s
0342   40D0 3E 14       	ld	a,20
0343   40D2 D3 06       	out	(OUT_CMD_PORT),a			; Clear UART
0344   40D4 3E 47       	ld	a,CMD_GET_TIME
0345   40D6 D3 07       	out	(OUT_TX_PORT),a
0346   40D8             TRY_AGAIN:
0347   40D8 C5          	push	bc
0348   40D9 21 78 00    	ld	hl,120						; Wait Up To 2s per attempt
0349   40DC CD BB 4A    	call	WAIT_MENU_CMD_RESPONSE
0350   40DF 20 1E       	jr	nz,INIT_CLOCKUPDATE			; if ok, follow up
0351   40E1 21 48 66    	ld	hl,STR_WAITING				; Print Waiting for connection message
0352   40E4 CD BF 4B    	call	PRINTHL
0353   40E7 3E FF       	ld	a,#FF
0354   40E9 B8          	cp	b							; Was time-out the failure reason?
0355   40EA C1          	pop	bc							; Restore stack ballance and retry counter
0356   40EB 20 04       	jr	nz,STOP_TRYING				; If error return code and not time-out, no more checks needed
0357   40ED 3E 47       	ld	a,CMD_GET_TIME				; Needed for retries
0358   40EF 10 E7       	djnz	TRY_AGAIN
0359   40F1             STOP_TRYING:
0360   40F1             	; Leave a message that clock has not been updated
0361   40F1 21 53 65    	ld	hl,STR_CLKUPDT_FAIL
0362   40F4 CD BF 4B    	call	PRINTHL
0363   40F7 3E F0       	ld	a,240						; Wait 4 seconds with message on screen
0364   40F9             WAIT_4S:
0365   40F9 76          	halt
0366   40FA 3D          	dec	a
0367   40FB             	; If not zero, our time out has not elapsed
0368   40FB 20 FC       	jr	nz,WAIT_4S
0369   40FD 18 3B       	jr	INIT_NOCLOCKUPDATE			; error, just skip to not set garbage in clock
0370   40FF             INIT_CLOCKUPDATE:
0371   40FF C1          	pop	bc
0372   4100 DD 2B       	dec	ix
0373   4102 DD 2B       	dec	ix							; ix back where it should
0374   4104             	; ix + 0 -> 0 If no need to set clock, 1 if set clock, 2 if set clock and request to turn Wi-Fi Off
0375   4104             	; ix + 1 -> GMT setting, well, not going to use it
0376   4104             	; ix + 2 -> Seconds
0377   4104             	; ix + 3 -> Minutes
0378   4104             	; ix + 4 -> Hours
0379   4104             	; ix + 5 -> Day
0380   4104             	; ix + 6 -> Month
0381   4104             	; ix + 7 -> Year LSB
0382   4104             	; ix + 8 -> Year MSB
0383   4104 DD 66 04    	ld	h,(ix+4)
0384   4107 DD 6E 03    	ld	l,(ix+3)
0385   410A DD 56 02    	ld	d,(ix+2)
0386   410D CD B1 59    	call	SET_TIME
0387   4110 20 28       	jr	nz,INIT_NOCLOCKUPDATE		; if error, just skip
0388   4112 DD 66 08    	ld	h,(ix+8)
0389   4115 DD 6E 07    	ld	l,(ix+7)
0390   4118 DD 56 06    	ld	d,(ix+6)
0391   411B DD 5E 05    	ld	e,(ix+5)
0392   411E CD DE 59    	call	SET_DATE
0393   4121 3E 02       	ld	a,2
0394   4123 DD BE 00    	cp	(ix+0)
0395   4126 20 12       	jr	nz,INIT_NOCLOCKUPDATE
0396   4128             	; First, release any hold to Wi-Fi Connection
0397   4128 3E 14       	ld	a,20
0398   412A D3 06       	out	(OUT_CMD_PORT),a			; Clear UART
0399   412C 3E 68       	ld	a,CMD_WIFIRELEASE_ESP
0400   412E D3 07       	out	(OUT_TX_PORT),a				; Just send, no need to wait response
0401   4130             	; And, turn off Wi-Fi Immediatelly
0402   4130 3E 14       	ld	a,20
0403   4132 D3 06       	out	(OUT_CMD_PORT),a			; Clear UART
0404   4134 3E 4F       	ld	a,CMD_WIFI_OFF
0405   4136 D3 07       	out	(OUT_TX_PORT),a				; Just send, no need to wait response
0406   4138 18 08       	jr	INIT_NOCLOCKUPDAT2
0407   413A             INIT_NOCLOCKUPDATE:
0408   413A             	; Release any hold to Wi-Fi Connection
0409   413A 3E 14       	ld	a,20
0410   413C D3 06       	out	(OUT_CMD_PORT),a			; Clear UART
0411   413E 3E 68       	ld	a,CMD_WIFIRELEASE_ESP
0412   4140 D3 07       	out	(OUT_TX_PORT),a				; Just send, no need to wait response
0413   4142             INIT_NOCLOCKUPDAT2:
0414   4142             	; Save existing EXTBIO hook if it exists
0415   4142 3A 20 FB    	ld	a,(HOKVLD)
0416   4145 CB 47       	bit	0,a
0417   4147 20 0B       	jr	nz,SAVE_HOOK2				; HOKVLD tells us if there is an extended BIOS already or not, if yes, save it
0418   4149             	; If here, no extended BIOS
0419   4149 CD 54 57    	call	GETSLT
0420   414C CD AD 57    	call	GETWRK					; Our ROM work area address is at HL (we can use up to 8 bytes)
0421   414F 3E C9       	ld	a,#C9						; RET, as we are the first extended BIOS
0422   4151 77          	ld	(hl),a
0423   4152 18 13       	jr	PATCH						; And now all we need to do is patch the EXTBIO hook :)
0424   4154             
0425   4154             SAVE_HOOK2:
0426   4154             	; If here, we are not the first to extend bios, so we need to save the previous one
0427   4154 CD 54 57    	call	GETSLT
0428   4157 CD AD 57    	call	GETWRK					; Our ROM work area address is at HL (we can use up to 8 bytes)
0429   415A EB          	ex	de,hl						; It is the destination for....
0430   415B 21 CA FF    	ld	hl,EXTBIO					; The actual EXTBIO hook
0431   415E 01 05 00    	ld	bc,5						; That is 5 bytes large
0432   4161 ED B0       	ldir							; And move to our work area
0433   4163 AF          	xor	a
0434   4164 12          	ld	(de),a						; Not initialized (de is at the sixth byte) of our slot work area
0435   4165 13          	inc	de
0436   4166 12          	ld	(de),a						; Not initialized (de is at the seventh byte) of our slot work area
0437   4167             
0438   4167             	; Patch EXTBIO
0439   4167             PATCH:
0440   4167 3E F7       	ld	a,#F7						; RST #30
0441   4169 32 CA FF    	ld	(EXTBIO),a					; In EXTBIO hook
0442   416C CD 54 57    	call	GETSLT					; Our Slot in A
0443   416F 32 CB FF    	ld	(EXTBIO+1),a				; Next EXTBIO hook byte
0444   4172 21 FB 4B    	ld	hl,DO_EXTBIO				; Our EXTBIO routine address
0445   4175 22 CC FF    	ld	(EXTBIO+2),hl				; Goes to the following two bytes in the hook
0446   4178             
0447   4178 21 CF FF    	ld	hl,EXTBIO+5					; Must patch DISINT and ENAINT as well
0448   417B 06 0A       	ld	b,5*2
0449   417D             PATCH2:
0450   417D 36 C9       	ld	(hl),#C9
0451   417F 23          	inc	hl
0452   4180 10 FB       	djnz	PATCH2					; So patch all 10 bytes with return
0453   4182             
0454   4182 21 20 FB    	ld	hl,HOKVLD
0455   4185 CB C6       	set	0,(hl)						; And set HOKVLD properly to indicate an EXTBIOS is installed
0456   4187             INIT_OK:
0457   4187             	if	SMX_ROM = 0
0458   4187 21 C1 65    	ld	hl,OK_S						; All done and set, nice exit message
0459   418A CD BF 4B    	call	PRINTHL
0460   418D             	endif
0461   418D 3E F0       	ld	a,#F0						; Set #F0, UNAPI driver has been loaded at least once
0462   418F D3 F2       	out	(PORT_F2),a					; on port #F2
0463   4191 C9          	ret
0464   4192             
0465   4192             ;==============================
0466   4192             ;===  TPA Memory Allocation  ==
0467   4192             ;==============================
0468   4192             HIMEM_ALLOC:
0469   4192             	; Now let's reserve memory in the 4th page for our usage
0470   4192 2A 4A FC    	ld hl,(HIMEM)					; Get HIMEM
0471   4195 B7          	or	a							; Clear Carry
0472   4196 11 1E 00    	ld	de,HIMEM_RESERVED_SIZE		; Reserve How much memory we need
0473   4199 ED 52       	sbc	hl,de						; New HIMEM
0474   419B 22 4A FC    	ld	(HIMEM),hl					; Save it
0475   419E 23          	inc	hl							; To be safe
0476   419F EB          	ex	de,hl						; now in DE
0477   41A0 CD 54 57    	call	GETSLT
0478   41A3 CD C1 57    	call	GETMEMPOINTERADDR		; This is where we are going to store our memory area address
0479   41A6             	; GETSLT and GETMEMPOINTER do not change DE, so it still has the our memory area address
0480   41A6 73          	ld	(hl),e
0481   41A7 23          	inc	hl
0482   41A8 72          	ld	(hl),d						; And save our memory area there
0483   41A9             	; Ok, DE has our memory area, let's save old H_TIMI hook there
0484   41A9 21 9F FD    	ld	hl,H_TIMI					; The actual H_TIMI hook
0485   41AC 01 05 00    	ld	bc,5						; That is 5 bytes large
0486   41AF ED B0       	ldir							; And move to our memory area
0487   41B1 F3          	di								; Turn of interrupts as we are going to patch H_TIMI
0488   41B2             PATCH_H_TIMI:
0489   41B2 3E F7       	ld	a,#F7						; RST #30
0490   41B4 32 9F FD    	ld	(H_TIMI),a					; In H_TIMI hook
0491   41B7 CD 54 57    	call	GETSLT					; Our Slot in A
0492   41BA 32 A0 FD    	ld	(H_TIMI+1),a				; Next H_TIMI hook byte
0493   41BD 21 E7 4B    	ld	hl,DO_HTIMI					; Our H_TIMI routine address
0494   41C0 22 A1 FD    	ld	(H_TIMI+2),hl				; Goes to the following two bytes in the hook
0495   41C3 FB          	ei								; done, so re-enable interrupts
0496   41C4             
0497   41C4             	; Set DNS_READY to zero
0498   41C4 AF          	xor	a
0499   41C5 CD EB 58    	call	SETDNSREADY
0500   41C8             	; Set TIME-OUT counter to zero
0501   41C8 21 00 00    	ld	hl,0
0502   41CB CD F4 57    	call	SETCOUNTER
0503   41CE C9          	ret
0504   41CF             
0505   41CF             ;============================
0506   41CF             ;===  SETUP Menu Routines  ==
0507   41CF             ;===       Main Menu       ==
0508   41CF             ;============================
0509   41CF             ESPSETUP.EXIT:
0510   41CF 3E 0C       	ld	a,CLS
0511   41D1 CD A2 00    	call	CHPUT
0512   41D4 C3 95 40    	jp	INIT_UNAPI					; When done, resume initialization
0513   41D7             ENTERING_ESPSETUP:
0514   41D7 3E FE       	ld	a,#FE						; Preset #FE, unexpected error
0515   41D9 D3 F2       	out	(PORT_F2),a					; on port #F2
0516   41DB 21 7F 5A    	ld	hl,ENTERING_WIFI_SETUP
0517   41DE CD BF 4B    	call	PRINTHL
0518   41E1 CD 6A 49    	call	WAIT_650MS_AND_THEN_CONTINUE
0519   41E4             	; Hold Wi-Fi Connection On
0520   41E4 3E 14       	ld	a,20
0521   41E6 D3 06       	out	(OUT_CMD_PORT),a			; Clear UART
0522   41E8 3E 48       	ld	a,CMD_WIFIHOLD_ESP
0523   41EA D3 07       	out	(OUT_TX_PORT),a
0524   41EC 21 3C 00    	ld	hl,60						; Up to 1s time-out
0525   41EF CD BB 4A    	call	WAIT_MENU_CMD_RESPONSE	; Wait response
0526   41F2             	; We do not want to error here, just in case user still need to upgrade ESP firmware
0527   41F2             ESPSETUP:
0528   41F2 CD 75 59    	call	RESET_ESP
0529   41F5 B7          	or	a
0530   41F6 C2 7E 40    	jp	nz,ESP_NOT_FOUND			; Not well, ESP was not found
0531   41F9             ESPSETUP_NEXT:
0532   41F9 CD 56 01    	call	KILBUF					; Clear Keyboard Buffer
0533   41FC             	; Well, if reset successful, continue
0534   41FC DB 07       	in	a,(IN_STS_PORT)
0535   41FE CB 5F       	bit	3,a							; Quick Receive Supported?
0536   4200 28 0C       	jr	z,ESPSETUP.1NF				; If not, tells no Quick Receive support
0537   4202 21 9B 5A    	ld	hl,WELCOME
0538   4205 CD BF 4B    	call	PRINTHL
0539   4208 21 4E 5B    	ld	hl,WELCOME_SF
0540   420B C3 17 42    	jp	ESPSETUP.1F					; Report that Quick Receive is supported
0541   420E             ESPSETUP.1NF:
0542   420E 21 9B 5A    	ld	hl,WELCOME
0543   4211 CD BF 4B    	call	PRINTHL
0544   4214 21 10 5B    	ld	hl,WELCOME_S
0545   4217             ESPSETUP.1F:
0546   4217 CD BF 4B    	call	PRINTHL					; Print Welcome message
0547   421A 3E 14       	ld	a,20
0548   421C D3 06       	out	(OUT_CMD_PORT),a			; Clear UART
0549   421E 3E 67       	ld	a,CMD_AP_STS
0550   4220 D3 07       	out	(OUT_TX_PORT),a				; Get AP conn status and name
0551   4222 21 3C 00    	ld	hl,60						; Wait Up To 1s
0552   4225 ED 5B 76 F6 	ld	de,(TXTTAB)					; We will borrow Basic Program memory area for now...
0553   4229 DD 6B       	ld	ixl,e
0554   422B DD 62       	ld	ixh,d						; Address in IX
0555   422D CD BB 4A    	call	WAIT_MENU_CMD_RESPONSE
0556   4230 CA 77 42    	jp	z,ESPSETUP.1G				; Won't block in case of error
0557   4233             	; Success, so connection state is in IX+0, then, zero terminated string with SSID starting at IX+1
0558   4233 DD 7E 00    	ld	a,(ix+0)
0559   4236 21 6A 5B    	ld	hl,WELCOME_CS0
0560   4239 FE 00       	cp	0
0561   423B 28 1F       	jr	z,ESPSETUP.2F
0562   423D 21 8B 5B    	ld	hl,WELCOME_CS1
0563   4240 FE 01       	cp	1
0564   4242 28 18       	jr	z,ESPSETUP.2F
0565   4244 21 A5 5B    	ld	hl,WELCOME_CS2
0566   4247 FE 02       	cp	2
0567   4249 28 11       	jr	z,ESPSETUP.2F
0568   424B 21 C4 5B    	ld	hl,WELCOME_CS3
0569   424E FE 03       	cp	3
0570   4250 28 0A       	jr	z,ESPSETUP.2F
0571   4252 21 DD 5B    	ld	hl,WELCOME_CS4
0572   4255 FE 04       	cp	4
0573   4257 28 03       	jr	z,ESPSETUP.2F
0574   4259 21 FB 5B    	ld	hl,WELCOME_CS5
0575   425C             ESPSETUP.2F:
0576   425C FD 67       	ld	iyh,a						; Save current conn status in iyh
0577   425E CD BF 4B    	call	PRINTHL					; Print Status
0578   4261 DD E5       	push	ix
0579   4263 E1          	pop	hl
0580   4264 23          	inc	hl							; HL has AP Name
0581   4265 CD C9 4B    	call	PRINTHLINE				; Print AP Name
0582   4268 3E 0D       	ld	a,CR
0583   426A CD A2 00    	call	CHPUT
0584   426D 3E 0A       	ld	a,LF
0585   426F CD A2 00    	call	CHPUT
0586   4272 3E 0A       	ld	a,LF
0587   4274 CD A2 00    	call	CHPUT					; Give some space...
0588   4277             ESPSETUP.1G:
0589   4277 21 11 5C    	ld	hl,MMENU_S
0590   427A CD BF 4B    	call	PRINTHL					; Print Main Menu
0591   427D             CONN_CHG_LOOP:
0592   427D CD 9C 00    	call	CHSNS
0593   4280 20 23       	jr	nz,MM_WAIT_INPUT			; If not zero, there is a key in buffer
0594   4282             	; Ok, there is not, we can check if connection status changed
0595   4282 3E 14       	ld	a,20
0596   4284 D3 06       	out	(OUT_CMD_PORT),a			; Clear UART
0597   4286 3E 67       	ld	a,CMD_AP_STS
0598   4288 D3 07       	out	(OUT_TX_PORT),a				; Get AP conn status and name
0599   428A 21 3C 00    	ld	hl,60						; Wait Up To 1s
0600   428D ED 5B 76 F6 	ld	de,(TXTTAB)					; We will borrow Basic Program memory area for now...
0601   4291 DD 6B       	ld	ixl,e
0602   4293 DD 62       	ld	ixh,d						; Address in IX
0603   4295 CD BB 4A    	call	WAIT_MENU_CMD_RESPONSE
0604   4298 CA 7D 42    	jp	z,CONN_CHG_LOOP				; Won't block in case of error
0605   429B DD 7E 00    	ld	a,(ix+0)
0606   429E FD BC       	cp	iyh							; If same, zero
0607   42A0 28 DB       	jr	z,CONN_CHG_LOOP				; Keep loop
0608   42A2 C3 F9 41    	jp	ESPSETUP_NEXT				; Changed, re-build menu
0609   42A5             MM_WAIT_INPUT:
0610   42A5 CD 9F 00    	call	CHGET
0611   42A8 FE 1B       	cp	#1b							; ESC?
0612   42AA CA CF 41    	jp	z,ESPSETUP.EXIT				; When done, resume initialization
0613   42AD FE 31       	cp	'1'							; Setup Nagle?
0614   42AF CA 5B 48    	jp	z,SET_NAGLE
0615   42B2 FE 32       	cp	'2'							; Setup Wi-Fi On Period?
0616   42B4 CA 95 47    	jp	z,SET_WIFI_TIMEOUT
0617   42B7 FE 33       	cp	'3'							; Scan networks?
0618   42B9 CA F6 44    	jp	z,START_WIFI_SCAN
0619   42BC FE 34       	cp	'4'							; Automatic Setting of Clock?
0620   42BE CA 18 43    	jp	z,START_CLK_AUTO
0621   42C1 CD C0 00    	call	BEEP					; Wrong Input, beep
0622   42C4 C3 A5 42    	jp	MM_WAIT_INPUT				; And return, waiting another key
0623   42C7             
0624   42C7             ;============================
0625   42C7             ;===  SETUP Menu Routines  ==
0626   42C7             ;===  Wi-Fi and Clock Menu ==
0627   42C7             ;============================
0628   42C7             CLK_MSX1_GO:
0629   42C7 21 FD 5D    	ld	hl,MMENU_CLOCK_MSX1
0630   42CA CD BF 4B    	call	PRINTHL					; Print Main Clock MSX1 message
0631   42CD CD 75 49    	call	ISCLKAUTO
0632   42D0 DD 7E 00    	ld	a,(ix+0)					; Auto Clock Current setting
0633   42D3 FE 03       	cp	3							; If 3 adapter disabled
0634   42D5 28 08       	jr	z,CLK_MSX1_ADAPTERDIS
0635   42D7 21 91 5E    	ld	hl,MMENU_CLOCK_0
0636   42DA CD BF 4B    	call	PRINTHL
0637   42DD 18 06       	jr	CLK_MSX1_OPT
0638   42DF             CLK_MSX1_ADAPTERDIS:
0639   42DF 21 D7 5E    	ld	hl,MMENU_CLOCK_3
0640   42E2 CD BF 4B    	call	PRINTHL
0641   42E5             CLK_MSX1_OPT:
0642   42E5 21 EA 5E    	ld	hl,MMENU_CLOCK_OPT
0643   42E8 CD BF 4B    	call	PRINTHL
0644   42EB             CLK_MSX1_WAIT_OPT_INPUT:
0645   42EB CD 9F 00    	call	CHGET
0646   42EE FE 1B       	cp	#1b							; ESC?
0647   42F0 CA F2 41    	jp	z,ESPSETUP					; Back to main menu
0648   42F3 FE 30       	cp	'0'
0649   42F5 CA 03 43    	jp	z,CLK_MSX1_SEND_CMD
0650   42F8 FE 33       	cp	'3'
0651   42FA CA BF 43    	jp	z,CLK_AUTO_WAIT_GMT
0652   42FD CD C0 00    	call	BEEP					; Wrong Input, beep
0653   4300 C3 EB 42    	jp	CLK_MSX1_WAIT_OPT_INPUT		; And return, waiting another key
0654   4303             CLK_MSX1_SEND_CMD:
0655   4303 CD A2 00    	call	CHPUT					; Print option
0656   4306 D6 30       	sub	'0'							; Adjust format
0657   4308 DD 77 00    	ld	(ix+0),a					; Save it
0658   430B 3E 0D       	ld	a,#0d
0659   430D CD A2 00    	call	CHPUT
0660   4310 3E 0A       	ld	a,#0a
0661   4312 CD A2 00    	call	CHPUT
0662   4315 C3 B6 44    	jp	CLK_AUTO_GMT_CHK_DONE		; And sending the command will be done there
0663   4318             
0664   4318             START_CLK_AUTO:
0665   4318 3E 34       	ld	a,'4'
0666   431A CD A2 00    	call	CHPUT
0667   431D CD 6E 49    	call	WAIT_250MS_AND_THEN_CONTINUE
0668   4320 3A 2D 00    	ld	a,(#002D)					; Check MSX Version
0669   4323 B7          	or	a
0670   4324 CA C7 42    	jp	z,CLK_MSX1_GO				; If zero, MSX1, so can just enable or disable adapter
0671   4327             CLK_AUTO_GO:
0672   4327 21 9D 5C    	ld	hl,MMENU_CLOCK_MSX2
0673   432A CD BF 4B    	call	PRINTHL					; Print Main Clock MSX2 message
0674   432D CD 75 49    	call	ISCLKAUTO
0675   4330 DD 7E 00    	ld	a,(ix+0)					; Auto Clock Current setting
0676   4333 B7          	or	a							; If zero, off
0677   4334 20 08       	jr	nz,CLK_AUTO_CHK1
0678   4336 21 91 5E    	ld	hl,MMENU_CLOCK_0
0679   4339 CD BF 4B    	call	PRINTHL
0680   433C 18 59       	jr	CLK_AUTO_GMT_OPT
0681   433E             CLK_AUTO_CHK1:
0682   433E 3D          	dec	a							; If 1, on and keep wifi on
0683   433F 20 08       	jr	nz,CLK_AUTO_CHK2
0684   4341 21 A3 5E    	ld	hl,MMENU_CLOCK_1
0685   4344 CD BF 4B    	call	PRINTHL
0686   4347 18 13       	jr	CLK_AUTO_GMT
0687   4349             CLK_AUTO_CHK2:
0688   4349 3D          	dec	a							; If 2, on and turn wifi off
0689   434A 20 08       	jr	nz,CLK_AUTO_3
0690   434C 21 BD 5E    	ld	hl,MMENU_CLOCK_2
0691   434F CD BF 4B    	call	PRINTHL
0692   4352 18 08       	jr	CLK_AUTO_GMT
0693   4354             CLK_AUTO_3:
0694   4354 21 D7 5E    	ld	hl,MMENU_CLOCK_3
0695   4357 CD BF 4B    	call	PRINTHL
0696   435A 18 3B       	jr	CLK_AUTO_GMT_OPT
0697   435C             CLK_AUTO_GMT:
0698   435C DD 66 01    	ld	h,(ix+1)					; Save it for now
0699   435F DD 7E 01    	ld	a,(ix+1)					; GMT current setting
0700   4362 CB 7F       	bit 7,a							; If set, is -
0701   4364 28 0B       	jr	z,CLK_AUTO_GMTP
0702   4366 3E 2D       	ld	a,'-'
0703   4368 CD A2 00    	call	CHPUT
0704   436B DD CB 01 BE 	res	7,(ix+1)					; Clear - indicator
0705   436F 18 05       	jr	CLK_AUTO_GMTM
0706   4371             CLK_AUTO_GMTP:
0707   4371 3E 2B       	ld	a,'+'
0708   4373 CD A2 00    	call	CHPUT
0709   4376             CLK_AUTO_GMTM:
0710   4376 3E 09       	ld	a,9
0711   4378 DD BE 01    	cp	(ix+1)						; Greater than 9?
0712   437B 30 0F       	jr	nc,CLK_AUTO_GMTD			; If not, just print what is in A + '0'
0713   437D 3E 31       	ld	a,'1'						; It is 1
0714   437F CD A2 00    	call	CHPUT
0715   4382 DD 7E 01    	ld	a,(ix+1)
0716   4385 C6 26       	add	'0'-10						; Need to subtract 10 and add '0' to print
0717   4387 CD A2 00    	call	CHPUT
0718   438A 18 0B       	jr	CLK_AUTO_GMT_OPT
0719   438C             CLK_AUTO_GMTD:
0720   438C 3E 30       	ld	a,'0'
0721   438E DD 86 01    	add	a,(ix+1)					; Our value
0722   4391 CD A2 00    	call	CHPUT
0723   4394 DD 74 01    	ld	(ix+1),h					; Restore original value
0724   4397             CLK_AUTO_GMT_OPT:
0725   4397 21 EA 5E    	ld	hl,MMENU_CLOCK_OPT
0726   439A CD BF 4B    	call	PRINTHL
0727   439D             CLK_AUTO_WAIT_OPT_INPUT:
0728   439D CD 9F 00    	call	CHGET
0729   43A0 FE 1B       	cp	#1b							; ESC?
0730   43A2 CA F2 41    	jp	z,ESPSETUP					; Back to main menu
0731   43A5 FE 30       	cp	'0'
0732   43A7 CA BF 43    	jp	z,CLK_AUTO_WAIT_GMT
0733   43AA FE 31       	cp	'1'
0734   43AC CA BF 43    	jp	z,CLK_AUTO_WAIT_GMT
0735   43AF FE 32       	cp	'2'
0736   43B1 CA BF 43    	jp	z,CLK_AUTO_WAIT_GMT
0737   43B4 FE 33       	cp	'3'
0738   43B6 CA BF 43    	jp	z,CLK_AUTO_WAIT_GMT
0739   43B9 CD C0 00    	call	BEEP					; Wrong Input, beep
0740   43BC C3 9D 43    	jp	CLK_AUTO_WAIT_OPT_INPUT		; And return, waiting another key
0741   43BF             CLK_AUTO_WAIT_GMT:
0742   43BF CD A2 00    	call	CHPUT					; Print option
0743   43C2 D6 30       	sub	'0'							; Adjust format
0744   43C4 DD 77 00    	ld	(ix+0),a					; Save it
0745   43C7 B7          	or	a
0746   43C8 CA B6 44    	jp	z,CLK_AUTO_GMT_CHK_DONE		; And send the command if just disabling clock auto set
0747   43CB FE 03       	cp	3
0748   43CD CA B6 44    	jp	z,CLK_AUTO_GMT_CHK_DONE		; Or send the command if just disabling the adapter
0749   43D0 21 14 5F    	ld	hl,MMENU_GMT_OPT
0750   43D3 CD BF 4B    	call	PRINTHL
0751   43D6 16 00       	ld	d,0							; # of digits entered
0752   43D8 1E 00       	ld	e,0							; # of characters printed
0753   43DA DD 36 01 00 	ld	(ix+1),0					; GMT 0
0754   43DE             CLK_AUTO_WAIT_GMT_INPUT:
0755   43DE CD 9F 00    	call	CHGET
0756   43E1 FE 1B       	cp	#1b							; ESC?
0757   43E3 CA F2 41    	jp	z,ESPSETUP					; Back to main menu
0758   43E6 FE 0D       	cp	#0d							; ENTER?
0759   43E8 CA 31 44    	jp	z,CLK_AUTO_GMT_CHK_INPUT	; Check if ok to send command
0760   43EB FE 08       	cp	#08							; Backspace?
0761   43ED CA 02 44    	jp	z,CLK_AUTO_GMT_CHK_BS		; Check if there is something to erase
0762   43F0 FE 2D       	cp	'-'							; Negative value?
0763   43F2 CA 31 44    	jp	z,CLK_AUTO_GMT_CHK_INPUT
0764   43F5 FE 30       	cp	'0'							; >=0?
0765   43F7 DA 23 44    	jp	c,CLK_AUTO_GMT_BAD_INPUT	; If not, bad input
0766   43FA FE 3A       	cp	'9'+1						; <= 9
0767   43FC D2 23 44    	jp	nc,CLK_AUTO_GMT_BAD_INPUT	; If not, bad input
0768   43FF C3 31 44    	jp	CLK_AUTO_GMT_CHK_INPUT		; Otherwise, validate digit
0769   4402             CLK_AUTO_GMT_CHK_BS:
0770   4402 AF          	xor	a
0771   4403 BB          	cp	e							; Anything on screen?
0772   4404 28 1D       	jr	z,CLK_AUTO_GMT_BAD_INPUT	; Nothing to erase
0773   4406 1D          	dec	e							; One less character on the screen
0774   4407 BA          	cp	d							; Any digit?
0775   4408 28 03       	jr	z,CLK_AUTO_GMT_CHK_BS_MIN	; If not, just erase - sign
0776   440A             	; There is, so it is one less digit
0777   440A 15          	dec	d
0778   440B 18 04       	jr	CLK_AUTO_GMT_CHK_DIGIT
0779   440D             CLK_AUTO_GMT_CHK_BS_MIN:
0780   440D DD 36 01 00 	ld	(ix+1),0					; Reset sign
0781   4411             CLK_AUTO_GMT_CHK_DIGIT:
0782   4411 3E 08       	ld	a,8							; Backspace
0783   4413 CD A2 00    	call	CHPUT					; Print it
0784   4416 3E 20       	ld	a,' '						; Space
0785   4418 CD A2 00    	call	CHPUT					; Print it
0786   441B 3E 08       	ld	a,8							; Backspace
0787   441D CD A2 00    	call	CHPUT					; Print it
0788   4420 C3 DE 43    	jp	CLK_AUTO_WAIT_GMT_INPUT		; Return
0789   4423             CLK_AUTO_GMT_BAD_INPUT:
0790   4423             	; Beep might use sub rom, and if so, all registers will be messed up, better save
0791   4423 C5          	push	bc
0792   4424 D5          	push	de
0793   4425 F5          	push	af
0794   4426 E5          	push	hl
0795   4427 CD C0 00    	call	BEEP					; Wrong Input, beep
0796   442A E1          	pop	hl
0797   442B F1          	pop	af
0798   442C D1          	pop	de
0799   442D C1          	pop bc
0800   442E C3 DE 43    	jp	CLK_AUTO_WAIT_GMT_INPUT		; And return, waiting another key
0801   4431             CLK_AUTO_GMT_CHK_INPUT:
0802   4431 4F          	ld	c,a							; Save in C for printing if needed
0803   4432 FE 2D       	cp	'-'							; - sign?
0804   4434 20 11       	jr	nz,CLK_AUTO_GMT_CHK_CR		; If not, check if enter
0805   4436             	; - sign
0806   4436 3E 00       	ld	a,0
0807   4438 BB          	cp	e							; If not the first character, can't accept
0808   4439 20 E8       	jr	nz,CLK_AUTO_GMT_BAD_INPUT
0809   443B             	; It is the first, so let's print it
0810   443B 79          	ld	a,c
0811   443C CD A2 00    	call	CHPUT
0812   443F DD 36 01 80 	ld	(ix+1),0x80					; Set the - sign bit, for now rest is zero
0813   4443 1C          	inc	e							; Increase # of characters printed
0814   4444 C3 DE 43    	jp	CLK_AUTO_WAIT_GMT_INPUT		; Continue waiting input
0815   4447             CLK_AUTO_GMT_CHK_CR:
0816   4447 FE 0D       	cp	#0d							; ENTER?
0817   4449 20 0F       	jr	nz,CLK_AUTO_GMT_CHK_CD		; If not, check if digit is valid
0818   444B             	; Enter
0819   444B 3E 00       	ld	a,0
0820   444D BA          	cp	d							; Ok, at least one digit entered?
0821   444E 28 D3       	jr	z,CLK_AUTO_GMT_BAD_INPUT	; No, so, enter is no good now
0822   4450             	; It is, if it had a digit entered and did not send, it was 1, so...
0823   4450 3E 01       	ld	a,1
0824   4452 DD B6 01    	or	a,(ix+1)					; Adjust sign, if needed
0825   4455 DD 77 01    	ld	(ix+1),a					; Save
0826   4458 18 5C       	jr	CLK_AUTO_GMT_CHK_DONE		; Ok, ready to send
0827   445A             CLK_AUTO_GMT_CHK_CD:
0828   445A             	; Ok, it is a digit
0829   445A 06 30       	ld	b,'0'
0830   445C 90          	sub	a,b							; A has digit value
0831   445D 47          	ld	b,a							; Save in B
0832   445E 3E 00       	ld	a,0
0833   4460 BA          	cp	d
0834   4461 20 1E       	jr	nz,CLK_AUTO_GMT_CHK_CSD		; If not zero, it is second digit, so almost done
0835   4463             	; 1st digit, let's check if it is other than 1, if it is, we are almost done
0836   4463 3E 01       	ld	a,1
0837   4465 B8          	cp	b
0838   4466 28 10       	jr	z,CLK_AUTO_GMT_CHK_CD.1		; If it is 1, wait next digit or enter
0839   4468             	; Not 1, so just adjust ix+1 and go
0840   4468 79          	ld	a,c
0841   4469 CD A2 00    	call	CHPUT					; Print it
0842   446C 78          	ld	a,b
0843   446D B7          	or	a
0844   446E 28 03       	jr	z,CLK_AUTO_SKIP_SIGN
0845   4470 DD B6 01    	or	a,(ix+1)					; Adjust sign, if needed
0846   4473             CLK_AUTO_SKIP_SIGN:
0847   4473 DD 77 01    	ld	(ix+1),a					; Save
0848   4476 18 3E       	jr	CLK_AUTO_GMT_CHK_DONE		; Ok, ready to send
0849   4478             CLK_AUTO_GMT_CHK_CD.1:
0850   4478 79          	ld	a,c
0851   4479 CD A2 00    	call	CHPUT					; Print it
0852   447C 14          	inc	d							; Digits entered now is 1
0853   447D 1C          	inc	e							; Digits printed increased
0854   447E C3 DE 43    	jp	CLK_AUTO_WAIT_GMT_INPUT		; Continue waiting input
0855   4481             CLK_AUTO_GMT_CHK_CSD:
0856   4481             	; Second digit, easy... First was 1, now need to check if it is 0, 1 or 2, otherwise, bad entry
0857   4481 78          	ld	a,b
0858   4482 06 03       	ld	b,3
0859   4484 B8          	cp	b
0860   4485 D2 23 44    	jp	nc,CLK_AUTO_GMT_BAD_INPUT	; 3 or more, so, not valid
0861   4488 B7          	or	a							; Is it zero?
0862   4489 20 0E       	jr	nz,CLK_AUTO_GMT_CHK_CSD1	; If not, check for 1
0863   448B             	; It was zero
0864   448B 3E 0A       	ld	a,10						; So, 10
0865   448D DD B6 01    	or	a,(ix+1)					; Adjust sign, if needed
0866   4490 DD 77 01    	ld	(ix+1),a					; Save
0867   4493 79          	ld	a,c
0868   4494 CD A2 00    	call	CHPUT					; Print it
0869   4497 18 1D       	jr	CLK_AUTO_GMT_CHK_DONE		; Ready to
0870   4499             CLK_AUTO_GMT_CHK_CSD1:
0871   4499 3D          	dec	a							; Is it one?
0872   449A 20 0E       	jr	nz,CLK_AUTO_GMT_CHK_CSD2
0873   449C             	; It was one
0874   449C 3E 0B       	ld	a,11						; So, eleven
0875   449E DD B6 01    	or	a,(ix+1)					; Adjust sign, if needed
0876   44A1 DD 77 01    	ld	(ix+1),a					; Save
0877   44A4 79          	ld	a,c
0878   44A5 CD A2 00    	call	CHPUT					; Print it
0879   44A8 18 0C       	jr	CLK_AUTO_GMT_CHK_DONE		; Ready to send
0880   44AA             CLK_AUTO_GMT_CHK_CSD2:
0881   44AA             	; It was two
0882   44AA 3E 0C       	ld	a,12						; So, twelve
0883   44AC DD B6 01    	or	a,(ix+1)					; Adjust sign, if needed
0884   44AF DD 77 01    	ld	(ix+1),a					; Save
0885   44B2 79          	ld	a,c
0886   44B3 CD A2 00    	call	CHPUT					; Print it
0887   44B6             	; And send command
0888   44B6             CLK_AUTO_GMT_CHK_DONE:
0889   44B6 3E 0D       	ld	a,#0d
0890   44B8 CD A2 00    	call	CHPUT
0891   44BB 3E 0A       	ld	a,#0a
0892   44BD CD A2 00    	call	CHPUT
0893   44C0 21 B6 64    	ld	hl,STR_SENDING
0894   44C3 CD BF 4B    	call	PRINTHL
0895   44C6 3E 14       	ld	a,20
0896   44C8 D3 06       	out	(OUT_CMD_PORT),a			; Clear UART
0897   44CA 3E 43       	ld	a,CMD_SET_ACLK_SETTINGS
0898   44CC D3 07       	out	(OUT_TX_PORT),a
0899   44CE 3E 00       	ld	a,0							; Size MSB is 0
0900   44D0 D3 07       	out	(OUT_TX_PORT),a
0901   44D2 3E 02       	ld	a,2							; Size LSB is 2
0902   44D4 D3 07       	out	(OUT_TX_PORT),a
0903   44D6 DD 7E 00    	ld	a,(ix+0)					; Option
0904   44D9 D3 07       	out	(OUT_TX_PORT),a
0905   44DB DD 7E 01    	ld	a,(ix+1)					; GMT
0906   44DE D3 07       	out	(OUT_TX_PORT),a
0907   44E0 21 3C 00    	ld	hl,60						; Wait Up To 1s
0908   44E3 3E 43       	ld	a,CMD_SET_ACLK_SETTINGS
0909   44E5 CD 8A 4A    	call	WAIT_MENU_QCMD_RESPONSE
0910   44E8 21 D1 64    	ld	hl,STR_SENDING_OK
0911   44EB 20 03       	jr	nz,CLK_AUTO_GMT_CHK_RESULT
0912   44ED 21 3E 65    	ld	hl,STR_SENDING_FAIL
0913   44F0             CLK_AUTO_GMT_CHK_RESULT:
0914   44F0 CD BF 4B    	call	PRINTHL
0915   44F3 C3 62 49    	jp	WAIT_2S_AND_THEN_MAINMENU
0916   44F6             
0917   44F6             ;============================
0918   44F6             ;===  SETUP Menu Routines  ==
0919   44F6             ;===    Wi-Fi Scan Menu    ==
0920   44F6             ;============================
0921   44F6             START_WIFI_SCAN:
0922   44F6 3E 33       	ld	a,'3'
0923   44F8 CD A2 00    	call	CHPUT
0924   44FB CD 6E 49    	call	WAIT_250MS_AND_THEN_CONTINUE
0925   44FE             START_WIFI_RESCAN:
0926   44FE 21 99 5F    	ld	hl,MMENU_SCAN
0927   4501 CD BF 4B    	call	PRINTHL					; Print Main Scan message
0928   4504 CD 13 49    	call	STARTWIFISCAN			; Request Wi-Fi Scan to start
0929   4507 ED 5B 76 F6 	ld	de,(TXTTAB)					; We will borrow Basic Program memory area for now...
0930   450B DD 6B       	ld	ixl,e
0931   450D DD 62       	ld	ixh,d						; Address in IX
0932   450F 11 14 00    	ld	de,20						; At least 10s waiting scan to finish, retry 20 times waiting 0.5s between attempts
0933   4512             WIFI_SCAN_WAIT_END:
0934   4512 3E 14       	ld	a,20
0935   4514 D3 06       	out	(OUT_CMD_PORT),a			; Clear UART
0936   4516 3E 73       	ld	a,CMD_SCAN_RESULTS
0937   4518 D3 07       	out	(OUT_TX_PORT),a
0938   451A 21 3C 00    	ld	hl,60						; Wait Up To 1s
0939   451D CD 3A 4B    	call	WAIT_MENU_SCMD_RESPONSE
0940   4520 C2 38 45    	jp	nz,WIFI_SCAN_SHOW_LIST		; if success show the list
0941   4523 78          	ld	a,b
0942   4524 FE 02       	cp	2							; If 2, scan is done and nothing found
0943   4526 CA 83 47    	jp	z,WIFI_SCAN_NONETWORKS
0944   4529 2E 1E       	ld	l,30
0945   452B             WIFI_SCAN_WAITHS:
0946   452B 76          	halt
0947   452C 2D          	dec	l
0948   452D 20 FC       	jr	nz,WIFI_SCAN_WAITHS
0949   452F 1B          	dec	de
0950   4530 7B          	ld	a,e
0951   4531 B2          	or	d
0952   4532 CA 8C 47    	jp	z,WIFI_SCAN_TIMEOUT
0953   4535 C3 12 45    	jp	WIFI_SCAN_WAIT_END
0954   4538             WIFI_SCAN_SHOW_LIST:
0955   4538 57          	ld	d,a							; Save access point counter here
0956   4539 1E 00       	ld	e,0							; And here how many were printed
0957   453B 21 1E 60    	ld	hl,MMENU_SCANS
0958   453E CD BF 4B    	call	PRINTHL
0959   4541 DD E5       	push	ix
0960   4543 E1          	pop	hl							; IX in HL
0961   4544             WIFI_LIST_LOOP:
0962   4544 7B          	ld	a,e
0963   4545 C6 30       	add	a,'0'						; Convert to number
0964   4547 CD A2 00    	call	CHPUT
0965   454A 3E 20       	ld	a,' '						; Space
0966   454C CD A2 00    	call	CHPUT
0967   454F 3E 2D       	ld	a,'-'						; Dash
0968   4551 CD A2 00    	call	CHPUT
0969   4554 3E 20       	ld	a,' '						; Space
0970   4556 CD A2 00    	call	CHPUT
0971   4559 06 18       	ld	b,24						; Cuts AP names > 23 chars
0972   455B             PRT_APNAMELP:
0973   455B 7E          	ld	a,(hl)
0974   455C B7          	or	a
0975   455D CA 77 45    	jp	z,PRT_APENC
0976   4560 CD A2 00    	call	CHPUT
0977   4563 23          	inc	hl
0978   4564 10 F5       	djnz	PRT_APNAMELP
0979   4566 E5          	push	hl
0980   4567 21 AD 61    	ld	hl,SCAN_TERMINATOR_CUT
0981   456A CD BF 4B    	call	PRINTHL
0982   456D E1          	pop	hl
0983   456E             PRT_APNAMELP_CUT:
0984   456E 7E          	ld	a,(hl)
0985   456F B7          	or	a
0986   4570 CA 77 45    	jp	z,PRT_APENC
0987   4573 23          	inc	hl
0988   4574 C3 6E 45    	jp	PRT_APNAMELP_CUT
0989   4577             PRT_APENC:
0990   4577 23          	inc	hl
0991   4578 7E          	ld	a,(hl)
0992   4579 B7          	or	a
0993   457A CA 88 45    	jp	z,PRT_APNOTENC
0994   457D E5          	push	hl
0995   457E 21 B5 61    	ld	hl,SCAN_TERMINATOR_ENC
0996   4581 CD BF 4B    	call	PRINTHL
0997   4584 E1          	pop	hl
0998   4585 C3 90 45    	jp	PRT_AP_CHKLOOP
0999   4588             PRT_APNOTENC:
1000   4588 E5          	push	hl
1001   4589 21 B8 61    	ld	hl,SCAN_TERMINATOR_OPEN
1002   458C CD BF 4B    	call	PRINTHL
1003   458F E1          	pop	hl
1004   4590             PRT_AP_CHKLOOP:
1005   4590 23          	inc	hl
1006   4591 1C          	inc	e
1007   4592 3E 08       	ld	a,SCAN_MAX_PAGE_SIZE
1008   4594 BB          	cp	e
1009   4595 CA A0 45    	jp	z,APLIST_OVERFLOW
1010   4598 15          	dec	d
1011   4599 C2 44 45    	jp	nz,WIFI_LIST_LOOP
1012   459C 06 00       	ld	b,0							; Signal no more list data
1013   459E 18 10       	jr	APLIST_NO_OVERFLOW
1014   45A0             APLIST_OVERFLOW:
1015   45A0 15          	dec	d							; Update remaining itens
1016   45A1 AF          	xor	a
1017   45A2 B2          	or	d							; Still has itens?
1018   45A3 28 0B       	jr	z,APLIST_NO_OVERFLOW		; No more itens
1019   45A5 06 01       	ld	b,1							; Signal that there still is data pending to list in another page
1020   45A7 E5          	push	hl
1021   45A8 FD E1       	pop	iy							; Save in IY the address to continue from
1022   45AA 4A          	ld	c,d							; And C has the remaining AP count
1023   45AB 21 3E 61    	ld	hl,MMENU_SCANQM
1024   45AE 18 03       	jr	APLIST_NOFLW
1025   45B0             APLIST_NO_OVERFLOW:
1026   45B0             	; If here, current page has been printed
1027   45B0             	; E has the maximum allowable AP number
1028   45B0             	; B will indicate if there are more itens for a next page
1029   45B0             	; IY will hold the address of the following itens
1030   45B0             	; Let's ask which one to connect
1031   45B0 21 D3 60    	ld	hl,MMENU_SCANQ
1032   45B3             APLIST_NOFLW:
1033   45B3 CD BF 4B    	call	PRINTHL					; Show message asking which network to connect
1034   45B6 3E 30       	ld	a,'0'
1035   45B8 83          	add	a,e
1036   45B9 5F          	ld	e,a							; To make it easy in the selection screen
1037   45BA             WIFI_SELECT_AP:
1038   45BA CD 9F 00    	call	CHGET
1039   45BD FE 1B       	cp	#1b							; ESC?
1040   45BF CA F2 41    	jp	z,ESPSETUP					; When done, back to main setup
1041   45C2 FE 20       	cp	#20							; Spacebar?
1042   45C4 CA D8 45    	jp	z,WIFI_SELECT_SPACEBAR		; Check if re-scan or next page
1043   45C7 FE 0D       	cp	CR							; ENTER?
1044   45C9 CA E5 45    	jp	z,WIFI_CONNECT_ME_CHOOSEN	; Request AP Name and Password if needed
1045   45CC FE 30       	cp	'0'							; Check if A is less than 0
1046   45CE DA 6D 47    	jp	c,INPUT_WFSAP_BAD_INPUT		; If it is, ignore
1047   45D1 BB          	cp	e							; Check if a is greater than what is in E
1048   45D2 D2 6D 47    	jp	nc,INPUT_WFSAP_BAD_INPUT	; If it is, ignore
1049   45D5 C3 58 46    	jp	WIFI_CONNECT_SELECTION_OK	; Selection Ok if here
1050   45D8             
1051   45D8             WIFI_SELECT_SPACEBAR:
1052   45D8 AF          	xor	a
1053   45D9 B0          	or	b
1054   45DA CA FE 44    	jp	z,START_WIFI_RESCAN			; Rescan if no more itens
1055   45DD             	; Otherwise, more itens, start at IY
1056   45DD FD E5       	push	iy
1057   45DF DD E1       	pop	ix							; Restore the list from where we finished last time
1058   45E1 79          	ld	a,c							; Restore the remaining APs to list
1059   45E2 C3 38 45    	jp	WIFI_SCAN_SHOW_LIST			; And show
1060   45E5             
1061   45E5             WIFI_CONNECT_ME_CHOOSEN:
1062   45E5 21 2D 5F    	ld	hl,MMENU_MANUALENTRY
1063   45E8 CD BF 4B    	call	PRINTHL					; Show message asking AP details....
1064   45EB             	; IX has the AP list, we don't care, but that address is ours to use to handle SSID Entry
1065   45EB DD E5       	push	ix
1066   45ED E1          	pop	hl							; HL has the address
1067   45EE 0E 00       	ld	c,0							; AP name size
1068   45F0             WIFI_CONNECT_MANUAL_ENTRY:
1069   45F0 CD 9F 00    	call	CHGET
1070   45F3 FE 1B       	cp	#1b							; ESC?
1071   45F5 CA F2 41    	jp	z,ESPSETUP					; Back to main setup
1072   45F8 FE 08       	cp	#08							; Backspace?
1073   45FA 28 3E       	jr	z,WIFI_CONNECT_ME_BS		; Check if there is something to erase
1074   45FC FE 0D       	cp	#0d							; ENTER?
1075   45FE 28 51       	jr	z,WIFI_ME_CHECK_INPUT		; Check if ok
1076   4600             	; Otherwise it is a digit
1077   4600 77          	ld	(hl),a
1078   4601 0C          	inc	c
1079   4602 23          	inc hl
1080   4603 FE 20       	cp	32
1081   4605 30 04       	jr	nc,WIFI_CONNECT_ME_CHKPRT2	; Ok, not below space, but is it delete?
1082   4607 3E 3F       	ld	a,'?'						; Prints a question mark
1083   4609 18 06       	jr	WIFI_CONNECT_ME_CHKPRTD
1084   460B             WIFI_CONNECT_ME_CHKPRT2:
1085   460B FE 7F       	cp	#7f
1086   460D 20 02       	jr	nz,WIFI_CONNECT_ME_CHKPRTD
1087   460F 3E 3F       	ld	a,'?'						; Prints a question mark if it is delete
1088   4611             WIFI_CONNECT_ME_CHKPRTD:
1089   4611 CD A2 00    	call	CHPUT					; Print a char
1090   4614 3E 20       	ld	a,32						; SSID maximum is 32 characters
1091   4616 B9          	cp	c							; Have we hit it?
1092   4617 20 D7       	jr	nz,WIFI_CONNECT_MANUAL_ENTRY; No, just continue waiting characters
1093   4619             	; Hit the limit or Enter when C not zero
1094   4619             WIFI_CONNECT_ME_0_TERM:
1095   4619 AF          	xor	a
1096   461A 77          	ld	(hl),a
1097   461B 23          	inc	hl
1098   461C E5          	push	hl						; Save it
1099   461D 21 84 5F    	ld	hl,MENU_MANUALENTRY_PWD
1100   4620 CD BF 4B    	call	PRINTHL					; We are asking if password is needed
1101   4623 E1          	pop	hl							; Restore it
1102   4624 CD 9F 00    	call	CHGET					; Get key, if Y or y, needed, otherwise not
1103   4627 CD A2 00    	call	CHPUT					; Print what was typed
1104   462A CB AF       	res	5,a							; Force upper case
1105   462C FE 59       	cp	'Y'
1106   462E 3E 01       	ld	a,1							; Do not change flags, pwd needed
1107   4630 28 01       	jr	z,WIFI_CONNECT_ME_PWD		; And tell using encryption
1108   4632 AF          	xor	a							; Ok, if here, no pwd, so no encryption
1109   4633             WIFI_CONNECT_ME_PWD:
1110   4633 77          	ld	(hl),a						; Save if encryption is expected
1111   4634 DD E5       	push	ix
1112   4636 E1          	pop	hl							; HL containing the beginning of SSID name
1113   4637 C3 7C 46    	jp	WIFI_CONNECT_AP_PWDQ		; And the rest is handled like if menu selected
1114   463A             WIFI_CONNECT_ME_BS:
1115   463A AF          	xor	a
1116   463B B9          	cp	c							; Has any data to delete?
1117   463C 28 B2       	jr	z,WIFI_CONNECT_MANUAL_ENTRY	; No
1118   463E             	; Yes
1119   463E 2B          	dec	hl							; Decrement pointer
1120   463F 0D          	dec	c							; Decrement counter
1121   4640 3E 08       	ld	a,8							; Backspace
1122   4642 CD A2 00    	call	CHPUT					; Print it
1123   4645 3E 20       	ld	a,' '						; Space
1124   4647 CD A2 00    	call	CHPUT					; Print it
1125   464A 3E 08       	ld	a,8							; Backspace
1126   464C CD A2 00    	call	CHPUT					; Print it
1127   464F 18 9F       	jr	WIFI_CONNECT_MANUAL_ENTRY	; Return
1128   4651             WIFI_ME_CHECK_INPUT:
1129   4651 AF          	xor	a
1130   4652 B9          	cp	c							; Has received any data?
1131   4653 28 9B       	jr	z,WIFI_CONNECT_MANUAL_ENTRY	; No
1132   4655 C3 19 46    	jp	WIFI_CONNECT_ME_0_TERM		; Yes, so handle SSID input termination
1133   4658             
1134   4658             WIFI_CONNECT_SELECTION_OK:
1135   4658 CD A2 00    	call	CHPUT					; Valid input, print it
1136   465B 1E 30       	ld	e,'0'
1137   465D 93          	sub	a,e							; Get in decimal
1138   465E 5F          	ld	e,a							; Back in E
1139   465F             	; IX has the AP list, A which one has been selected, now our routine will do it
1140   465F 3E 0D       	ld	a,#0d
1141   4661 CD A2 00    	call	CHPUT
1142   4664 3E 0A       	ld	a,#0a
1143   4666 CD A2 00    	call	CHPUT
1144   4669 DD E5       	push	ix
1145   466B E1          	pop	hl							; put IX in HL
1146   466C             WIFI_CONNECT_AP_SRCH:
1147   466C 7B          	ld	a,e
1148   466D B7          	or	a
1149   466E             WIFI_CONNECT_AP_SRCH.1:
1150   466E CA 7C 46    	jp	z,WIFI_CONNECT_AP_PWDQ
1151   4671 7E          	ld	a,(hl)
1152   4672 23          	inc	hl
1153   4673 B7          	or	a
1154   4674 C2 6E 46    	jp	nz,WIFI_CONNECT_AP_SRCH.1	; Find string terminator
1155   4677             	; Found, jump encryption byte
1156   4677 23          	inc	hl
1157   4678 1D          	dec	e							; Decrement selection, if 0 we are done
1158   4679 C2 6E 46    	jp	nz,WIFI_CONNECT_AP_SRCH.1
1159   467C             WIFI_CONNECT_AP_PWDQ:
1160   467C             	; HL has the address of AP name string
1161   467C 54          	ld	d,h
1162   467D 5D          	ld	e,l							; Save copy in D
1163   467E 01 00 00    	ld	bc,0						; BC will have the ap connection data lenght
1164   4681             WIFI_CONNECT_APSIZE:
1165   4681 03          	inc	bc
1166   4682 1A          	ld	a,(de)
1167   4683 13          	inc	de
1168   4684 B7          	or	a
1169   4685 C2 81 46    	jp	nz,WIFI_CONNECT_APSIZE		; Count size, including zero terminator
1170   4688             	; Check for encryption
1171   4688 1A          	ld	a,(de)
1172   4689 B7          	or	a
1173   468A CA 1B 47    	jp	z,WIFI_CONNECT_SENDCMD		; If no password requested, good to go
1174   468D             	; Shoot, need to request password, well, let's do it
1175   468D E5          	push	hl						; Save HL
1176   468E 21 90 60    	ld	hl,MMENU_ASKPWD
1177   4691 CD BF 4B    	call	PRINTHL					; Inform that user need to input PWD
1178   4694 E1          	pop	hl							; Restore HL
1179   4695 FD 21 00 00 	ld	iy,0						; IY will help in backspacing
1180   4699 DD 26 01    	ld	ixh,1						; Start hidden
1181   469C             WIFI_CONNECT_RCV_PWD:
1182   469C CD 9F 00    	call	CHGET
1183   469F FE 1B       	cp	#1b							; ESC?
1184   46A1 CA F2 41    	jp	z,ESPSETUP					; When done, back to main setup
1185   46A4 FE 08       	cp	#08							; Backspace?
1186   46A6 CA F7 46    	jp	z,WIFI_CONNECT_RCV_PWD_BS	; Check if there is something to erase
1187   46A9 FE 0D       	cp	#0d							; ENTER?
1188   46AB CA 14 47    	jp	z,WIFI_PWD_CHECK_INPUT		; Check if ok
1189   46AE FE 7F       	cp	#7f							; Delete?
1190   46B0 CA E3 46    	jp	z,WIFI_CONNECT_RCV_PWDH		; Change password from clear to hidden or vice versa
1191   46B3             WIFI_CONNECT_RCV_PWD_STR:
1192   46B3             	; Ok, so it is a digit and store
1193   46B3 12          	ld	(de),a
1194   46B4 FD 7D       	ld	a,iyl
1195   46B6 D6 3F       	sub	63							; 63 chars password limit (WPA2 encryption)
1196   46B8 28 E2       	jr	z,WIFI_CONNECT_RCV_PWD
1197   46BA 1A          	ld	a,(de)
1198   46BB 03          	inc	bc
1199   46BC 13          	inc	de
1200   46BD FD 23       	inc	iy							; Increment counters and pointer
1201   46BF F5          	push	af						; Save A
1202   46C0 DD 7C       	ld	a,ixh
1203   46C2 B7          	or	a							; If zero, print char, otherwise print *
1204   46C3 28 09       	jr	z,WIFI_CONNECT_RCV_PWD_CHAR
1205   46C5 F1          	pop	af
1206   46C6 3E 2A       	ld	a,'*'						; Print * and keep password hidden
1207   46C8 CD A2 00    	call	CHPUT
1208   46CB C3 9C 46    	jp	WIFI_CONNECT_RCV_PWD		; And back to receiving digits
1209   46CE             WIFI_CONNECT_RCV_PWD_CHAR:
1210   46CE F1          	pop	af
1211   46CF FE 20       	cp	32
1212   46D1 30 04       	jr	nc,WIFI_CONNECT_RCV_CHKPRT2	; Ok, not below space, but is it delete?
1213   46D3 3E 3F       	ld	a,'?'						; Prints a question mark
1214   46D5 18 06       	jr	WIFI_CONNECT_RCV_CHKPRTD
1215   46D7             WIFI_CONNECT_RCV_CHKPRT2:
1216   46D7 FE 7F       	cp	#7f
1217   46D9 20 02       	jr	nz,WIFI_CONNECT_RCV_CHKPRTD
1218   46DB 3E 3F       	ld	a,'?'						; Prints a question mark if it is delete
1219   46DD             WIFI_CONNECT_RCV_CHKPRTD:
1220   46DD CD A2 00    	call	CHPUT					; Print a char
1221   46E0 C3 9C 46    	jp	WIFI_CONNECT_RCV_PWD		; And back to receiving digits
1222   46E3             
1223   46E3             WIFI_CONNECT_RCV_PWDH:
1224   46E3 FD 7D       	ld	a,iyl
1225   46E5 FD B4       	or	iyh
1226   46E7 C2 B3 46    	jp	nz,WIFI_CONNECT_RCV_PWD_STR	; If digits entered, can't change password behavior, so it is a pass phrase char
1227   46EA AF          	xor	a
1228   46EB DD B4       	or	ixh
1229   46ED DD 26 01    	ld	ixh,1
1230   46F0 28 AA       	jr	z,WIFI_CONNECT_RCV_PWD		; Return if it was 0
1231   46F2 DD 26 00    	ld	ixh,0
1232   46F5 28 A5       	jr	z,WIFI_CONNECT_RCV_PWD		; Otherwise set to 0 and return
1233   46F7             
1234   46F7             WIFI_CONNECT_RCV_PWD_BS:
1235   46F7 FD 7D       	ld	a,iyl
1236   46F9 FD B4       	or	iyh
1237   46FB CA 9C 46    	jp	z,WIFI_CONNECT_RCV_PWD		; If no digits entered, nothing to erase
1238   46FE FD 2B       	dec	iy							; Decrement counter
1239   4700 0B          	dec	bc							; Decrement counter
1240   4701 1B          	dec	de							; Decrement pointer
1241   4702 3E 08       	ld	a,8							; Backspace
1242   4704 CD A2 00    	call	CHPUT					; Print it
1243   4707 3E 20       	ld	a,' '						; Space
1244   4709 CD A2 00    	call	CHPUT					; Print it
1245   470C 3E 08       	ld	a,8							; Backspace
1246   470E CD A2 00    	call	CHPUT					; Print it
1247   4711 C3 9C 46    	jp	WIFI_CONNECT_RCV_PWD		; Return
1248   4714             
1249   4714             WIFI_PWD_CHECK_INPUT:
1250   4714 FD 7D       	ld	a,iyl
1251   4716 FD B4       	or	iyh
1252   4718 CA 9C 46    	jp	z,WIFI_CONNECT_RCV_PWD		; If no digits entered, no password to send
1253   471B             	; Otherwise done and ready to send
1254   471B             WIFI_CONNECT_SENDCMD:
1255   471B CD 6E 49    	call	WAIT_250MS_AND_THEN_CONTINUE
1256   471E E5          	push	hl
1257   471F 21 54 60    	ld	HL,MMENU_CONNECTING
1258   4722 CD BF 4B    	call	PRINTHL
1259   4725 E1          	pop	hl
1260   4726             	; Print AP name
1261   4726 E5          	push	hl
1262   4727 CD BF 4B    	call	PRINTHL
1263   472A E1          	pop	hl
1264   472B 3E 0D       	ld	a,CR
1265   472D CD A2 00    	call	CHPUT
1266   4730 3E 0A       	ld	a,LF
1267   4732 CD A2 00    	call	CHPUT
1268   4735 CD A2 00    	call	CHPUT
1269   4738             	; HL has the address of our data, BC the data size, so it is just needed to send the command
1270   4738 3E 14       	ld	a,20
1271   473A D3 06       	out	(OUT_CMD_PORT),a			; Clear UART
1272   473C 3E 41       	ld	a,CMD_WIFI_CONNECT
1273   473E D3 07       	out	(OUT_TX_PORT),a
1274   4740 78          	ld	a,b							; Size MSB is in B
1275   4741 D3 07       	out	(OUT_TX_PORT),a
1276   4743 79          	ld	a,c							; Size LSB is in c
1277   4744 D3 07       	out	(OUT_TX_PORT),a
1278   4746             WIFI_CONNECT_SENDCMDLP:
1279   4746 7E          	ld	a,(hl)
1280   4747 D3 07       	out	(OUT_TX_PORT),a
1281   4749 23          	inc	hl
1282   474A 0B          	dec	bc
1283   474B 78          	ld	a,b
1284   474C B1          	or	c
1285   474D C2 46 47    	jp	nz,WIFI_CONNECT_SENDCMDLP
1286   4750 21 58 02    	ld	hl,600						; Wait Up To 10s
1287   4753 3E 41       	ld	a,CMD_WIFI_CONNECT			; Our command
1288   4755 CD 8A 4A    	call	WAIT_MENU_QCMD_RESPONSE
1289   4758 CA 64 47    	jp	z,WIFI_CONNECT_FAIL
1290   475B 21 EA 64    	ld	hl,STR_SENDING_OK_JN		; Success
1291   475E CD BF 4B    	call	PRINTHL
1292   4761 C3 62 49    	jp	WAIT_2S_AND_THEN_MAINMENU
1293   4764             WIFI_CONNECT_FAIL:
1294   4764 21 04 65    	ld	hl,STR_SENDING_NOK_JN		; Failure
1295   4767 CD BF 4B    	call	PRINTHL
1296   476A C3 5E 49    	jp	WAIT_4S_AND_THEN_MAINMENU
1297   476D             
1298   476D             INPUT_WFSAP_BAD_INPUT:
1299   476D C5          	push	bc
1300   476E D5          	push	de
1301   476F F5          	push	af
1302   4770 E5          	push	hl
1303   4771 DD E5       	push	ix
1304   4773 FD E5       	push	iy
1305   4775 CD C0 00    	call	BEEP					; Wrong Input, beep
1306   4778 FD E1       	pop	iy
1307   477A DD E1       	pop	ix
1308   477C E1          	pop	hl
1309   477D F1          	pop	af
1310   477E D1          	pop	de
1311   477F C1          	pop bc
1312   4780 C3 BA 45    	jp WIFI_SELECT_AP				; Return
1313   4783             
1314   4783             WIFI_SCAN_NONETWORKS:
1315   4783 21 07 60    	ld	hl,MMENU_SCANN
1316   4786 CD BF 4B    	call	PRINTHL
1317   4789 C3 5E 49    	jp	WAIT_4S_AND_THEN_MAINMENU
1318   478C             
1319   478C             WIFI_SCAN_TIMEOUT:
1320   478C 21 E7 5F    	ld	hl,MMENU_SCANF
1321   478F CD BF 4B    	call	PRINTHL
1322   4792 C3 5E 49    	jp	WAIT_4S_AND_THEN_MAINMENU
1323   4795             
1324   4795             SET_WIFI_TIMEOUT:
1325   4795 3E 32       	ld	a,'2'
1326   4797 CD A2 00    	call	CHPUT
1327   479A CD 6E 49    	call	WAIT_250MS_AND_THEN_CONTINUE
1328   479D 21 BB 61    	ld	hl,MMENU_TIMEOUT
1329   47A0 CD BF 4B    	call	PRINTHL					; Print Main Timeout message
1330   47A3 CD DB 49    	call	CHECKTIMEOUT			; TimeOut is on or off?
1331   47A6 CA BE 47    	jp	z,WIFI_SET_ALWAYS_ON		; If 0, always on
1332   47A9             	; Otherwise there is a timeout
1333   47A9 E5          	push	hl
1334   47AA 21 F2 62    	ld hl,MMENU_TIMEOUT_NOTALWAYSON1
1335   47AD CD BF 4B    	call	PRINTHL
1336   47B0 E1          	pop	hl
1337   47B1 CD BF 4B    	call	PRINTHL
1338   47B4 21 08 63    	ld hl,MMENU_TIMEOUT_NOTALWAYSON2
1339   47B7 CD BF 4B    	call	PRINTHL
1340   47BA 16 00       	ld	d,0							; Count digits
1341   47BC 18 10       	jr	INPUT_TIMEOUT
1342   47BE             WIFI_SET_ALWAYS_ON:
1343   47BE 21 9D 62    	ld	hl,MMENU_TIMEOUT_ALWAYSON
1344   47C1 CD BF 4B    	call	PRINTHL
1345   47C4 ED 5B 76 F6 	ld	de,(TXTTAB)					; We will borrow Basic Program memory area for now...
1346   47C8 DD 6B       	ld	ixl,e
1347   47CA DD 62       	ld	ixh,d						; Address in IX
1348   47CC 16 00       	ld	d,0							; Count digits
1349   47CE             INPUT_TIMEOUT:
1350   47CE CD 9F 00    	call	CHGET
1351   47D1 FE 1B       	cp	#1b							; ESC?
1352   47D3 CA F2 41    	jp	z,ESPSETUP					; When done, back to main setup
1353   47D6 FE 0D       	cp	#0d							; ENTER?
1354   47D8 CA 1C 48    	jp	z,SET_WIFI_CHECK_INPUT		; Check if ok
1355   47DB FE 08       	cp	#08							; Backspace?
1356   47DD CA 02 48    	jp	z,SET_WIFI_BS_INPUT			; Check if there is something to erase
1357   47E0 FE 30       	cp	'0'							; Check if A is less than 0
1358   47E2 DA FC 47    	jp	c,INPUT_TIMEOUT_BAD_INPUT	; if it is, ignore
1359   47E5 FE 3A       	cp	'9'+1						; Check if a is greater than  9
1360   47E7 D2 FC 47    	jp	nc,INPUT_TIMEOUT_BAD_INPUT	; If it is, ignore
1361   47EA DD 77 00    	ld	(ix+0),a					; Save it
1362   47ED CD A2 00    	call	CHPUT					; It is valid, so print it
1363   47F0 14          	inc	d							; Increment digit count
1364   47F1 DD 23       	inc	ix							; Increment pointer
1365   47F3 3E 03       	ld	a,3
1366   47F5 BA          	cp	d
1367   47F6 CA 1C 48    	jp	z,SET_WIFI_CHECK_INPUT		; All we can do is accept up to 3 digits, check if ok
1368   47F9 C3 CE 47    	jp	INPUT_TIMEOUT				; Not done yet, so continue
1369   47FC             
1370   47FC             INPUT_TIMEOUT_BAD_INPUT:
1371   47FC CD C0 00    	call	BEEP					; Wrong Input, beep
1372   47FF C3 CE 47    	jp INPUT_TIMEOUT				; Return
1373   4802             
1374   4802             SET_WIFI_BS_INPUT:
1375   4802 AF          	xor	a
1376   4803 B2          	or	d							; Counter has any digit?
1377   4804 CA CE 47    	jp	z,INPUT_TIMEOUT				; Nope, so just continue
1378   4807 15          	dec	d							; Decrement counter
1379   4808 DD 2B       	dec	ix							; Decrement pointer
1380   480A 3E 08       	ld	a,8							; Backspace
1381   480C CD A2 00    	call	CHPUT					; Print it
1382   480F 3E 20       	ld	a,' '						; Space
1383   4811 CD A2 00    	call	CHPUT					; Print it
1384   4814 3E 08       	ld	a,8							; Backspace
1385   4816 CD A2 00    	call	CHPUT					; Print it
1386   4819 C3 CE 47    	jp	INPUT_TIMEOUT				; Return
1387   481C             
1388   481C             SET_WIFI_CHECK_INPUT:
1389   481C AF          	xor	a
1390   481D B2          	or	d							; Counter has any digits
1391   481E CA CE 47    	jp	z,INPUT_TIMEOUT				; Nope, so just continue
1392   4821             	; IX is pointing one position after last digit, so revert
1393   4821 DD 2B       	dec	ix
1394   4823 DD 7E 00    	ld	a,(ix+0)					; Digit in A
1395   4826 D6 30       	sub	'0'							; Convert it to decimal
1396   4828 26 00       	ld	h,0							; First digit, so H is 0
1397   482A 6F          	ld	l,a							; And L has the digit
1398   482B 15          	dec	d							; If digits finished, just set
1399   482C CA 58 48    	jp	z,SET_WIFI_EXECUTE_SET_COMMAND
1400   482F DD 2B       	dec	ix
1401   4831 DD 7E 00    	ld	a,(ix+0)					; Digit in A
1402   4834 D6 30       	sub	'0'							; Convert it to decimal
1403   4836 87          	add	a,a							; A*2
1404   4837 4F          	ld	c,a							; A*2 in C
1405   4838 87          	add	a,a							; A*4
1406   4839 87          	add	a,a							; A*8
1407   483A 81          	add	a,c							; A*10
1408   483B             	; Up to here, we can get 90 + 9, 99, won't go to H anyway, just add to L
1409   483B 85          	add	a,l							; L has the first digit
1410   483C 6F          	ld	l,a							; And now L has the two digits
1411   483D 15          	dec	d							; If digits finished, just set
1412   483E CA 58 48    	jp	z,SET_WIFI_EXECUTE_SET_COMMAND
1413   4841 DD 2B       	dec	ix
1414   4843 DD 7E 00    	ld	a,(ix+0)					; Digit in A
1415   4846 D6 30       	sub	'0'							; Convert it to decimal
1416   4848 87          	add	a,a							; A*2
1417   4849 4F          	ld	c,a							; A*2 in C
1418   484A 87          	add	a,a							; A*4
1419   484B 87          	add	a,a							; A*8
1420   484C 81          	add	a,c							; A*10
1421   484D EB          	ex	de,hl						; Get the two digits results in de
1422   484E 6F          	ld	l,a
1423   484F 26 00       	ld	h,0							; HL = A*10
1424   4851 29          	add	hl,hl						; HL = A*20
1425   4852 4D          	ld	c,l
1426   4853 44          	ld	b,h							; BC = A*20
1427   4854 29          	add	hl,hl						; HL = A*40
1428   4855 29          	add	hl,hl						; HL = A*80
1429   4856 09          	add	hl,bc						; HL = A*100
1430   4857 19          	add	hl,de						; HL = three digits result
1431   4858             	; This was the last digit, up to three
1432   4858             SET_WIFI_EXECUTE_SET_COMMAND:
1433   4858 C3 AA 48    	jp	SET_ESP_WIFI_TIMEOUT		; And set and done
1434   485B             
1435   485B             ;============================
1436   485B             ;===  SETUP Menu Routines  ==
1437   485B             ;===      NAGLE Menu       ==
1438   485B             ;============================
1439   485B             SET_NAGLE:
1440   485B 3E 31       	ld	a,'1'
1441   485D CD A2 00    	call	CHPUT
1442   4860 CD 6E 49    	call	WAIT_250MS_AND_THEN_CONTINUE
1443   4863 21 40 63    	ld	hl,MMENU_NAGLE
1444   4866 CD BF 4B    	call	PRINTHL					; Print Main Nagle message
1445   4869 CD 8F 49    	call	CHECKNAGLE				; Nagle is on or off?
1446   486C 20 1E       	jr	nz,NAGLE_IS_ON				;
1447   486E 21 75 64    	ld	hl,MMENU_NAGLE_OFF			; Show the menu telling nagle is off
1448   4871 CD BF 4B    	call	PRINTHL					; Print options
1449   4874             SET_NAGLE_WI_ON:
1450   4874 CD 9F 00    	call	CHGET
1451   4877 FE 1B       	cp	#1b							; ESC?
1452   4879 CA F2 41    	jp	z,ESPSETUP					; When done, back to main setup
1453   487C FE 4F       	cp	'O'							; Toggle Nagle On
1454   487E CA 2F 49    	jp	z,SET_NAGLE_ON				;
1455   4881 FE 6F       	cp	'o'							; Toggle Nagle On
1456   4883 CA 2F 49    	jp	z,SET_NAGLE_ON				;
1457   4886 CD C0 00    	call	BEEP					; Wrong Input, beep
1458   4889 C3 74 48    	jp	SET_NAGLE_WI_ON				; And return waiting key
1459   488C             
1460   488C             NAGLE_IS_ON:
1461   488C 21 35 64    	ld	hl,MMENU_NAGLE_ON			; Show the menu telling nagle is on
1462   488F CD BF 4B    	call	PRINTHL					; Print options
1463   4892             SET_NAGLE_WI_OFF:
1464   4892 CD 9F 00    	call	CHGET
1465   4895 FE 1B       	cp	#1b							; ESC?
1466   4897 CA F2 41    	jp	z,ESPSETUP					; When done, back to main setup
1467   489A FE 4F       	cp	'O'							; Toggle Nagle Off
1468   489C CA E4 48    	jp	z,SET_NAGLE_OFF				;
1469   489F FE 6F       	cp	'o'							; Toggle Nagle Off
1470   48A1 CA E4 48    	jp	z,SET_NAGLE_OFF				;
1471   48A4 CD C0 00    	call	BEEP					; Wrong Input, beep
1472   48A7 C3 92 48    	jp	SET_NAGLE_WI_OFF			; And return waiting key
1473   48AA             
1474   48AA             ;============================
1475   48AA             ;===  SETUP Menu Routines  ==
1476   48AA             ;===  Auxiliary Functions  ==
1477   48AA             ;============================
1478   48AA             SET_ESP_WIFI_TIMEOUT:
1479   48AA EB          	ex	de,hl
1480   48AB 3E 0D       	ld	a,#0d
1481   48AD CD A2 00    	call	CHPUT
1482   48B0 3E 0A       	ld	a,#0a
1483   48B2 CD A2 00    	call	CHPUT
1484   48B5 21 B6 64    	ld	hl,STR_SENDING				; Indicate it is sending a command
1485   48B8 CD BF 4B    	call	PRINTHL
1486   48BB 3E 14       	ld	a,20
1487   48BD D3 06       	out	(OUT_CMD_PORT),a			; Clear UART
1488   48BF 3E 54       	ld	a,CMD_TIMER_SET
1489   48C1 D3 07       	out	(OUT_TX_PORT),a
1490   48C3 AF          	xor	a							; Size MSB is 0
1491   48C4 D3 07       	out	(OUT_TX_PORT),a
1492   48C6 3E 02       	ld	a,2							; Size LSB is 2
1493   48C8 D3 07       	out	(OUT_TX_PORT),a
1494   48CA 7A          	ld	a,d							; Timeout MSB
1495   48CB D3 07       	out	(OUT_TX_PORT),a
1496   48CD 7B          	ld	a,e							; Timeout LSB
1497   48CE D3 07       	out	(OUT_TX_PORT),a
1498   48D0 21 3C 00    	ld	hl,60						; Wait Up To 1s
1499   48D3 3E 54       	ld	a,CMD_TIMER_SET				; Our command
1500   48D5 CD 8A 4A    	call	WAIT_MENU_QCMD_RESPONSE
1501   48D8 CA 81 4A    	jp	z,MENU_BAD_END
1502   48DB 21 D1 64    	ld	hl,STR_SENDING_OK			; Success
1503   48DE CD BF 4B    	call	PRINTHL
1504   48E1 C3 62 49    	jp	WAIT_2S_AND_THEN_MAINMENU
1505   48E4             
1506   48E4             SET_NAGLE_OFF:
1507   48E4 3E 4F       	ld	a,'O'
1508   48E6 CD A2 00    	call	CHPUT
1509   48E9 3E 0D       	ld	a,#0d
1510   48EB CD A2 00    	call	CHPUT
1511   48EE 3E 0A       	ld	a,#0a
1512   48F0 CD A2 00    	call	CHPUT
1513   48F3 21 B6 64    	ld	hl,STR_SENDING				; Indicate it is sending a command
1514   48F6 CD BF 4B    	call	PRINTHL
1515   48F9 3E 14       	ld	a,20
1516   48FB D3 06       	out	(OUT_CMD_PORT),a			; Clear UART
1517   48FD 3E 4E       	ld	a,CMD_NAGLE_OFF
1518   48FF D3 07       	out	(OUT_TX_PORT),a
1519   4901 21 3C 00    	ld	hl,60						; Wait Up To 1s
1520   4904 CD 8A 4A    	call	WAIT_MENU_QCMD_RESPONSE
1521   4907 CA 81 4A    	jp	z,MENU_BAD_END
1522   490A 21 D1 64    	ld	hl,STR_SENDING_OK			; Success
1523   490D CD BF 4B    	call	PRINTHL
1524   4910 C3 62 49    	jp	WAIT_2S_AND_THEN_MAINMENU
1525   4913             
1526   4913             STARTWIFISCAN:
1527   4913 3E 14       	ld	a,20
1528   4915 D3 06       	out	(OUT_CMD_PORT),a			; Clear UART
1529   4917 3E 53       	ld	a,CMD_SCAN_START
1530   4919 D3 07       	out	(OUT_TX_PORT),a
1531   491B 21 3C 00    	ld	hl,60						; Wait Up To 1s
1532   491E CD 8A 4A    	call	WAIT_MENU_QCMD_RESPONSE
1533   4921 C0          	ret	nz							; If success return
1534   4922 3E 0D       	ld	a,CR
1535   4924 CD A2 00    	call	CHPUT
1536   4927 3E 0A       	ld	a,LF
1537   4929 CD A2 00    	call	CHPUT
1538   492C C3 80 4A    	jp	MENU_SUB_BAD_END			; If error, nothing much to do, main menu
1539   492F             
1540   492F             SET_NAGLE_ON:
1541   492F 3E 4F       	ld	a,'O'
1542   4931 CD A2 00    	call	CHPUT
1543   4934 3E 0D       	ld	a,#0d
1544   4936 CD A2 00    	call	CHPUT
1545   4939 3E 0A       	ld	a,#0a
1546   493B CD A2 00    	call	CHPUT
1547   493E 21 B6 64    	ld	hl,STR_SENDING				; Indicate it is sending a command
1548   4941 CD BF 4B    	call	PRINTHL
1549   4944 3E 14       	ld	a,20
1550   4946 D3 06       	out	(OUT_CMD_PORT),a			; Clear UART
1551   4948 3E 44       	ld	a,CMD_NAGLE_ON
1552   494A D3 07       	out	(OUT_TX_PORT),a
1553   494C 21 3C 00    	ld	hl,60						; Wait Up To 1s
1554   494F CD 8A 4A    	call	WAIT_MENU_QCMD_RESPONSE
1555   4952 CA 81 4A    	jp	z,MENU_BAD_END
1556   4955 21 D1 64    	ld	hl,STR_SENDING_OK			; Success
1557   4958 CD BF 4B    	call	PRINTHL
1558   495B C3 62 49    	jp	WAIT_2S_AND_THEN_MAINMENU
1559   495E             
1560   495E             WAIT_4S_AND_THEN_MAINMENU:
1561   495E 3E F0       	ld	a,240						; Wait 4 seconds with message on screen
1562   4960 18 02       	jr	WAIT_AND_THEN_MAINMENU
1563   4962             WAIT_2S_AND_THEN_MAINMENU:
1564   4962 3E 78       	ld	a,120						; Wait 2 seconds with message on screen
1565   4964             WAIT_AND_THEN_MAINMENU:
1566   4964 CD 70 49    	call	WAIT_BEFORE_CONTINUING
1567   4967 C3 F2 41    	jp	ESPSETUP					; When done, back to main setup
1568   496A             WAIT_650MS_AND_THEN_CONTINUE:
1569   496A 3E 27       	ld	a,39						; Wait 650 ms then continue
1570   496C 18 02       	jr	WAIT_BEFORE_CONTINUING
1571   496E             WAIT_250MS_AND_THEN_CONTINUE:
1572   496E 3E 0F       	ld	a,15						; Wait 250 ms then continue
1573   4970             WAIT_BEFORE_CONTINUING:
1574   4970 76          	halt
1575   4971 3D          	dec	a
1576   4972             	; If not zero, our time out has not elapsed
1577   4972 20 FC       	jr	nz,WAIT_BEFORE_CONTINUING
1578   4974 C9          	ret								; Time out and continue
1579   4975             
1580   4975             ; Check Auto Clock
1581   4975             ISCLKAUTO:
1582   4975 3E 14       	ld	a,20
1583   4977 D3 06       	out	(OUT_CMD_PORT),a			; Clear UART
1584   4979 3E 63       	ld	a,CMD_QUERY_ACLK_SETTINGS
1585   497B D3 07       	out	(OUT_TX_PORT),a
1586   497D 21 3C 00    	ld	hl,60						; Wait Up To 1s
1587   4980 ED 5B 76 F6 	ld	de,(TXTTAB)					; We will borrow Basic Program memory area for now...
1588   4984 DD 6B       	ld	ixl,e
1589   4986 DD 62       	ld	ixh,d						; address in IX
1590   4988 CD BB 4A    	call	WAIT_MENU_CMD_RESPONSE
1591   498B CA 80 4A    	jp	z,MENU_SUB_BAD_END
1592   498E             	; Response received, IX+0 and IX+1 has Auto Clock and GMT, A
1593   498E C9          	ret
1594   498F             
1595   498F             ; Check what is the current NAGLE setting
1596   498F             CHECKNAGLE:
1597   498F 3E 14       	ld	a,20
1598   4991 D3 06       	out	(OUT_CMD_PORT),a			; Clear UART
1599   4993 3E 51       	ld	a,CMD_QUERY_ESP_SETTINGS
1600   4995 D3 07       	out	(OUT_TX_PORT),a
1601   4997 21 3C 00    	ld	hl,60						; Wait Up To 1s
1602   499A ED 5B 76 F6 	ld	de,(TXTTAB)					; We will borrow Basic Program memory area for now...
1603   499E DD 6B       	ld	ixl,e
1604   49A0 DD 62       	ld	ixh,d						; Address in IX
1605   49A2 CD BB 4A    	call	WAIT_MENU_CMD_RESPONSE
1606   49A5 CA 80 4A    	jp	z,MENU_SUB_BAD_END
1607   49A8             	; Response received, nagle is the first one, ON: or OFF:
1608   49A8 3E 4F       	ld	a,'O'
1609   49AA DD BE 00    	cp	(ix+0)
1610   49AD C2 80 4A    	jp	nz,MENU_SUB_BAD_END
1611   49B0 3E 4E       	ld	a,'N'
1612   49B2 DD BE 01    	cp	(ix+1)
1613   49B5 C2 C2 49    	jp	nz,CHECK_NAGLE_OFF
1614   49B8 3E 3A       	ld	a,':'
1615   49BA DD BE 02    	cp	(ix+2)
1616   49BD C2 80 4A    	jp	nz,MENU_SUB_BAD_END
1617   49C0 B7          	or	a							; It will make it NZ
1618   49C1 C9          	ret
1619   49C2             CHECK_NAGLE_OFF:
1620   49C2 3E 46       	ld	a,'F'
1621   49C4 DD BE 01    	cp	(ix+1)
1622   49C7 C2 80 4A    	jp	nz,MENU_SUB_BAD_END
1623   49CA 3E 46       	ld	a,'F'
1624   49CC DD BE 02    	cp	(ix+2)
1625   49CF C2 80 4A    	jp	nz,MENU_SUB_BAD_END
1626   49D2 3E 3A       	ld	a,':'
1627   49D4 DD BE 03    	cp	(ix+3)
1628   49D7 C2 80 4A    	jp	nz,MENU_SUB_BAD_END
1629   49DA             	; Already has zero, so just ret
1630   49DA C9          	ret
1631   49DB             
1632   49DB             ; Check what is the current TIMEOUT setting, return 0 if always on, otherwise there is a timeout
1633   49DB             ; Will return a zero terminated string @ HL that can be printed
1634   49DB             ; Will return the value in DE
1635   49DB             CHECKTIMEOUT:
1636   49DB 3E 14       	ld	a,20
1637   49DD D3 06       	out	(OUT_CMD_PORT),a			; Clear UART
1638   49DF 3E 51       	ld	a,CMD_QUERY_ESP_SETTINGS
1639   49E1 D3 07       	out	(OUT_TX_PORT),a
1640   49E3 21 3C 00    	ld	hl,60						; Wait Up To 1s
1641   49E6 ED 5B 76 F6 	ld	de,(TXTTAB)					; We will borrow Basic Program memory area for now...
1642   49EA DD 6B       	ld	ixl,e
1643   49EC DD 62       	ld	ixh,d						; Address in IX
1644   49EE CD BB 4A    	call	WAIT_MENU_CMD_RESPONSE
1645   49F1 CA 80 4A    	jp	z,MENU_SUB_BAD_END
1646   49F4             	; Response received, nagle is the first one, ON: or OFF:
1647   49F4 3E 3A       	ld	a,':'
1648   49F6 DD 23       	inc	ix
1649   49F8 DD 23       	inc	ix							; Nagle response is two or three bytes long, let's check
1650   49FA 0B          	dec	bc
1651   49FB 0B          	dec	bc							; Remaining bytes
1652   49FC DD BE 00    	cp	(ix+0)
1653   49FF CA 0B 4A    	jp	z,CHECKTIMEOUT.1
1654   4A02 DD 23       	inc	ix
1655   4A04 0B          	dec	bc							; Remaining bytes
1656   4A05 DD BE 00    	cp	(ix+0)
1657   4A08 C2 80 4A    	jp	nz,MENU_SUB_BAD_END			; If not here, sorry to say it is an error
1658   4A0B             CHECKTIMEOUT.1:
1659   4A0B 78          	ld	a,b
1660   4A0C B1          	or	c							; All data read?
1661   4A0D CA 80 4A    	jp	z,MENU_SUB_BAD_END			; If so, sorry to say it is an error
1662   4A10 DD 23       	inc	ix							; At the first digit
1663   4A12 0B          	dec	bc							; Remaining bytes
1664   4A13 78          	ld	a,b
1665   4A14 B1          	or	c							; All data read?
1666   4A15 CA 80 4A    	jp	z,MENU_SUB_BAD_END			; If so, sorry to say it is an error
1667   4A18 DD E5       	push	ix						; This is the start of the string, save it
1668   4A1A 26 00       	ld	h,0							; No digit so far
1669   4A1C             	; It can have up to three digits
1670   4A1C             CHECKTIMEOUT.2:
1671   4A1C 3E 3A       	ld	a,':'
1672   4A1E DD BE 00    	cp	(ix+0)						; Check if it is the separator
1673   4A21 CA 42 4A    	jp	z,CHECKTIMEOUT.3			; If it is routine will follow through
1674   4A24 DD 7E 00    	ld	a,(ix+0)					; Get the supposed digit in A
1675   4A27 2E 3A       	ld	l,'9'+1
1676   4A29 BD          	cp	l
1677   4A2A D2 7F 4A    	jp	nc,MENU_SUB_BAD_END_1S		; If more than '9', sorry to say it is an error
1678   4A2D 2E 30       	ld	l,'0'
1679   4A2F BD          	cp	l
1680   4A30 DA 7F 4A    	jp	c,MENU_SUB_BAD_END_1S		; If less than '0', sorry to say it is an error
1681   4A33 24          	inc	h							; It is not, so it is a digit
1682   4A34 3E 03       	ld	a,3
1683   4A36 BC          	cp	h
1684   4A37 DA 7F 4A    	jp	c,MENU_SUB_BAD_END_1S		; If more than three digits, sorry to say it is an error
1685   4A3A DD 23       	inc	ix							; Increase pointer
1686   4A3C 0B          	dec	bc							; Decrease remaining
1687   4A3D 78          	ld	a,b
1688   4A3E B1          	or	c							; All data read?
1689   4A3F C2 1C 4A    	jp	nz,CHECKTIMEOUT.2			; Not, so rinse and repeat
1690   4A42             CHECKTIMEOUT.3:
1691   4A42 DD 36 00 00 	ld	(ix+0),0					; Null terminate string value
1692   4A46 DD 2B       	dec	ix
1693   4A48 DD 7E 00    	ld	a,(ix+0)					; 1st Digit in A
1694   4A4B D6 30       	sub	'0'							; Convert it to decimal value
1695   4A4D 5F          	ld	e,a
1696   4A4E 16 00       	ld	d,0							; DE has first digit
1697   4A50 25          	dec	h							; Decrement digit counter
1698   4A51 28 28       	jr	z,CHECKTIMEOUT.END			; If all digits, done
1699   4A53             	; Now second digit, multiply it by 10 and add to E, even if 90 + 9, still fits E
1700   4A53 DD 2B       	dec	ix
1701   4A55 DD 7E 00    	ld	a,(ix+0)					; 2nd Digit
1702   4A58 D6 30       	sub	'0'							; Convert it to decimal value
1703   4A5A 87          	add	a,a							; A has *2
1704   4A5B 4F          	ld	c,a							; C has *2
1705   4A5C 87          	add	a,a							; A has *4
1706   4A5D 87          	add	a,a							; A has *8
1707   4A5E 81          	add	a,c							; A has *10
1708   4A5F 83          	add	a,e							; A has two digits result
1709   4A60 5F          	ld	e,a							; Back to E, DE has two digits results
1710   4A61 25          	dec	h							; Decrement digit counter
1711   4A62 28 17       	jr	z,CHECKTIMEOUT.END			; If all digits, done
1712   4A64             	; Now Third digit, multiply it by 100 and add to DE
1713   4A64 DD 2B       	dec	ix
1714   4A66 DD 7E 00    	ld	a,(ix+0)					; 3rd Digit
1715   4A69 D6 30       	sub	'0'							; Convert it to decimal value
1716   4A6B 87          	add	a,a							; A has *2
1717   4A6C 4F          	ld	c,a							; C has *2
1718   4A6D 87          	add	a,a							; A has *4
1719   4A6E 87          	add	a,a							; A has *8
1720   4A6F 81          	add	a,c							; A has *10
1721   4A70 26 00       	ld	h,0
1722   4A72 6F          	ld	l,a							; HL has *10
1723   4A73 29          	add	hl,hl						; HL has *20
1724   4A74 44          	ld	b,h
1725   4A75 4D          	ld	c,l							; BC has *20
1726   4A76 29          	add	hl,hl						; HL has *40
1727   4A77 29          	add	hl,hl						; HL has *80
1728   4A78 09          	add	hl,bc						; HL has *100
1729   4A79 19          	add	hl,de						; HL has three digit value
1730   4A7A EB          	ex	de,hl						; now in DE
1731   4A7B             CHECKTIMEOUT.END:
1732   4A7B E1          	pop	hl							; Restore address of string version of time count
1733   4A7C 7A          	ld	a,d
1734   4A7D B3          	or	e							; Set zero flag according to the time out set
1735   4A7E C9          	ret
1736   4A7F             
1737   4A7F             MENU_SUB_BAD_END_1S:
1738   4A7F F1          	pop	af							; 1 register was stacked, pop it
1739   4A80             MENU_SUB_BAD_END:
1740   4A80 F1          	pop	af							; It was a sub, so clear stack
1741   4A81             MENU_BAD_END:
1742   4A81 21 3E 65    	ld	hl,STR_SENDING_FAIL			; error message
1743   4A84 CD BF 4B    	call	PRINTHL
1744   4A87 C3 62 49    	jp	WAIT_2S_AND_THEN_MAINMENU
1745   4A8A             
1746   4A8A             ; WAIT an ESP quick command Response
1747   4A8A             ; Inputs:
1748   4A8A             ; A -> Command Code
1749   4A8A             ; HL -> Timeout
1750   4A8A             ;
1751   4A8A             ; Returns:
1752   4A8A             ; Flag Z is zero if failure, non zero if success
1753   4A8A             ;
1754   4A8A             ; Affect:
1755   4A8A             ; AF and HL
1756   4A8A             ;
1757   4A8A             WAIT_MENU_QCMD_RESPONSE:
1758   4A8A D5          	push	de
1759   4A8B 57          	ld	d,a							; Command to wait in D
1760   4A8C             WAIT_MENU_QCMD_RESPONSE_ST1:
1761   4A8C DB 07       	in	a,(IN_STS_PORT)
1762   4A8E CB 47       	bit	0,a							; If nz has data
1763   4A90 20 08       	jr	nz,WAIT_MENU_QCMD_RESPONSE_ST1.1
1764   4A92 CD B9 4B    	call	HLTIMEOUT
1765   4A95 20 F5       	jr	nz,WAIT_MENU_QCMD_RESPONSE_ST1
1766   4A97 C3 B6 4A    	jp	WAIT_MENU_QCMD_RESPONSE_END	; If time out waiting, return
1767   4A9A             WAIT_MENU_QCMD_RESPONSE_ST1.1:
1768   4A9A             	; nz, check the data
1769   4A9A DB 06       	in	a,(IN_DATA_PORT)
1770   4A9C BA          	cp	d							; Is response of our command?
1771   4A9D 20 ED       	jr	nz,WAIT_MENU_QCMD_RESPONSE_ST1
1772   4A9F             	; Now get return code, if return code other than 0, it is failure, otherwise success
1773   4A9F             WAIT_MENU_QCMD_RESPONSE_RC:
1774   4A9F DB 07       	in	a,(IN_STS_PORT)
1775   4AA1 CB 47       	bit	0,a							; If nz has data
1776   4AA3 20 08       	jr	nz,WAIT_MENU_QCMD_RESPONSE_RC.1
1777   4AA5 CD B9 4B    	call	HLTIMEOUT
1778   4AA8 20 F5       	jr	nz,WAIT_MENU_QCMD_RESPONSE_RC
1779   4AAA C3 B6 4A    	jp	WAIT_MENU_QCMD_RESPONSE_END	; If time-out waiting, return
1780   4AAD             WAIT_MENU_QCMD_RESPONSE_RC.1:
1781   4AAD DB 06       	in	a,(IN_DATA_PORT)
1782   4AAF B7          	or	a							; 0?
1783   4AB0             	; If not, done
1784   4AB0 C2 B8 4A    	jp	nz,WAIT_MENU_QCMD_RESPONSE_END_NOK
1785   4AB3             WAIT_MENU_QCMD_RESPONSE_END_OK:
1786   4AB3 3E 01       	ld	a,1
1787   4AB5 B7          	or	a							; NZ to indicate success
1788   4AB6             WAIT_MENU_QCMD_RESPONSE_END:
1789   4AB6 D1          	pop	de
1790   4AB7 C9          	ret
1791   4AB8             WAIT_MENU_QCMD_RESPONSE_END_NOK:
1792   4AB8 AF          	xor	a
1793   4AB9 D1          	pop	de
1794   4ABA C9          	ret
1795   4ABB             
1796   4ABB             ; WAIT an ESP regular command Response
1797   4ABB             ; Inputs:
1798   4ABB             ; A -> Command Code
1799   4ABB             ; HL -> Timeout
1800   4ABB             ; IX -> Where to store response
1801   4ABB             ;
1802   4ABB             ; Returns:
1803   4ABB             ; Flag Z is zero if failure, non zero if success
1804   4ABB             ; BC is the response size
1805   4ABB             ;
1806   4ABB             ; Affect:
1807   4ABB             ; AF , BC and HL
1808   4ABB             WAIT_MENU_CMD_RESPONSE:
1809   4ABB D5          	push	de
1810   4ABC DD E5       	push	ix
1811   4ABE 57          	ld	d,a							; Command to wait in D
1812   4ABF             WAIT_MENU_CMD_RESPONSE_ST1:
1813   4ABF DB 07       	in	a,(IN_STS_PORT)
1814   4AC1 CB 47       	bit	0,a							; If nz has data
1815   4AC3 20 08       	jr	nz,WAIT_MENU_CMD_RESPONSE_ST1.1
1816   4AC5 CD B9 4B    	call	HLTIMEOUT
1817   4AC8 20 F5       	jr	nz,WAIT_MENU_CMD_RESPONSE_ST1
1818   4ACA C3 2E 4B    	jp	WAIT_MENU_CMD_RESPONSE_END	; If time out waiting, return
1819   4ACD             WAIT_MENU_CMD_RESPONSE_ST1.1:
1820   4ACD             	; nz, check the data
1821   4ACD DB 06       	in	a,(IN_DATA_PORT)
1822   4ACF BA          	cp	d							; Is response of our command?
1823   4AD0 20 ED       	jr	nz,WAIT_MENU_CMD_RESPONSE_ST1
1824   4AD2             	; Now get return code, if return code other than 0, it is finished
1825   4AD2             WAIT_MENU_CMD_RESPONSE_RC:
1826   4AD2 DB 07       	in	a,(IN_STS_PORT)
1827   4AD4 CB 47       	bit	0,a							; If nz has data
1828   4AD6 20 08       	jr	nz,WAIT_MENU_CMD_RESPONSE_RC.1
1829   4AD8 CD B9 4B    	call	HLTIMEOUT
1830   4ADB 20 F5       	jr	nz,WAIT_MENU_CMD_RESPONSE_RC
1831   4ADD C3 2E 4B    	jp	WAIT_MENU_CMD_RESPONSE_END	; If time out waiting, return
1832   4AE0             WAIT_MENU_CMD_RESPONSE_RC.1:
1833   4AE0 DB 06       	in	a,(IN_DATA_PORT)
1834   4AE2 B7          	or	a							; 0?
1835   4AE3             	; If not, done
1836   4AE3 C2 34 4B    	jp	nz,WAIT_MENU_CMD_RESPONSE_END_NOK
1837   4AE6             	; Next two bytes are size bytes, save it to BC
1838   4AE6             WAIT_MENU_CMD_RESPONSE_ST2A:
1839   4AE6 DB 07       	in	a,(IN_STS_PORT)
1840   4AE8 CB 47       	bit	0,a							; If nz has data
1841   4AEA 20 08       	jr	nz,WAIT_MENU_CMD_RESPONSE_ST2A.1
1842   4AEC CD B9 4B    	call	HLTIMEOUT
1843   4AEF 20 F5       	jr	nz,WAIT_MENU_CMD_RESPONSE_ST2A
1844   4AF1 C3 2E 4B    	jp	WAIT_MENU_CMD_RESPONSE_END	; If time out waiting, return
1845   4AF4             WAIT_MENU_CMD_RESPONSE_ST2A.1:
1846   4AF4 DB 06       	in	a,(IN_DATA_PORT)
1847   4AF6 47          	ld	b,a
1848   4AF7             WAIT_MENU_CMD_RESPONSE_ST2B:
1849   4AF7 DB 07       	in	a,(IN_STS_PORT)
1850   4AF9 CB 47       	bit	0,a							; If nz has data
1851   4AFB 20 08       	jr	nz,WAIT_MENU_CMD_RESPONSE_ST2B.1
1852   4AFD CD B9 4B    	call	HLTIMEOUT
1853   4B00 20 F5       	jr	nz,WAIT_MENU_CMD_RESPONSE_ST2B
1854   4B02 C3 2E 4B    	jp	WAIT_MENU_CMD_RESPONSE_END	; If time out waiting, return
1855   4B05             WAIT_MENU_CMD_RESPONSE_ST2B.1:
1856   4B05 DB 06       	in	a,(IN_DATA_PORT)
1857   4B07 4F          	ld	c,a
1858   4B08 B0          	or	b							; Zero size in response?
1859   4B09 28 1C       	jr	z,WAIT_MENU_CMD_RESPONSE_END_OK
1860   4B0B 50          	ld	d,b
1861   4B0C 59          	ld	e,c							; Copy to DE
1862   4B0D             	; Now loop getting the data until received everything or time-out
1863   4B0D             WAIT_MENU_CMD_RESPONSE_GET_DATA:
1864   4B0D DB 07       	in	a,(IN_STS_PORT)
1865   4B0F CB 47       	bit	0,a							; If nz has data
1866   4B11 20 08       	jr	nz,WAIT_MENU_CMD_RESPONSE_GET_DATA.1
1867   4B13 CD B9 4B    	call	HLTIMEOUT
1868   4B16 20 F5       	jr	nz,WAIT_MENU_CMD_RESPONSE_GET_DATA
1869   4B18 C3 2E 4B    	jp	WAIT_MENU_CMD_RESPONSE_END	; If time out waiting, return
1870   4B1B             WAIT_MENU_CMD_RESPONSE_GET_DATA.1:
1871   4B1B DB 06       	in	a,(IN_DATA_PORT)			; Get data
1872   4B1D DD 77 00    	ld	(ix+0),a					; Put it in the buffer
1873   4B20 DD 23       	inc	ix							; Increment pointer
1874   4B22 1B          	dec	de							; Decrement counter
1875   4B23 7A          	ld	a,d
1876   4B24 B3          	or	e							; Is counter 0?
1877   4B25 20 E6       	jr	nz,WAIT_MENU_CMD_RESPONSE_GET_DATA
1878   4B27             WAIT_MENU_CMD_RESPONSE_END_OK:
1879   4B27 3E 01       	ld	a,1
1880   4B29 B7          	or	a							; NZ to indicate success
1881   4B2A DD E1       	pop	ix
1882   4B2C D1          	pop	de
1883   4B2D C9          	ret
1884   4B2E             WAIT_MENU_CMD_RESPONSE_END:
1885   4B2E 06 FF       	ld	b,#FF
1886   4B30 DD E1       	pop	ix
1887   4B32 D1          	pop	de
1888   4B33 C9          	ret
1889   4B34             WAIT_MENU_CMD_RESPONSE_END_NOK:
1890   4B34 47          	ld	b,a							; Get result in B, 0xFF for time-out, otherwise was an error return code
1891   4B35 AF          	xor	a
1892   4B36 DD E1       	pop	ix
1893   4B38 D1          	pop	de
1894   4B39 C9          	ret
1895   4B3A             
1896   4B3A             ; WAIT an ESP Wi-Fi Scan command Response
1897   4B3A             ; Inputs:
1898   4B3A             ; A -> Command Code
1899   4B3A             ; HL -> Timeout
1900   4B3A             ; IX -> Where to store response
1901   4B3A             ;
1902   4B3A             ; Returns:
1903   4B3A             ; Flag Z is zero if failure, non zero if success
1904   4B3A             ; A is the number of access points scanned
1905   4B3A             ;
1906   4B3A             ; Response is stored as:
1907   4B3A             ; Access Point SSID zero terminated and after first 0
1908   4B3A             ; 0 if Open otherwise requires a password to join
1909   4B3A             ; And this repeats...
1910   4B3A             ;
1911   4B3A             ; Affect:
1912   4B3A             ; AF , BC and HL
1913   4B3A             ;
1914   4B3A             WAIT_MENU_SCMD_RESPONSE:
1915   4B3A D5          	push	de
1916   4B3B DD E5       	push	ix
1917   4B3D 57          	ld	d,a							; Command to wait in D
1918   4B3E             WAIT_MENU_SCMD_RESPONSE_ST1:
1919   4B3E DB 07       	in	a,(IN_STS_PORT)
1920   4B40 CB 47       	bit	0,a							; If nz has data
1921   4B42 20 08       	jr	nz,WAIT_MENU_SCMD_RESPONSE_ST1.1
1922   4B44 CD B9 4B    	call	HLTIMEOUT
1923   4B47 20 F5       	jr	nz,WAIT_MENU_SCMD_RESPONSE_ST1
1924   4B49 C3 AF 4B    	jp	WAIT_MENU_SCMD_RESPONSE_END	; If time out waiting, return
1925   4B4C             WAIT_MENU_SCMD_RESPONSE_ST1.1:
1926   4B4C             	; nz, check the data
1927   4B4C DB 06       	in	a,(IN_DATA_PORT)
1928   4B4E BA          	cp	d							; Is response of our command?
1929   4B4F 20 ED       	jr	nz,WAIT_MENU_SCMD_RESPONSE_ST1
1930   4B51             	; Now get return code, if return code other than 0, it is finished
1931   4B51             WAIT_MENU_SCMD_RESPONSE_RC:
1932   4B51 DB 07       	in	a,(IN_STS_PORT)
1933   4B53 CB 47       	bit	0,a							; If nz has data
1934   4B55 20 08       	jr	nz,WAIT_MENU_SCMD_RESPONSE_RC.1
1935   4B57 CD B9 4B    	call	HLTIMEOUT
1936   4B5A 20 F5       	jr	nz,WAIT_MENU_SCMD_RESPONSE_RC
1937   4B5C C3 AF 4B    	jp	WAIT_MENU_SCMD_RESPONSE_END	; If time out waiting, return
1938   4B5F             WAIT_MENU_SCMD_RESPONSE_RC.1:
1939   4B5F DB 06       	in	a,(IN_DATA_PORT)
1940   4B61 B7          	or	a							; 0?
1941   4B62             	; If not, done
1942   4B62 C2 B3 4B    	jp	nz,WAIT_MENU_SCMD_RESPONSE_END_NOK
1943   4B65             	; Next byte is how many access points are available
1944   4B65             WAIT_MENU_SCMD_RESPONSE_ST2A:
1945   4B65 DB 07       	in	a,(IN_STS_PORT)
1946   4B67 CB 47       	bit	0,a							; If nz has data
1947   4B69 20 08       	jr	nz,WAIT_MENU_SCMD_RESPONSE_ST2A.1
1948   4B6B CD B9 4B    	call	HLTIMEOUT
1949   4B6E 20 F5       	jr	nz,WAIT_MENU_SCMD_RESPONSE_ST2A
1950   4B70 C3 AF 4B    	jp	WAIT_MENU_SCMD_RESPONSE_END	; If time out waiting, return
1951   4B73             WAIT_MENU_SCMD_RESPONSE_ST2A.1:
1952   4B73 DB 06       	in	a,(IN_DATA_PORT)
1953   4B75 47          	ld	b,a							; Save in B
1954   4B76 4F          	ld	c,a							; And C as well
1955   4B77             	; Now should loop this until c is 0, c will control access point received count
1956   4B77             WAIT_MENU_SCMD_RESPONSE_ST2B:
1957   4B77 DB 07       	in	a,(IN_STS_PORT)
1958   4B79 CB 47       	bit	0,a							; If nz has data
1959   4B7B 20 08       	jr	nz,WAIT_MENU_SCMD_RESPONSE_ST2B.1
1960   4B7D CD B9 4B    	call	HLTIMEOUT
1961   4B80 20 F5       	jr	nz,WAIT_MENU_SCMD_RESPONSE_ST2B
1962   4B82 C3 AF 4B    	jp	WAIT_MENU_SCMD_RESPONSE_END	; If time out waiting, return
1963   4B85             WAIT_MENU_SCMD_RESPONSE_ST2B.1:
1964   4B85 DB 06       	in	a,(IN_DATA_PORT)
1965   4B87 DD 77 00    	ld	(ix+0),a
1966   4B8A DD 23       	inc	ix							; Increment pointer
1967   4B8C B7          	or	a							; Terminator of AP Name?
1968   4B8D 20 E8       	jr	nz,WAIT_MENU_SCMD_RESPONSE_ST2B
1969   4B8F             	; Get encryption
1970   4B8F             WAIT_MENU_SCMD_RESPONSE_GET_ENC:
1971   4B8F DB 07       	in	a,(IN_STS_PORT)
1972   4B91 CB 47       	bit	0,a							; If nz has data
1973   4B93 20 08       	jr	nz,WAIT_MENU_SCMD_RESPONSE_GET_ENC.1
1974   4B95 CD B9 4B    	call	HLTIMEOUT
1975   4B98 20 F5       	jr	nz,WAIT_MENU_SCMD_RESPONSE_GET_ENC
1976   4B9A C3 2E 4B    	jp	WAIT_MENU_CMD_RESPONSE_END	; If time out waiting, return
1977   4B9D             WAIT_MENU_SCMD_RESPONSE_GET_ENC.1:
1978   4B9D DB 06       	in	a,(IN_DATA_PORT)			; Get data
1979   4B9F D6 4F       	sub	'O'							; If O, open, will be 0, otherwise, will be notzero
1980   4BA1 DD 77 00    	ld	(ix+0),a					; Put it in the buffer
1981   4BA4 DD 23       	inc	ix							; Increment pointer
1982   4BA6 0D          	dec	c							; Decrement counter
1983   4BA7 AF          	xor	a
1984   4BA8 B1          	or	c							; Is counter 0?
1985   4BA9             	; If not continue getting more SSIDs
1986   4BA9 20 CC       	jr	nz,WAIT_MENU_SCMD_RESPONSE_ST2B
1987   4BAB             	; It is zero, so, done
1988   4BAB             WAIT_MENU_SCMD_RESPONSE_END_OK:
1989   4BAB 3E 01       	ld	a,1
1990   4BAD B7          	or	a							; NZ to indicate success
1991   4BAE 78          	ld	a,b							; Number of APs in A
1992   4BAF             WAIT_MENU_SCMD_RESPONSE_END:
1993   4BAF DD E1       	pop	ix
1994   4BB1 D1          	pop	de
1995   4BB2 C9          	ret
1996   4BB3             WAIT_MENU_SCMD_RESPONSE_END_NOK:
1997   4BB3 47          	ld	b,a							; Return code in B
1998   4BB4 AF          	xor	a
1999   4BB5 DD E1       	pop	ix
2000   4BB7 D1          	pop	de
2001   4BB8 C9          	ret
2002   4BB9             
2003   4BB9             ; This routine will check if HL is 0, if it is, will return immediatelly
2004   4BB9             ; If it is not, will decrease HL value and halt (wait one interrupt)
2005   4BB9             HLTIMEOUT:
2006   4BB9 7C          	ld	a,h
2007   4BBA B5          	or	l
2008   4BBB C8          	ret	z
2009   4BBC 2B          	dec	hl
2010   4BBD 76          	halt
2011   4BBE C9          	ret
2012   4BBF             
2013   4BBF             ; Routine to print the string addressed by HL
2014   4BBF             PRINTHL:
2015   4BBF 7E          	ld	a,(hl)
2016   4BC0 B7          	or	a
2017   4BC1 C8          	ret	z							; When string is finished, done!
2018   4BC2 CD A2 00    	call	CHPUT
2019   4BC5 23          	inc	hl
2020   4BC6 C3 BF 4B    	jp	PRINTHL
2021   4BC9             
2022   4BC9             ; Routine to print the string addressed by HL on a line, if exceeding it, ends with ..
2023   4BC9             PRINTHLINE:
2024   4BC9 C5          	push	bc
2025   4BCA 06 1B       	ld	b,27
2026   4BCC             PHLINEL:
2027   4BCC 7E          	ld	a,(hl)
2028   4BCD B7          	or	a
2029   4BCE 28 15       	jr	z,PHLINELR					; When string is finished, done!
2030   4BD0 CD A2 00    	call	CHPUT
2031   4BD3 23          	inc	hl
2032   4BD4 10 F6       	djnz	PHLINEL
2033   4BD6 3E 2E       	ld	a,'.'
2034   4BD8 CD A2 00    	call	CHPUT
2035   4BDB 3E 2E       	ld	a,'.'
2036   4BDD CD A2 00    	call	CHPUT
2037   4BE0 3E 1D       	ld	a,GOLEFT
2038   4BE2 CD A2 00    	call	CHPUT
2039   4BE5             PHLINELR:
2040   4BE5 C1          	pop	bc
2041   4BE6 C9          	ret
2042   4BE7             
2043   4BE7             ;===============================
2044   4BE7             ;===  HTIM_I hook execution  ===
2045   4BE7             ;===============================
2046   4BE7             DO_HTIMI:
2047   4BE7 F5          	push	af						; HTIM hook -> need to keep A value
2048   4BE8 CD E5 57    	call	GETCOUNTER				; Counter in hl
2049   4BEB 7D          	ld	a,l
2050   4BEC B4          	or	h							; In this operation, check if HL is o
2051   4BED 28 04       	jr	z,DO_HTIMI_END				; If it is, nothing to do
2052   4BEF 2B          	dec	hl							; Otherwise decrement it
2053   4BF0 CD F4 57    	call	SETCOUNTER				; And save it
2054   4BF3             DO_HTIMI_END:
2055   4BF3 CD 54 57    	call	GETSLT
2056   4BF6             	; Slot in A, now get the address of our counter
2057   4BF6 CD DD 57    	call	GETMEMPOINTER
2058   4BF9             	; HL has the address of our memory area, and there is where we should jump
2059   4BF9 F1          	pop	af							; Restore original A value
2060   4BFA E9          	jp	(hl)
2061   4BFB             
2062   4BFB             ;===============================
2063   4BFB             ;===  EXTBIO hook execution  ===
2064   4BFB             ;===============================
2065   4BFB             DO_EXTBIO:
2066   4BFB E5          	push	hl
2067   4BFC C5          	push	bc
2068   4BFD F5          	push	af
2069   4BFE 7A          	ld	a,d
2070   4BFF FE 22       	cp	#22
2071   4C01 20 43       	jr	nz,JUMP_OLD
2072   4C03 BB          	cp	e
2073   4C04 20 40       	jr	nz,JUMP_OLD
2074   4C06             
2075   4C06             	; Check API ID
2076   4C06 21 A2 66    	ld	hl,UNAPI_ID
2077   4C09 11 47 F8    	ld	de,ARG
2078   4C0C             LOOP:
2079   4C0C 1A          	ld	a,(de)
2080   4C0D CD 2F 59    	call	TOUPPER
2081   4C10 BE          	cp	(hl)
2082   4C11 20 30       	jr	nz,JUMP_OLD2
2083   4C13 23          	inc	hl
2084   4C14 13          	inc	de
2085   4C15 B7          	or	a
2086   4C16 20 F4       	jr	nz,LOOP
2087   4C18             
2088   4C18             	; A=255: Jump to old hook
2089   4C18             
2090   4C18 F1          	pop	af
2091   4C19 F5          	push	af
2092   4C1A 3C          	inc	a
2093   4C1B 28 26       	jr	z,JUMP_OLD2
2094   4C1D             
2095   4C1D             	; A=0: B=B+1 and jump to old hook
2096   4C1D             
2097   4C1D CD 54 57    	call	GETSLT
2098   4C20 CD AD 57    	call	GETWRK
2099   4C23 F1          	pop	af
2100   4C24 C1          	pop	bc
2101   4C25 B7          	or	a
2102   4C26 20 06       	jr	nz,DO_EXTBIO2
2103   4C28 04          	inc	b
2104   4C29 E3          	ex	(sp),hl
2105   4C2A 11 22 22    	ld	de,#2222
2106   4C2D C9          	ret
2107   4C2E             
2108   4C2E             DO_EXTBIO2:
2109   4C2E             	; A=1: Return A=Slot, B=Segment, HL=UNAPI entry address
2110   4C2E             
2111   4C2E 3D          	dec	a
2112   4C2F 20 0D       	jr	nz,DO_EXTBIO3
2113   4C31 E1          	pop	hl
2114   4C32 CD 74 57    	call	GETSLTT					; GETSLTT is GETSLT that checks if our memory area @ HIMEM has been allocated, if not, allocate it
2115   4C35 06 FF       	ld	b,#FF
2116   4C37 21 52 4C    	ld	hl,UNAPI_ENTRY
2117   4C3A 11 22 22    	ld	de,#2222
2118   4C3D C9          	ret
2119   4C3E             
2120   4C3E             	; A>1: A=A-1, and jump to old hook
2121   4C3E             
2122   4C3E             DO_EXTBIO3:							; A=A-1 already done
2123   4C3E E3          	ex	(sp),hl
2124   4C3F 11 22 22    	ld	de,#2222
2125   4C42 C9          	ret
2126   4C43             
2127   4C43             
2128   4C43             ; Jump here to execute old EXTBIO code
2129   4C43             JUMP_OLD2:
2130   4C43 11 22 22    	ld	de,#2222
2131   4C46             JUMP_OLD:							; Assumes "push hl,bc,af" done
2132   4C46 D5          	push	de
2133   4C47 CD 54 57    	call	GETSLT
2134   4C4A CD AD 57    	call	GETWRK
2135   4C4D D1          	pop	de
2136   4C4E F1          	pop	af
2137   4C4F C1          	pop	bc
2138   4C50 E3          	ex	(sp),hl
2139   4C51 C9          	ret
2140   4C52             
2141   4C52             ;====================================
2142   4C52             ;===  Functions entry point code  ===
2143   4C52             ;====================================
2144   4C52             UNAPI_ENTRY:
2145   4C52 FB          	ei
2146   4C53 E5          	push	hl
2147   4C54 F5          	push	af
2148   4C55 21 73 4C    	ld	hl,FN_TABLE
2149   4C58 CB 7F       	bit	7,a
2150   4C5A             
2151   4C5A             	if	MAX_IMPFN >= 128
2152   4C5A~            
2153   4C5A~            	jr	z,IS_STANDARD
2154   4C5A~            	ld	hl,IMPFN_TABLE
2155   4C5A~            	and	%01111111
2156   4C5A~            	cp	MAX_IMPFN-128
2157   4C5A~            	jr	z,OK_FNUM
2158   4C5A~            	jr	nc,UNDEFINED
2159   4C5A~            IS_STANDARD:
2160   4C5A~            
2161   4C5A             	else
2162   4C5A             
2163   4C5A 20 14       	jr	nz,UNDEFINED
2164   4C5C             
2165   4C5C             	endif
2166   4C5C             
2167   4C5C FE 1D       	cp	MAX_FN
2168   4C5E 28 02       	jr	z,OK_FNUM
2169   4C60 30 0E       	jr	nc,UNDEFINED
2170   4C62             
2171   4C62             OK_FNUM:
2172   4C62 87          	add	a,a
2173   4C63 D5          	push	de
2174   4C64 5F          	ld	e,a
2175   4C65 16 00       	ld	d,0
2176   4C67 19          	add	hl,de
2177   4C68 D1          	pop	de
2178   4C69             
2179   4C69 7E          	ld	a,(hl)
2180   4C6A 23          	inc	hl
2181   4C6B 66          	ld	h,(hl)
2182   4C6C 6F          	ld	l,a
2183   4C6D             
2184   4C6D F1          	pop	af
2185   4C6E E3          	ex	(sp),hl
2186   4C6F C9          	ret
2187   4C70             
2188   4C70             ; Undefined function: return with registers unmodified
2189   4C70             UNDEFINED:
2190   4C70 F1          	pop	af
2191   4C71 E1          	pop	hl
2192   4C72 C9          	ret
2193   4C73             
2194   4C73             ;===================================
2195   4C73             ;===  Functions addresses table  ===
2196   4C73             ;===================================
2197   4C73             ;--- Implementation-specific routines addresses table
2198   4C73             
2199   4C73             	if	MAX_IMPFN >= 128
2200   4C73~            
2201   4C73~            IMPFN_TABLE:
2202   4C73~            FN_128:					dw	FN_DUMMY
2203   4C73~            
2204   4C73             	endif
2205   4C73             
2206   4C73             FN_TABLE:
2207   4C73 C4 4C       FN_0:					dw	UNAPI_GET_INFO
2208   4C75 CF 4C       FN_1:					dw	TCPIP_GET_CAPAB
2209   4C77 FF 4D       FN_2:					dw	TCPIP_GET_IPINFO
2210   4C79 7C 4E       FN_3:					dw	TCPIP_NET_STATE
2211   4C7B             ; TCPIP_SEND_ECHO not going to be implemented, ESP do not support ping like UNAPI specify
2212   4C7B AF 4C       FN_4:					dw	FN_NOT_IMP
2213   4C7D             ; TCPIP_RCV_ECHO not going to be implemented as SEND_ECHO is not implemented
2214   4C7D AF 4C       FN_5:					dw	FN_NOT_IMP
2215   4C7F CB 4E       FN_6:					dw	TCPIP_DNS_Q
2216   4C81 7A 4F       FN_7:					dw	TCPIP_DNS_S
2217   4C83 A7 4F       FN_8:					dw	TCPIP_UDP_OPEN
2218   4C85 01 50       FN_9:					dw	TCPIP_UDP_CLOSE
2219   4C87 47 50       FN_10:					dw	TCPIP_UDP_STATE
2220   4C89 D2 50       FN_11:					dw	TCPIP_UDP_SEND
2221   4C8B 71 51       FN_12:					dw	TCPIP_UDP_RCV
2222   4C8D 9A 52       FN_13:					dw	TCPIP_TCP_OPEN
2223   4C8F 70 53       FN_14:					dw	TCPIP_TCP_CLOSE
2224   4C91 B6 53       FN_15:					dw	TCPIP_TCP_ABORT
2225   4C93 1F 54       FN_16:					dw	TCPIP_TCP_STATE
2226   4C95 39 55       FN_17:					dw	TCPIP_TCP_SEND
2227   4C97 D1 55       FN_18:					dw	TCPIP_TCP_RCV
2228   4C99             ; TCPIP_TCP_FLUSH makes no sense as we do not use buffers to send, any buffer is internal to ESP and we can't delete
2229   4C99 AF 4C       FN_19:					dw	FN_NOT_IMP
2230   4C9B             ; TCPIP_RAW_OPEN not going to be implemented, ESP do not support RAW connections
2231   4C9B AF 4C       FN_20:					dw	FN_NOT_IMP
2232   4C9D             ; TCPIP_RAW_CLOSE not going to be implemented, ESP do not support RAW connections
2233   4C9D AF 4C       FN_21:					dw	FN_NOT_IMP
2234   4C9F             ; TCPIP_RAW_STATE not going to be implemented, ESP do not support RAW connections
2235   4C9F AF 4C       FN_22:					dw	FN_NOT_IMP
2236   4CA1             ; TCPIP_RAW_SEND not going to be implemented, ESP do not support RAW connections
2237   4CA1 AF 4C       FN_23:					dw	FN_NOT_IMP
2238   4CA3             ; TCPIP_RAW_RCV not going to be implemented, ESP do not support RAW connections
2239   4CA3 AF 4C       FN_24:					dw	FN_NOT_IMP
2240   4CA5 9E 56       FN_25:					dw	TCPIP_CONFIG_AUTOIP
2241   4CA7 F5 56       FN_26:					dw	TCPIP_CONFIG_IP
2242   4CA9 32 57       FN_27:					dw	TCPIP_CONFIG_TTL
2243   4CAB 44 57       FN_28:					dw	TCPIP_CONFIG_PING
2244   4CAD             ; TCPIP_WAIT not needed for our implementation
2245   4CAD B2 4C       FN_29:					dw	END_OK
2246   4CAF             
2247   4CAF             ;========================
2248   4CAF             ;===  Functions code  ===
2249   4CAF             ;========================
2250   4CAF             FN_NOT_IMP:
2251   4CAF 3E 01       	ld	a,ERR_NOT_IMP
2252   4CB1 C9          	ret
2253   4CB2             
2254   4CB2             END_OK:
2255   4CB2 AF          	xor a
2256   4CB3 C9          	ret
2257   4CB4             
2258   4CB4             ; Most functions do not have special handling on time out and can use this.
2259   4CB4             ; If there is a need to retry sending or receiving on time-out, then a custom
2260   4CB4             ; time-out function must be done, check the examples of UDP and TCP receive
2261   4CB4             TCPIP_GENERIC_CHECK_TIME_OUT:
2262   4CB4             	; Save registers other than AF
2263   4CB4 C5          	push bc
2264   4CB5 D5          	push de
2265   4CB6 E5          	push hl
2266   4CB7 CD E5 57    	call	GETCOUNTER
2267   4CBA 7D          	ld	a,l
2268   4CBB B4          	or	h
2269   4CBC             	; Restore registers, we are returning
2270   4CBC E1          	pop	hl
2271   4CBD D1          	pop	de
2272   4CBE C1          	pop	bc
2273   4CBF C0          	ret	nz
2274   4CC0             	; Ok, timeout...
2275   4CC0 F1          	pop	af							; Get return address of who called this out of the stack
2276   4CC1 3E 0F       	ld	a,ERR_INV_OPER
2277   4CC3 C9          	ret								; and return the function itself
2278   4CC4             
2279   4CC4             ;========================
2280   4CC4             ;===  UNAPI_GET_INFO  ===
2281   4CC4             ;========================
2282   4CC4             ; Obtain the implementation name and version.
2283   4CC4             ;
2284   4CC4             ;    Input:  A  = 0
2285   4CC4             ;    Output: HL = Descriptive string for this implementation, on this slot, zero terminated
2286   4CC4             ;            DE = API version supported, D.E
2287   4CC4             ;            BC = This implementation version, B.C.
2288   4CC4             ;            A  = 0 and Cy = 0
2289   4CC4             UNAPI_GET_INFO:
2290   4CC4 01 02 01    	ld	bc,256*ROM_V_P+ROM_V_S
2291   4CC7 11 02 01    	ld	de,256*API_V_P+API_V_S
2292   4CCA 21 A9 66    	ld	hl,APIINFO
2293   4CCD AF          	xor	a
2294   4CCE C9          	ret
2295   4CCF             
2296   4CCF             ;=========================
2297   4CCF             ;===  TCPIP_GET_CAPAB  ===
2298   4CCF             ;=========================
2299   4CCF             ; Get information about the TCP/IP capabilities and features.
2300   4CCF             ;
2301   4CCF             ;    Input:  A = 1
2302   4CCF             ;            B = Index of information block to retrieve:
2303   4CCF             ;                1: Capabilities and features flags, link level protocol
2304   4CCF             ;                2: Connection pool size and status
2305   4CCF             ;                3: Maximum datagram size allowed
2306   4CCF             ;                4: Second set of capabilities and features flags
2307   4CCF             ;    Output: A = Error code
2308   4CCF             ;        When information block 1 requested:
2309   4CCF             ;            HL = Capabilities flags
2310   4CCF             ;            DE = Features flags
2311   4CCF             ;            B  = Link level protocol used
2312   4CCF             ;        When information block 2 requested:
2313   4CCF             ;            B = Maximum simultaneous TCP connections supported
2314   4CCF             ;            C = Maximum simultaneous UDP connections supported
2315   4CCF             ;            D = Free TCP connections currently available
2316   4CCF             ;            E = Free UDP connections currently available
2317   4CCF             ;            H = Maximum simultaneous raw IP connections supported
2318   4CCF             ;            L = Free raw IP connections currently available
2319   4CCF             ;        When information block 3 requested:
2320   4CCF             ;            HL = Maximum incoming datagram size supported
2321   4CCF             ;            DE = Maximum outgoing datagram size supported
2322   4CCF             ;        When information block 4 requested:
2323   4CCF             ;            HL = Second set of capabilities flags
2324   4CCF             ;            DE = Second set of features flags (currently unused, always zero)
2325   4CCF             TCPIP_GET_CAPAB:
2326   4CCF D3 07       	out	(OUT_TX_PORT),a				; Send the command
2327   4CD1 AF          	xor	a
2328   4CD2 D3 07       	out	(OUT_TX_PORT),a				; Send the command size msb
2329   4CD4 3C          	inc	a
2330   4CD5 D3 07       	out	(OUT_TX_PORT),a				; Send the command size lsb
2331   4CD7 78          	ld	a,b
2332   4CD8 CD 16 58    	call	SETBYTE					; Save it, we are going to need it later
2333   4CDB D3 07       	out	(OUT_TX_PORT),a				; Send the parameter
2334   4CDD             
2335   4CDD             	; Now wait up to 120 ticks to get response
2336   4CDD 21 78 00    	ld	hl,120
2337   4CE0 CD F4 57    	call	SETCOUNTER
2338   4CE3             TCPIP_GET_CAPAB_ST1:
2339   4CE3 DB 07       	in	a,(IN_STS_PORT)
2340   4CE5 CB 47       	bit	0,a							; If nz has data
2341   4CE7 20 05       	jr	nz,TCPIP_GET_CAPAB_ST1.1
2342   4CE9 CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
2343   4CEC 18 F5       	jr	TCPIP_GET_CAPAB_ST1
2344   4CEE             TCPIP_GET_CAPAB_ST1.1:
2345   4CEE             	; nz, check the data
2346   4CEE DB 06       	in	a,(IN_DATA_PORT)
2347   4CF0 FE 01       	cp	1							; Is response of our command?
2348   4CF2 20 EF       	jr	nz,TCPIP_GET_CAPAB_ST1
2349   4CF4             	; Now get return code, if return code other than 0, it is finished
2350   4CF4             TCPIP_GET_CAPAB_RC:
2351   4CF4 DB 07       	in	a,(IN_STS_PORT)
2352   4CF6 CB 47       	bit	0,a							; If nz has data
2353   4CF8 20 05       	jr	nz,TCPIP_GET_CAPAB_RC.1
2354   4CFA CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
2355   4CFD 18 F5       	jr	TCPIP_GET_CAPAB_RC
2356   4CFF             TCPIP_GET_CAPAB_RC.1:
2357   4CFF             	; nz, discard
2358   4CFF DB 06       	in	a,(IN_DATA_PORT)
2359   4D01 B7          	or	a							; 0?
2360   4D02 C0          	ret	nz							; If not, done
2361   4D03             
2362   4D03             	; Next two bytes are return code and size bytes, don't care
2363   4D03 06 02       	ld	b,2
2364   4D05             TCPIP_GET_CAPAB_ST2:
2365   4D05 DB 07       	in	a,(IN_STS_PORT)
2366   4D07 CB 47       	bit	0,a							; If nz has data
2367   4D09 20 05       	jr	nz,TCPIP_GET_CAPAB_ST2.1
2368   4D0B CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
2369   4D0E 18 F5       	jr	TCPIP_GET_CAPAB_ST2
2370   4D10             TCPIP_GET_CAPAB_ST2.1:
2371   4D10             	; Nz, discard
2372   4D10 DB 06       	in	a,(IN_DATA_PORT)
2373   4D12 05          	dec	b
2374   4D13 20 F0       	jr	nz,TCPIP_GET_CAPAB_ST2
2375   4D15             
2376   4D15             	; Now check if block 1, 2 or 3
2377   4D15 CD 04 58    	call	GETBYTE					; Get the parameter we saved at the start
2378   4D18 3D          	dec	a
2379   4D19 CA B7 4D    	jp	z,TCPIP_GET_CAPAB_BLK1		; 1
2380   4D1C 3D          	dec	a
2381   4D1D CA 61 4D    	jp	z,TCPIP_GET_CAPAB_BLK2		; 2
2382   4D20 3D          	dec	a
2383   4D21 CA 27 4D    	jp	z,TCPIP_GET_CAPAB_BLK3		; 3
2384   4D24             	; Else, only block four, same as block 1
2385   4D24 C3 B7 4D    	jp	TCPIP_GET_CAPAB_BLK1		; 1
2386   4D27             	; Block 3 Handling, we will receive L, H, E and D
2387   4D27             TCPIP_GET_CAPAB_BLK3:
2388   4D27             TCPIP_GET_CAPAB_BLK3_ST1:
2389   4D27 DB 07       	in	a,(IN_STS_PORT)
2390   4D29 CB 47       	bit	0,a							; If nz has data
2391   4D2B 20 05       	jr	nz,TCPIP_GET_CAPAB_BLK3_ST1.1
2392   4D2D CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
2393   4D30 18 F5       	jr	TCPIP_GET_CAPAB_BLK3_ST1
2394   4D32             TCPIP_GET_CAPAB_BLK3_ST1.1:
2395   4D32             	; nz, get it
2396   4D32 DB 06       	in	a,(IN_DATA_PORT)
2397   4D34 6F          	ld	l,a
2398   4D35             TCPIP_GET_CAPAB_BLK3_ST2:
2399   4D35 DB 07       	in	a,(IN_STS_PORT)
2400   4D37 CB 47       	bit	0,a							; If nz has data
2401   4D39 20 05       	jr	nz,TCPIP_GET_CAPAB_BLK3_ST2.1
2402   4D3B CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
2403   4D3E 18 F5       	jr	TCPIP_GET_CAPAB_BLK3_ST2
2404   4D40             TCPIP_GET_CAPAB_BLK3_ST2.1:
2405   4D40             	; nz, get it
2406   4D40 DB 06       	in	a,(IN_DATA_PORT)
2407   4D42 67          	ld	h,a
2408   4D43             TCPIP_GET_CAPAB_BLK3_ST3:
2409   4D43 DB 07       	in	a,(IN_STS_PORT)
2410   4D45 CB 47       	bit	0,a							; If nz has data
2411   4D47 20 05       	jr	nz,TCPIP_GET_CAPAB_BLK3_ST3.1
2412   4D49 CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
2413   4D4C 18 F5       	jr	TCPIP_GET_CAPAB_BLK3_ST3
2414   4D4E             TCPIP_GET_CAPAB_BLK3_ST3.1:
2415   4D4E             	; nz, get it
2416   4D4E DB 06       	in	a,(IN_DATA_PORT)
2417   4D50 5F          	ld	e,a
2418   4D51             TCPIP_GET_CAPAB_BLK3_ST4:
2419   4D51 DB 07       	in	a,(IN_STS_PORT)
2420   4D53 CB 47       	bit	0,a							; If nz has data
2421   4D55 20 05       	jr	nz,TCPIP_GET_CAPAB_BLK3_ST4.1
2422   4D57 CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
2423   4D5A 18 F5       	jr	TCPIP_GET_CAPAB_BLK3_ST4
2424   4D5C             TCPIP_GET_CAPAB_BLK3_ST4.1:
2425   4D5C             	; nz, get it
2426   4D5C DB 06       	in	a,(IN_DATA_PORT)
2427   4D5E 57          	ld	d,a
2428   4D5F             	; Done
2429   4D5F AF          	xor a
2430   4D60 C9          	ret
2431   4D61             
2432   4D61             TCPIP_GET_CAPAB_BLK2:
2433   4D61             	; Block 2 Handling, we will receive B, C, D, E, H, L
2434   4D61             TCPIP_GET_CAPAB_BLK2_ST1:
2435   4D61 DB 07       	in	a,(IN_STS_PORT)
2436   4D63 CB 47       	bit	0,a							; If nz has data
2437   4D65 20 05       	jr	nz,TCPIP_GET_CAPAB_BLK2_ST1.1
2438   4D67 CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
2439   4D6A 18 F5       	jr	TCPIP_GET_CAPAB_BLK2_ST1
2440   4D6C             TCPIP_GET_CAPAB_BLK2_ST1.1:
2441   4D6C             	; nz, get it
2442   4D6C DB 06       	in	a,(IN_DATA_PORT)
2443   4D6E 47          	ld	b,a
2444   4D6F             TCPIP_GET_CAPAB_BLK2_ST2:
2445   4D6F DB 07       	in	a,(IN_STS_PORT)
2446   4D71 CB 47       	bit	0,a							; If nz has data
2447   4D73 20 05       	jr	nz,TCPIP_GET_CAPAB_BLK2_ST2.1
2448   4D75 CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
2449   4D78 18 F5       	jr	TCPIP_GET_CAPAB_BLK2_ST2
2450   4D7A             TCPIP_GET_CAPAB_BLK2_ST2.1:
2451   4D7A             	; nz, get it
2452   4D7A DB 06       	in	a,(IN_DATA_PORT)
2453   4D7C 4F          	ld	c,a
2454   4D7D             TCPIP_GET_CAPAB_BLK2_ST3:
2455   4D7D DB 07       	in	a,(IN_STS_PORT)
2456   4D7F CB 47       	bit	0,a							; If nz has data
2457   4D81 20 05       	jr	nz,TCPIP_GET_CAPAB_BLK2_ST3.1
2458   4D83 CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
2459   4D86 18 F5       	jr	TCPIP_GET_CAPAB_BLK2_ST3
2460   4D88             TCPIP_GET_CAPAB_BLK2_ST3.1:
2461   4D88             	; nz, get it
2462   4D88 DB 06       	in	a,(IN_DATA_PORT)
2463   4D8A 57          	ld	d,a
2464   4D8B             TCPIP_GET_CAPAB_BLK2_ST4:
2465   4D8B DB 07       	in	a,(IN_STS_PORT)
2466   4D8D CB 47       	bit	0,a							; If nz has data
2467   4D8F 20 05       	jr	nz,TCPIP_GET_CAPAB_BLK2_ST4.1
2468   4D91 CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
2469   4D94 18 F5       	jr	TCPIP_GET_CAPAB_BLK2_ST4
2470   4D96             TCPIP_GET_CAPAB_BLK2_ST4.1:
2471   4D96             	; nz, get it
2472   4D96 DB 06       	in	a,(IN_DATA_PORT)
2473   4D98 5F          	ld	e,a
2474   4D99             TCPIP_GET_CAPAB_BLK2_ST5:
2475   4D99 DB 07       	in	a,(IN_STS_PORT)
2476   4D9B CB 47       	bit	0,a							; If nz has data
2477   4D9D 20 05       	jr	nz,TCPIP_GET_CAPAB_BLK2_ST5.1
2478   4D9F CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
2479   4DA2 18 F5       	jr	TCPIP_GET_CAPAB_BLK2_ST5
2480   4DA4             TCPIP_GET_CAPAB_BLK2_ST5.1:
2481   4DA4             	; nz, get it
2482   4DA4 DB 06       	in	a,(IN_DATA_PORT)
2483   4DA6 67          	ld	h,a
2484   4DA7             TCPIP_GET_CAPAB_BLK2_ST6:
2485   4DA7 DB 07       	in	a,(IN_STS_PORT)
2486   4DA9 CB 47       	bit	0,a							; If nz has data
2487   4DAB 20 05       	jr	nz,TCPIP_GET_CAPAB_BLK2_ST6.1
2488   4DAD CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
2489   4DB0 18 F5       	jr	TCPIP_GET_CAPAB_BLK2_ST6
2490   4DB2             TCPIP_GET_CAPAB_BLK2_ST6.1:
2491   4DB2             	; nz, get it
2492   4DB2 DB 06       	in	a,(IN_DATA_PORT)
2493   4DB4 6F          	ld	l,a
2494   4DB5             	; Done
2495   4DB5 AF          	xor	a
2496   4DB6 C9          	ret
2497   4DB7             
2498   4DB7             TCPIP_GET_CAPAB_BLK1:
2499   4DB7             	; Block 1 Handling, we will receive L, H, E, D and B
2500   4DB7             TCPIP_GET_CAPAB_BLK1_ST1:
2501   4DB7 DB 07       	in	a,(IN_STS_PORT)
2502   4DB9 CB 47       	bit	0,a							; If nz has data
2503   4DBB 20 05       	jr	nz,TCPIP_GET_CAPAB_BLK1_ST1.1
2504   4DBD CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
2505   4DC0 18 F5       	jr	TCPIP_GET_CAPAB_BLK1_ST1
2506   4DC2             TCPIP_GET_CAPAB_BLK1_ST1.1:
2507   4DC2             	; nz, get it
2508   4DC2 DB 06       	in	a,(IN_DATA_PORT)
2509   4DC4 6F          	ld	l,a
2510   4DC5             TCPIP_GET_CAPAB_BLK1_ST2:
2511   4DC5 DB 07       	in	a,(IN_STS_PORT)
2512   4DC7 CB 47       	bit	0,a							; If nz has data
2513   4DC9 20 05       	jr	nz,TCPIP_GET_CAPAB_BLK1_ST2.1
2514   4DCB CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
2515   4DCE 18 F5       	jr	TCPIP_GET_CAPAB_BLK1_ST2
2516   4DD0             TCPIP_GET_CAPAB_BLK1_ST2.1:
2517   4DD0             	; nz, get it
2518   4DD0 DB 06       	in	a,(IN_DATA_PORT)
2519   4DD2 67          	ld	h,a
2520   4DD3             TCPIP_GET_CAPAB_BLK1_ST3:
2521   4DD3 DB 07       	in	a,(IN_STS_PORT)
2522   4DD5 CB 47       	bit	0,a							; If nz has data
2523   4DD7 20 05       	jr	nz,TCPIP_GET_CAPAB_BLK1_ST3.1
2524   4DD9 CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
2525   4DDC 18 F5       	jr	TCPIP_GET_CAPAB_BLK1_ST3
2526   4DDE             TCPIP_GET_CAPAB_BLK1_ST3.1:
2527   4DDE             	; nz, get it
2528   4DDE DB 06       	in	a,(IN_DATA_PORT)
2529   4DE0 5F          	ld	e,a
2530   4DE1             TCPIP_GET_CAPAB_BLK1_ST4:
2531   4DE1 DB 07       	in	a,(IN_STS_PORT)
2532   4DE3 CB 47       	bit	0,a							; If nz has data
2533   4DE5 20 05       	jr	nz,TCPIP_GET_CAPAB_BLK1_ST4.1
2534   4DE7 CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
2535   4DEA 18 F5       	jr	TCPIP_GET_CAPAB_BLK1_ST4
2536   4DEC             TCPIP_GET_CAPAB_BLK1_ST4.1:
2537   4DEC             	; nz, get it
2538   4DEC DB 06       	in	a,(IN_DATA_PORT)
2539   4DEE 57          	ld	d,a
2540   4DEF             TCPIP_GET_CAPAB_BLK1_ST5:
2541   4DEF DB 07       	in	a,(IN_STS_PORT)
2542   4DF1 CB 47       	bit	0,a							; If nz has data
2543   4DF3 20 05       	jr	nz,TCPIP_GET_CAPAB_BLK1_ST5.1
2544   4DF5 CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
2545   4DF8 18 F5       	jr	TCPIP_GET_CAPAB_BLK1_ST5
2546   4DFA             TCPIP_GET_CAPAB_BLK1_ST5.1:
2547   4DFA             	; nz, get it
2548   4DFA DB 06       	in	a,(IN_DATA_PORT)
2549   4DFC 47          	ld	b,a
2550   4DFD             	; Done
2551   4DFD AF          	xor	a
2552   4DFE C9          	ret
2553   4DFF             
2554   4DFF             ;==========================
2555   4DFF             ;===  TCPIP_GET_IPINFO  ===
2556   4DFF             ;==========================
2557   4DFF             ;Get IP address.
2558   4DFF             ;
2559   4DFF             ;Input:  A = 2
2560   4DFF             ;        B = Index of address to obtain:
2561   4DFF             ;            1: Local IP address
2562   4DFF             ;            2: Peer IP address
2563   4DFF             ;            3: Subnet mask
2564   4DFF             ;            4: Default gateway
2565   4DFF             ;            5: Primary DNS server IP address
2566   4DFF             ;            6: Secondary DNS server IP address
2567   4DFF             ;Output: A = Error code
2568   4DFF             ;        L.H.E.D = Requested address
2569   4DFF             TCPIP_GET_IPINFO:
2570   4DFF D3 07       	out	(OUT_TX_PORT),a				; Send the command
2571   4E01 AF          	xor	a
2572   4E02 D3 07       	out	(OUT_TX_PORT),a				; Send the command size msb
2573   4E04 3C          	inc	a
2574   4E05 D3 07       	out	(OUT_TX_PORT),a				; Send the command size lsb
2575   4E07 78          	ld	a,b
2576   4E08 D3 07       	out (OUT_TX_PORT),a				; Send the parameter
2577   4E0A             
2578   4E0A             	; Now wait up to 600 ticks to get response
2579   4E0A 21 58 02    	ld	hl,600
2580   4E0D CD F4 57    	call	SETCOUNTER
2581   4E10             TCPIP_GET_IPINFO_ST1:
2582   4E10 DB 07       	in	a,(IN_STS_PORT)
2583   4E12 CB 47       	bit	0,a							; if nz has data
2584   4E14 20 05       	jr	nz,TCPIP_GET_IPINFO_ST1.1
2585   4E16 CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
2586   4E19 18 F5       	jr	TCPIP_GET_IPINFO_ST1
2587   4E1B             TCPIP_GET_IPINFO_ST1.1:
2588   4E1B             	; nz, check the data
2589   4E1B DB 06       	in	a,(IN_DATA_PORT)
2590   4E1D FE 02       	cp	2							; Is response of our command?
2591   4E1F 20 EF       	jr	nz,TCPIP_GET_IPINFO_ST1
2592   4E21             	; now get return code, if return code other than 0, it is finished
2593   4E21             TCPIP_GET_IPINFO_RC:
2594   4E21 DB 07       	in	a,(IN_STS_PORT)
2595   4E23 CB 47       	bit	0,a							; if nz has data
2596   4E25 20 05       	jr	nz,TCPIP_GET_IPINFO_RC.1
2597   4E27 CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
2598   4E2A 18 F5       	jr	TCPIP_GET_IPINFO_RC
2599   4E2C             TCPIP_GET_IPINFO_RC.1:
2600   4E2C             	; nz, discard
2601   4E2C DB 06       	in	a,(IN_DATA_PORT)
2602   4E2E B7          	or	a							; 0?
2603   4E2F C0          	ret	nz							; if not, done
2604   4E30             
2605   4E30             	; next two bytes are return code and size bytes, don't care, it is 4
2606   4E30 06 02       	ld	b,2
2607   4E32             TCPIP_GET_IPINFO_ST2:
2608   4E32 DB 07       	in	a,(IN_STS_PORT)
2609   4E34 CB 47       	bit	0,a							; if nz has data
2610   4E36 20 05       	jr	nz,TCPIP_GET_IPINFO_ST2.1
2611   4E38 CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
2612   4E3B 18 F5       	jr	TCPIP_GET_IPINFO_ST2
2613   4E3D             TCPIP_GET_IPINFO_ST2.1:
2614   4E3D             	; nz, discard
2615   4E3D DB 06       	in	a,(IN_DATA_PORT)
2616   4E3F 05          	dec	b
2617   4E40 20 F0       	jr	nz,TCPIP_GET_IPINFO_ST2
2618   4E42             
2619   4E42             	; now just get the 4 bytes IP and order it in L, H, E and D
2620   4E42             TCPIP_GET_IPINFO_IP_ST1:
2621   4E42 DB 07       	in	a,(IN_STS_PORT)
2622   4E44 CB 47       	bit	0,a							; if nz has data
2623   4E46 20 05       	jr	nz,TCPIP_GET_IPINFO_IP_ST1.1
2624   4E48 CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
2625   4E4B 18 F5       	jr	TCPIP_GET_IPINFO_IP_ST1
2626   4E4D             TCPIP_GET_IPINFO_IP_ST1.1:
2627   4E4D             	; nz, get it
2628   4E4D DB 06       	in	a,(IN_DATA_PORT)
2629   4E4F 6F          	ld	l,a
2630   4E50             TCPIP_GET_IPINFO_IP_ST2:
2631   4E50 DB 07       	in	a,(IN_STS_PORT)
2632   4E52 CB 47       	bit	0,a							; if nz has data
2633   4E54 20 05       	jr	nz,TCPIP_GET_IPINFO_IP_ST2.1
2634   4E56 CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
2635   4E59 18 F5       	jr	TCPIP_GET_IPINFO_IP_ST2
2636   4E5B             TCPIP_GET_IPINFO_IP_ST2.1:
2637   4E5B             	; nz, get it
2638   4E5B DB 06       	in	a,(IN_DATA_PORT)
2639   4E5D 67          	ld	h,a
2640   4E5E             TCPIP_GET_IPINFO_IP_ST3:
2641   4E5E DB 07       	in	a,(IN_STS_PORT)
2642   4E60 CB 47       	bit	0,a							; if nz has data
2643   4E62 20 05       	jr	nz,TCPIP_GET_IPINFO_IP_ST3.1
2644   4E64 CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
2645   4E67 18 F5       	jr	TCPIP_GET_IPINFO_IP_ST3
2646   4E69             TCPIP_GET_IPINFO_IP_ST3.1:
2647   4E69             	; nz, get it
2648   4E69 DB 06       	in	a,(IN_DATA_PORT)
2649   4E6B 5F          	ld	e,a
2650   4E6C             TCPIP_GET_IPINFO_IP_ST4:
2651   4E6C DB 07       	in	a,(IN_STS_PORT)
2652   4E6E CB 47       	bit	0,a							; if nz has data
2653   4E70 20 05       	jr	nz,TCPIP_GET_IPINFO_IP_ST4.1
2654   4E72 CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
2655   4E75 18 F5       	jr	TCPIP_GET_IPINFO_IP_ST4
2656   4E77             TCPIP_GET_IPINFO_IP_ST4.1:
2657   4E77             	; nz, get it
2658   4E77 DB 06       	in	a,(IN_DATA_PORT)
2659   4E79 57          	ld	d,a
2660   4E7A             	; done
2661   4E7A AF          	xor	a
2662   4E7B C9          	ret
2663   4E7C             
2664   4E7C             ;=========================
2665   4E7C             ;===  TCPIP_NET_STATE  ===
2666   4E7C             ;=========================
2667   4E7C             ;Get network state.
2668   4E7C             ;
2669   4E7C             ;Input:  A = 3
2670   4E7C             ;Output: A = Error code
2671   4E7C             ;        B = Current network state:
2672   4E7C             ;            0: Closed
2673   4E7C             ;            1: Opening
2674   4E7C             ;            2: Open
2675   4E7C             ;            3: Closing
2676   4E7C             ;            255: Unknown
2677   4E7C             TCPIP_NET_STATE:
2678   4E7C D3 07       	out	(OUT_TX_PORT),a				; Send the command
2679   4E7E AF          	xor	a
2680   4E7F D3 07       	out	(OUT_TX_PORT),a				; Send the command size msb
2681   4E81 D3 07       	out	(OUT_TX_PORT),a				; Send the command size lsb
2682   4E83             
2683   4E83             	; Now wait up to 720 ticks to get response
2684   4E83 21 D0 02    	ld	hl,720
2685   4E86 CD F4 57    	call	SETCOUNTER
2686   4E89             TCPIP_NET_STATE_ST1:
2687   4E89 DB 07       	in	a,(IN_STS_PORT)
2688   4E8B CB 47       	bit	0,a							; if nz has data
2689   4E8D 20 05       	jr	nz,TCPIP_NET_STATE_ST1.1
2690   4E8F CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
2691   4E92 18 F5       	jr	TCPIP_NET_STATE_ST1
2692   4E94             TCPIP_NET_STATE_ST1.1:
2693   4E94             	; nz, check the data
2694   4E94 DB 06       	in	a,(IN_DATA_PORT)
2695   4E96 FE 03       	cp	3							; Is response of our command?
2696   4E98 20 EF       	jr	nz,TCPIP_NET_STATE_ST1
2697   4E9A             	; now get return code, if return code other than 0, it is finished
2698   4E9A             TCPIP_NET_STATE_RC:
2699   4E9A DB 07       	in	a,(IN_STS_PORT)
2700   4E9C CB 47       	bit	0,a							; if nz has data
2701   4E9E 20 05       	jr	nz,TCPIP_NET_STATE_RC.1
2702   4EA0 CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
2703   4EA3 18 F5       	jr	TCPIP_NET_STATE_RC
2704   4EA5             TCPIP_NET_STATE_RC.1:
2705   4EA5             	; nz, get it
2706   4EA5 DB 06       	in	a,(IN_DATA_PORT)
2707   4EA7 B7          	or	a							; 0?
2708   4EA8 C0          	ret	nz							; if not, done
2709   4EA9             
2710   4EA9             	; next two bytes are return code and size bytes, don't care, it is 1
2711   4EA9 06 02       	ld	b,2
2712   4EAB             TCPIP_NET_STATE_ST2:
2713   4EAB DB 07       	in	a,(IN_STS_PORT)
2714   4EAD CB 47       	bit	0,a							; if nz has data
2715   4EAF 20 05       	jr	nz,TCPIP_NET_STATE_ST2.1
2716   4EB1 CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
2717   4EB4 18 F5       	jr	TCPIP_NET_STATE_ST2
2718   4EB6             TCPIP_NET_STATE_ST2.1:
2719   4EB6             	; nz, discard
2720   4EB6 DB 06       	in	a,(IN_DATA_PORT)
2721   4EB8 05          	dec	b
2722   4EB9 20 F0       	jr	nz,TCPIP_NET_STATE_ST2
2723   4EBB             
2724   4EBB             	; now just get the 1 byte (NET STATE) IP and place it in B
2725   4EBB             TCPIP_NET_STATE_NS_ST1:
2726   4EBB DB 07       	in	a,(IN_STS_PORT)
2727   4EBD CB 47       	bit	0,a							; if nz has data
2728   4EBF 20 05       	jr	nz,TCPIP_NET_STATE_NS_ST1.1
2729   4EC1 CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
2730   4EC4 18 F5       	jr	TCPIP_NET_STATE_NS_ST1
2731   4EC6             TCPIP_NET_STATE_NS_ST1.1:
2732   4EC6             	; nz, get it
2733   4EC6 DB 06       	in	a,(IN_DATA_PORT)
2734   4EC8 47          	ld	b,a
2735   4EC9             	; done
2736   4EC9 AF          	xor	a
2737   4ECA C9          	ret
2738   4ECB             
2739   4ECB             ;=====================
2740   4ECB             ;===  TCPIP_DNS_Q  ===
2741   4ECB             ;=====================
2742   4ECB             ;Start a host name resolution query.
2743   4ECB             ;
2744   4ECB             ;Input:  A  = 6
2745   4ECB             ;        HL = Address of the host name to be resolved, zero terminated
2746   4ECB             ;        B  = Flags, when set to 1 they instruct the resolver to:
2747   4ECB             ;             bit 0: Only abort the query currently in progress, if there is any
2748   4ECB             ;                    (other flags and registers are then ignored)
2749   4ECB             ;             bit 1: Assume that the passed name is an IP address,
2750   4ECB             ;                    and return an error if this is not true
2751   4ECB             ;             bit 2: If there is a query in progress already,
2752   4ECB             ;                    do NOT abort it and return an error instead
2753   4ECB             ;Output:  A = Error code
2754   4ECB             ;         B = 0 if a query to a DNS server is in progress
2755   4ECB             ;             1 if the name represented an IP address
2756   4ECB             ;             2 if the name could be resolved locally
2757   4ECB             ;         L.H.E.D = Resolved IP address
2758   4ECB             ;                   (only if no error occurred and B=1 or 2 is returned)
2759   4ECB             ;RAM Buffer to store names to be resolved (and used also to translate IPs from ASCII to 32bits number)
2760   4ECB             ;Will store the result of the last DNS query
2761   4ECB             TCPIP_DNS_Q:
2762   4ECB E5          	push	hl						; Save HL
2763   4ECC AF          	xor	a
2764   4ECD 5F          	ld	e,a
2765   4ECE 57          	ld	d,a							; Zero DE
2766   4ECF             TCPIP_DNS_Q_SIZE_LOOP:
2767   4ECF 7E          	ld	a,(hl)						; so let's check the size of dns data
2768   4ED0 B7          	or	a							; it is zero terminated
2769   4ED1 28 05       	jr	z,TCPIP_DNS_Q_SEND			; if zero, end of string
2770   4ED3 13          	inc	de							; ok, not zero, one more char
2771   4ED4 23          	inc	hl							; next
2772   4ED5 C3 CF 4E    	jp	TCPIP_DNS_Q_SIZE_LOOP		; jp is a tad bit faster and we are not worried about code size
2773   4ED8             TCPIP_DNS_Q_SEND:
2774   4ED8             	; Here we send the query and wait the result
2775   4ED8 13          	inc	de							; add 1, we will send flag first
2776   4ED9 3E CE       	ld	a,206						; DNS_Q_NEW
2777   4EDB D3 07       	out	(OUT_TX_PORT),a				; Send the command
2778   4EDD 7A          	ld	a,d
2779   4EDE D3 07       	out	(OUT_TX_PORT),a				; Send the command size msb
2780   4EE0 7B          	ld	a,e
2781   4EE1 D3 07       	out	(OUT_TX_PORT),a				; Send the command size lsb
2782   4EE3 78          	ld	a,b
2783   4EE4 D3 07       	out	(OUT_TX_PORT),a				; Send the flag byte
2784   4EE6             
2785   4EE6             	; now otir of DNS/DNS BUFFER DATA SIZE
2786   4EE6 0E 07       	ld	c,OUT_TX_PORT				; our data TX port
2787   4EE8 E1          	pop	hl							; string to try to resolve
2788   4EE9 1B          	dec	de							; we are sending just data addressed by HL, so revert count
2789   4EEA 7A          	ld	a,d
2790   4EEB B3          	or	e							; if de zero, no string, wrong parameters, but let the ESP answer
2791   4EEC CA FC 4E    	jp	z,TCPIP_DNS_Q_WAIT_RSP
2792   4EEF AF          	xor	a
2793   4EF0             	; Fast 16 bit variable size loop by GRAUW
2794   4EF0 43          	ld	b,e
2795   4EF1 1B          	dec	de
2796   4EF2 14          	inc	d
2797   4EF3             TCPIP_DNS_Q_SENDLP:
2798   4EF3             	; send it
2799   4EF3 ED A3       	outi
2800   4EF5 C2 F3 4E    	jp	nz,TCPIP_DNS_Q_SENDLP
2801   4EF8 15          	dec	d
2802   4EF9 C2 F3 4E    	jp	nz,TCPIP_DNS_Q_SENDLP
2803   4EFC             TCPIP_DNS_Q_WAIT_RSP:
2804   4EFC             	; Now wait up to 900 ticks (15s@60Hz) to get response
2805   4EFC 21 84 03    	ld	hl,900
2806   4EFF CD F4 57    	call	SETCOUNTER
2807   4F02             TCPIP_DNSQ_SEND_ST1:
2808   4F02 DB 07       	in	a,(IN_STS_PORT)
2809   4F04 CB 47       	bit	0,a ;if nz has data
2810   4F06 20 05       	jr	nz,TCPIP_DNSQ_SEND_ST1.1
2811   4F08 CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
2812   4F0B 18 F5       	jr	TCPIP_DNSQ_SEND_ST1
2813   4F0D             TCPIP_DNSQ_SEND_ST1.1:
2814   4F0D             	; nz, check the data
2815   4F0D DB 06       	in	a,(IN_DATA_PORT)
2816   4F0F FE CE       	cp	206							; Is response of our command?
2817   4F11 20 EF       	jr	nz,TCPIP_DNSQ_SEND_ST1
2818   4F13             	; now get return code, if return code other than 0, it is finished
2819   4F13             TCPIP_DNSQ_SEND_RC:
2820   4F13 DB 07       	in	a,(IN_STS_PORT)
2821   4F15 CB 47       	bit	0,a							; if nz has data
2822   4F17 20 05       	jr	nz,TCPIP_DNSQ_SEND_RC.1
2823   4F19 CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
2824   4F1C 18 F5       	jr	TCPIP_DNSQ_SEND_RC
2825   4F1E             TCPIP_DNSQ_SEND_RC.1:
2826   4F1E             	; nz, discard
2827   4F1E DB 06       	in	a,(IN_DATA_PORT)
2828   4F20 B7          	or	a							; 0?
2829   4F21 06 00       	ld	b,0							; say in progress as there is no failure status
2830   4F23 C0          	ret	nz							; if not, done, ERROR won't return data
2831   4F24             
2832   4F24             	; next two bytes are return code and size bytes, don't care, it is 4, resolved IP
2833   4F24 06 02       	ld	b,2
2834   4F26             TCPIP_DNSQ_SEND_RC_ST2:
2835   4F26 DB 07       	in	a,(IN_STS_PORT)
2836   4F28 CB 47       	bit	0,a							; if nz has data
2837   4F2A 20 05       	jr	nz,TCPIP_DNSQ_SEND_RC_ST2.1
2838   4F2C CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
2839   4F2F 18 F5       	jr	TCPIP_DNSQ_SEND_RC_ST2
2840   4F31             TCPIP_DNSQ_SEND_RC_ST2.1:
2841   4F31             	; nz, discard
2842   4F31 DB 06       	in	a,(IN_DATA_PORT)
2843   4F33 05          	dec	b
2844   4F34 20 F0       	jr	nz,TCPIP_DNSQ_SEND_RC_ST2
2845   4F36             
2846   4F36             	; now just get the 4 bytes IP and place it in L H E D
2847   4F36             TCPIP_DNSQ_IP_ST1:
2848   4F36 DB 07       	in	a,(IN_STS_PORT)
2849   4F38 CB 47       	bit	0,a							; if nz has data
2850   4F3A 20 05       	jr	nz,TCPIP_DNSQ_IP_ST1.1
2851   4F3C CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
2852   4F3F 18 F5       	jr	TCPIP_DNSQ_IP_ST1
2853   4F41             TCPIP_DNSQ_IP_ST1.1:
2854   4F41             	; nz, get it
2855   4F41 DB 06       	in	a,(IN_DATA_PORT)
2856   4F43 6F          	ld	l,a
2857   4F44             TCPIP_DNSQ_IP_ST2:
2858   4F44 DB 07       	in	a,(IN_STS_PORT)
2859   4F46 CB 47       	bit	0,a							; if nz has data
2860   4F48 20 05       	jr	nz,TCPIP_DNSQ_IP_ST2.1
2861   4F4A CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
2862   4F4D 18 F5       	jr	TCPIP_DNSQ_IP_ST2
2863   4F4F             TCPIP_DNSQ_IP_ST2.1:
2864   4F4F             	; nz, get it
2865   4F4F DB 06       	in	a,(IN_DATA_PORT)
2866   4F51 67          	ld	h,a
2867   4F52             TCPIP_DNSQ_IP_ST3:
2868   4F52 DB 07       	in	a,(IN_STS_PORT)
2869   4F54 CB 47       	bit	0,a							; if nz has data
2870   4F56 20 05       	jr	nz,TCPIP_DNSQ_IP_ST3.1
2871   4F58 CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
2872   4F5B 18 F5       	jr	TCPIP_DNSQ_IP_ST3
2873   4F5D             TCPIP_DNSQ_IP_ST3.1:
2874   4F5D             	; nz, get it
2875   4F5D DB 06       	in	a,(IN_DATA_PORT)
2876   4F5F 5F          	ld	e,a
2877   4F60             TCPIP_DNSQ_IP_ST4:
2878   4F60 DB 07       	in	a,(IN_STS_PORT)
2879   4F62 CB 47       	bit	0,a							; if nz has data
2880   4F64 20 05       	jr	nz,TCPIP_DNSQ_IP_ST4.1
2881   4F66 CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
2882   4F69 18 F5       	jr	TCPIP_DNSQ_IP_ST4
2883   4F6B             TCPIP_DNSQ_IP_ST4.1:
2884   4F6B             	; nz, get it
2885   4F6B DB 06       	in	a,(IN_DATA_PORT)
2886   4F6D 57          	ld	d,a
2887   4F6E             	; done
2888   4F6E 3E 01       	ld	a,1
2889   4F70 CD EB 58    	call	SETDNSREADY				; DNS done
2890   4F73 CD 15 59    	call	SETDNSRESULT			; DNS RESULT
2891   4F76 06 02       	ld	b,2
2892   4F78 AF          	xor	a
2893   4F79 C9          	ret
2894   4F7A             
2895   4F7A             ;=====================
2896   4F7A             ;===  TCPIP_DNS_S  ===
2897   4F7A             ;=====================
2898   4F7A             ;Obtains the host name resolution process state and result.
2899   4F7A             ;
2900   4F7A             ;Input:  A = 7
2901   4F7A             ;        B = Flags, when set to 1 they instruct the resolver to:
2902   4F7A             ;            bit 0: Clear any existing result or error condition after the execution
2903   4F7A             ;                   (except if there is a query in progress)
2904   4F7A             ;Output: A = Error code
2905   4F7A             ;        B = DNS error code (when error is ERR_DNS)
2906   4F7A             ;        B = Current query status (when error is ERR_OK):
2907   4F7A             ;            0: There is no query in progress, nor any result nor error code available
2908   4F7A             ;            1: There is a query in progress
2909   4F7A             ;            2: Query is complete
2910   4F7A             ;        C = Current query sub status (when error is ERR_OK and B=1):
2911   4F7A             ;            0: Unknown
2912   4F7A             ;            1: Querying the primary DNS server
2913   4F7A             ;            2: Querying the secondary DNS server
2914   4F7A             ;            3: Querying another DNS server
2915   4F7A             ;        C = Resolution process type (when error is ERR_OK and B=2):
2916   4F7A             ;            0: The name was obtained by querying a DNS server
2917   4F7A             ;            1: The name was a direct representation of an IP address
2918   4F7A             ;            2: The name was resolved locally
2919   4F7A             ;       L.H.E.D = Resolved IP address (when error is ERR_OK and B=2)
2920   4F7A             TCPIP_DNS_S:
2921   4F7A             	;--- Is there a result?
2922   4F7A CD D9 58    	call	GETDNSREADY				; DNS done?
2923   4F7D B7          	or	a
2924   4F7E 28 23       	jr	z,TCPIP_DNS_S_NORESULT		; No DNS result
2925   4F80             	;--- Ok, we have a result, is it success?
2926   4F80 3D          	dec a
2927   4F81 28 12       	jr	z,TCPIP_DNS_S_HASRESULT		; If it is 1, it was not an error
2928   4F83             	;--- Shoot, there is an error...
2929   4F83             	;--- And sure thing, ESP do not tell us details, it is always failure :-P
2930   4F83 CB 40       	bit	0,b							;--- clear error after this?
2931   4F85 28 09       	jr	z,TCP_IP_DNS_S_NOCLR
2932   4F87             	;--- Clear
2933   4F87 06 00       	ld b,0							;--- Like I've said, no details
2934   4F89 AF          	xor	a
2935   4F8A CD EB 58    	call	SETDNSREADY				; DNS not done
2936   4F8D 3E 08       	ld	a,ERR_DNS;
2937   4F8F C9          	ret
2938   4F90             TCP_IP_DNS_S_NOCLR:
2939   4F90             	;--- Don't clear
2940   4F90 3E 08       	ld	a,ERR_DNS
2941   4F92 06 00       	ld	b,0							;--- Like I've said, no details
2942   4F94 C9          	ret
2943   4F95             	;--- There is a result available...
2944   4F95             TCPIP_DNS_S_HASRESULT:
2945   4F95             	;--- Copy the result
2946   4F95 CD FF 58    	call	GETDNSRESULT
2947   4F98 AF          	xor	a
2948   4F99 CB 40       	bit	0,b							;--- clear result after this?
2949   4F9B 28 03       	jr	z,TCP_IP_DNS_S_RES_NOCLR	;--- no, just return
2950   4F9D             	;--- Yes, clear
2951   4F9D CD EB 58    	call	SETDNSREADY				; DNS not done
2952   4FA0             TCP_IP_DNS_S_RES_NOCLR:
2953   4FA0 06 02       	ld	b,2
2954   4FA2 C9          	ret
2955   4FA3             
2956   4FA3             TCPIP_DNS_S_NORESULT:
2957   4FA3 AF          	xor	a							;--- OK no query in progress, no result, means nothing in progress
2958   4FA4 06 00       	ld	b,0							;--- No query in progress
2959   4FA6 C9          	ret
2960   4FA7             
2961   4FA7             ;========================
2962   4FA7             ;===  TCPIP_UDP_OPEN  ===
2963   4FA7             ;========================
2964   4FA7             ;Open an UDP connection.
2965   4FA7             ;
2966   4FA7             ;Input:  A  = 8
2967   4FA7             ;        HL = Local port number (#FFFF=random)
2968   4FA7             ;        B  = Intended connection lifetime:
2969   4FA7             ;             0: Transient
2970   4FA7             ;             1: Resident
2971   4FA7             ;Output: A = Error code
2972   4FA7             ;        B = Connection number
2973   4FA7             TCPIP_UDP_OPEN:
2974   4FA7 D3 07       	out	(OUT_TX_PORT),a				; Send the command
2975   4FA9 AF          	xor	a
2976   4FAA D3 07       	out	(OUT_TX_PORT),a				; Send the command size msb
2977   4FAC 3E 03       	ld	a,3
2978   4FAE D3 07       	out	(OUT_TX_PORT),a				; Send the command size lsb
2979   4FB0 7D          	ld	a,l
2980   4FB1 D3 07       	out	(OUT_TX_PORT),a				; Send the port LSB
2981   4FB3 7C          	ld	a,h
2982   4FB4 D3 07       	out	(OUT_TX_PORT),a				; Send the port MSB
2983   4FB6 78          	ld	a,b
2984   4FB7 D3 07       	out	(OUT_TX_PORT),a				; Send the connection transient/resident
2985   4FB9             
2986   4FB9             	; Now wait up to 180 ticks to get response
2987   4FB9 21 B4 00    	ld	hl,180
2988   4FBC CD F4 57    	call	SETCOUNTER
2989   4FBF             TCPIP_UDP_OPEN_ST1:
2990   4FBF DB 07       	in	a,(IN_STS_PORT)
2991   4FC1 CB 47       	bit	0,a							; if nz has data
2992   4FC3 20 05       	jr	nz,TCPIP_UDP_OPEN_ST1.1
2993   4FC5 CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
2994   4FC8 18 F5       	jr	TCPIP_UDP_OPEN_ST1
2995   4FCA             TCPIP_UDP_OPEN_ST1.1:
2996   4FCA             	; nz, check the data
2997   4FCA DB 06       	in	a,(IN_DATA_PORT)
2998   4FCC FE 08       	cp	8							; Is response of our command?
2999   4FCE 20 EF       	jr	nz,TCPIP_UDP_OPEN_ST1
3000   4FD0             	; now get return code, if return code other than 0, it is finished
3001   4FD0             TCPIP_UDP_OPEN_RC:
3002   4FD0 DB 07       	in	a,(IN_STS_PORT)
3003   4FD2 CB 47       	bit	0,a							; if nz has data
3004   4FD4 20 05       	jr	nz,TCPIP_UDP_OPEN_RC.1
3005   4FD6 CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
3006   4FD9 18 F5       	jr	TCPIP_UDP_OPEN_RC
3007   4FDB             TCPIP_UDP_OPEN_RC.1:
3008   4FDB             	; nz, discard
3009   4FDB DB 06       	in	a,(IN_DATA_PORT)
3010   4FDD B7          	or	a							; 0?
3011   4FDE C0          	ret	nz							; if not, done
3012   4FDF             
3013   4FDF             	; next two bytes are return code and size bytes, don't care, it is 1, conn #
3014   4FDF 06 02       	ld	b,2
3015   4FE1             TCPIP_UDP_OPEN_ST2:
3016   4FE1 DB 07       	in	a,(IN_STS_PORT)
3017   4FE3 CB 47       	bit	0,a							; if nz has data
3018   4FE5 20 05       	jr	nz,TCPIP_UDP_OPEN_ST2.1
3019   4FE7 CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
3020   4FEA 18 F5       	jr	TCPIP_UDP_OPEN_ST2
3021   4FEC             TCPIP_UDP_OPEN_ST2.1:
3022   4FEC             	; nz, discard
3023   4FEC DB 06       	in	a,(IN_DATA_PORT)
3024   4FEE 05          	dec	b
3025   4FEF 20 F0       	jr	nz,TCPIP_UDP_OPEN_ST2
3026   4FF1             
3027   4FF1             	; now just get the 1 byte, conn#, should go to B
3028   4FF1             TCPIP_UDP_OPEN_CONN_ST1:
3029   4FF1 DB 07       	in	a,(IN_STS_PORT)
3030   4FF3 CB 47       	bit	0,a							;if nz has data
3031   4FF5 20 05       	jr	nz,TCPIP_UDP_OPEN_CONN_ST1.1
3032   4FF7 CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
3033   4FFA 18 F5       	jr	TCPIP_UDP_OPEN_CONN_ST1
3034   4FFC             TCPIP_UDP_OPEN_CONN_ST1.1:
3035   4FFC             	; nz, get it
3036   4FFC DB 06       	in	a,(IN_DATA_PORT)
3037   4FFE 47          	ld	b,a
3038   4FFF             	; done
3039   4FFF AF          	xor	a
3040   5000 C9          	ret
3041   5001             
3042   5001             ;=========================
3043   5001             ;===  TCPIP_UDP_CLOSE  ===
3044   5001             ;=========================
3045   5001             ;Close a UDP connection.
3046   5001             ;
3047   5001             ;Input:  A = 9
3048   5001             ;        B = Connection number
3049   5001             ;            0 to close all open transient UDP connections
3050   5001             ;Output: A = Error code
3051   5001             TCPIP_UDP_CLOSE:
3052   5001 D3 07       	out	(OUT_TX_PORT),a				; Send the command
3053   5003 AF          	xor	a
3054   5004 D3 07       	out	(OUT_TX_PORT),a				; Send the command size msb
3055   5006 3E 01       	ld	a,1
3056   5008 D3 07       	out	(OUT_TX_PORT),a				; Send the command size lsb
3057   500A 78          	ld	a,b
3058   500B D3 07       	out	(OUT_TX_PORT),a				; Send the connection #
3059   500D             	; Now wait up to 180 ticks to get response
3060   500D 21 B4 00    	ld	hl,180
3061   5010 CD F4 57    	call	SETCOUNTER
3062   5013             TCPIP_UDP_CLOSE_ST1:
3063   5013 DB 07       	in	a,(IN_STS_PORT)
3064   5015 CB 47       	bit	0,a							; if nz has data
3065   5017 20 05       	jr	nz,TCPIP_UDP_CLOSE_ST1.1
3066   5019 CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
3067   501C 18 F5       	jr	TCPIP_UDP_CLOSE_ST1
3068   501E             TCPIP_UDP_CLOSE_ST1.1:
3069   501E             	; nz, check the data
3070   501E DB 06       	in	a,(IN_DATA_PORT)
3071   5020 FE 09       	cp	9							; Is response of our command?
3072   5022 20 EF       	jr	nz,TCPIP_UDP_CLOSE_ST1
3073   5024             	; now get return code, if return code other than 0, it is finished
3074   5024             TCPIP_UDP_CLOSE_RC:
3075   5024 DB 07       	in	a,(IN_STS_PORT)
3076   5026 CB 47       	bit	0,a							; if nz has data
3077   5028 20 05       	jr	nz,TCPIP_UDP_CLOSE_RC.1
3078   502A CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
3079   502D 18 F5       	jr	TCPIP_UDP_CLOSE_RC
3080   502F             TCPIP_UDP_CLOSE_RC.1:
3081   502F             	; nz, discard
3082   502F DB 06       	in	a,(IN_DATA_PORT)
3083   5031 B7          	or	a							; 0?
3084   5032 C0          	ret	nz							; if not, done
3085   5033             
3086   5033             	; next two bytes are return code and size bytes, don't care, it is 1, conn #
3087   5033 06 02       	ld	b,2
3088   5035             TCPIP_UDP_CLOSE_ST2:
3089   5035 DB 07       	in	a,(IN_STS_PORT)
3090   5037 CB 47       	bit	0,a							; if nz has data
3091   5039 20 05       	jr	nz,TCPIP_UDP_CLOSE_ST2.1
3092   503B CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
3093   503E 18 F5       	jr	TCPIP_UDP_CLOSE_ST2
3094   5040             TCPIP_UDP_CLOSE_ST2.1:
3095   5040             	; nz, discard
3096   5040 DB 06       	in	a,(IN_DATA_PORT)
3097   5042 05          	dec	b
3098   5043 20 F0       	jr	nz,TCPIP_UDP_CLOSE_ST2
3099   5045             
3100   5045             	; done, no return data other than return code
3101   5045 AF          	xor	a
3102   5046 C9          	ret
3103   5047             
3104   5047             ;=========================
3105   5047             ;===  TCPIP_UDP_STATE  ===
3106   5047             ;=========================
3107   5047             ;Get the state of a UDP connection.
3108   5047             ;
3109   5047             ;Input:  A = 10
3110   5047             ;        B = Connection number
3111   5047             ;Output: A  = Error code
3112   5047             ;        HL = Local port number
3113   5047             ;        B  = Number of pending incoming datagrams
3114   5047             ;        DE = Size of oldest pending incoming datagram (data part only)
3115   5047             TCPIP_UDP_STATE:
3116   5047 D3 07       	out	(OUT_TX_PORT),a				; Send the command
3117   5049 AF          	xor	a
3118   504A D3 07       	out	(OUT_TX_PORT),a				; Send the command size msb
3119   504C 3C          	inc	a
3120   504D D3 07       	out	(OUT_TX_PORT),a				; Send the command size lsb
3121   504F 78          	ld	a,b
3122   5050 D3 07       	out	(OUT_TX_PORT),a				; Send the parameter
3123   5052             
3124   5052             	; Now wait up to 60 ticks to get response
3125   5052 21 3C 00    	ld	hl,60
3126   5055 CD F4 57    	call	SETCOUNTER
3127   5058             TCPIP_UDP_STATE_ST1:
3128   5058 DB 07       	in	a,(IN_STS_PORT)
3129   505A CB 47       	bit	0,a							; if nz has data
3130   505C 20 05       	jr	nz,TCPIP_UDP_STATE_ST1.1
3131   505E CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
3132   5061 18 F5       	jr	TCPIP_UDP_STATE_ST1
3133   5063             TCPIP_UDP_STATE_ST1.1:
3134   5063             	; nz, check the data
3135   5063 DB 06       	in	a,(IN_DATA_PORT)
3136   5065 FE 0A       	cp	10							; Is response of our command?
3137   5067 20 EF       	jr	nz,TCPIP_UDP_STATE_ST1
3138   5069             	; now get return code, if return code other than 0, it is finished
3139   5069             TCPIP_UDP_STATE_RC:
3140   5069 DB 07       	in	a,(IN_STS_PORT)
3141   506B CB 47       	bit	0,a							; if nz has data
3142   506D 20 05       	jr	nz,TCPIP_UDP_STATE_RC.1
3143   506F CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
3144   5072 18 F5       	jr	TCPIP_UDP_STATE_RC
3145   5074             TCPIP_UDP_STATE_RC.1:
3146   5074             	; nz, discard
3147   5074 DB 06       	in	a,(IN_DATA_PORT)
3148   5076 B7          	or	a							; 0?
3149   5077 C0          	ret	nz							; if not, done
3150   5078             
3151   5078             	; next two bytes are return code and size bytes, don't care, it is 5
3152   5078 06 02       	ld	b,2
3153   507A             TCPIP_UDP_STATE_ST2:
3154   507A DB 07       	in	a,(IN_STS_PORT)
3155   507C CB 47       	bit	0,a							; if nz has data
3156   507E 20 05       	jr	nz,TCPIP_UDP_STATE_ST2.1
3157   5080 CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
3158   5083 18 F5       	jr	TCPIP_UDP_STATE_ST2
3159   5085             TCPIP_UDP_STATE_ST2.1:
3160   5085             	; nz, discard
3161   5085 DB 06       	in	a,(IN_DATA_PORT)
3162   5087 05          	dec	b
3163   5088 20 F0       	jr	nz,TCPIP_UDP_STATE_ST2
3164   508A             
3165   508A             	; now just get the 5 bytes (Port LSB then MSB, # of packets, packet size LSB then MSB) and order it in L, H, B, E and D
3166   508A             TCPIP_UDP_STATE_RESP_ST1:
3167   508A DB 07       	in	a,(IN_STS_PORT)
3168   508C CB 47       	bit	0,a							; if nz has data
3169   508E 20 05       	jr	nz,TCPIP_UDP_STATE_RESP_ST1.1
3170   5090 CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
3171   5093 18 F5       	jr	TCPIP_UDP_STATE_RESP_ST1
3172   5095             TCPIP_UDP_STATE_RESP_ST1.1:
3173   5095             	; nz, get it
3174   5095 DB 06       	in	a,(IN_DATA_PORT)
3175   5097 6F          	ld	l,a
3176   5098             TCPIP_UDP_STATE_RESP_ST2:
3177   5098 DB 07       	in	a,(IN_STS_PORT)
3178   509A CB 47       	bit	0,a							; if nz has data
3179   509C 20 05       	jr	nz,TCPIP_UDP_STATE_RESP_ST2.1
3180   509E CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
3181   50A1 18 F5       	jr	TCPIP_UDP_STATE_RESP_ST2
3182   50A3             TCPIP_UDP_STATE_RESP_ST2.1:
3183   50A3             	; nz, get it
3184   50A3 DB 06       	in	a,(IN_DATA_PORT)
3185   50A5 67          	ld	h,a
3186   50A6             TCPIP_UDP_STATE_RESP_ST3:
3187   50A6 DB 07       	in	a,(IN_STS_PORT)
3188   50A8 CB 47       	bit	0,a							; if nz has data
3189   50AA 20 05       	jr	nz,TCPIP_UDP_STATE_RESP_ST3.1
3190   50AC CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
3191   50AF 18 F5       	jr	TCPIP_UDP_STATE_RESP_ST3
3192   50B1             TCPIP_UDP_STATE_RESP_ST3.1:
3193   50B1             	; nz, get it
3194   50B1 DB 06       	in	a,(IN_DATA_PORT)
3195   50B3 47          	ld	b,a
3196   50B4             TCPIP_UDP_STATE_RESP_ST4:
3197   50B4 DB 07       	in	a,(IN_STS_PORT)
3198   50B6 CB 47       	bit	0,a							; if nz has data
3199   50B8 20 05       	jr	nz,TCPIP_UDP_STATE_RESP_ST4.1
3200   50BA CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
3201   50BD 18 F5       	jr	TCPIP_UDP_STATE_RESP_ST4
3202   50BF             TCPIP_UDP_STATE_RESP_ST4.1:
3203   50BF             	; nz, get it
3204   50BF DB 06       	in	a,(IN_DATA_PORT)
3205   50C1 5F          	ld	e,a
3206   50C2             TCPIP_UDP_STATE_RESP_ST5:
3207   50C2 DB 07       	in	a,(IN_STS_PORT)
3208   50C4 CB 47       	bit	0,a							; if nz has data
3209   50C6 20 05       	jr	nz,TCPIP_UDP_STATE_RESP_ST5.1
3210   50C8 CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
3211   50CB 18 F5       	jr	TCPIP_UDP_STATE_RESP_ST5
3212   50CD             TCPIP_UDP_STATE_RESP_ST5.1:
3213   50CD             	; nz, get it
3214   50CD DB 06       	in	a,(IN_DATA_PORT)
3215   50CF 57          	ld	d,a
3216   50D0             	; done
3217   50D0 AF          	xor	a
3218   50D1 C9          	ret
3219   50D2             
3220   50D2             ;========================
3221   50D2             ;===  TCPIP_UDP_SEND  ===
3222   50D2             ;========================
3223   50D2             ;Send an UDP datagram.
3224   50D2             ;
3225   50D2             ;Input:  A = 11
3226   50D2             ;        B = Connection number
3227   50D2             ;        HL = Address of datagram data
3228   50D2             ;        DE = Address of parameters block
3229   50D2             ;Output: A = Error code
3230   50D2             ;
3231   50D2             ;Parameters block:
3232   50D2             ;
3233   50D2             ;    +0 (4): Destination IP address
3234   50D2             ;    +4 (2): Destination port
3235   50D2             ;    +6 (2): Data length
3236   50D2             TCPIP_UDP_SEND:
3237   50D2 E5          	push	hl
3238   50D3 D5          	push	de
3239   50D4 D3 07       	out	(OUT_TX_PORT),a				; Send the command
3240   50D6             	; prepare new data size, adding our 7 bytes overhead
3241   50D6 DD 62       	ld	ixh,d
3242   50D8 DD 6B       	ld	ixl,e
3243   50DA 11 07 00    	ld	de,7
3244   50DD DD 6E 06    	ld	l,(ix+6)
3245   50E0 DD 66 07    	ld	h,(ix+7)
3246   50E3 19          	add	hl,de
3247   50E4 7C          	ld	a,h
3248   50E5 D3 07       	out	(OUT_TX_PORT),a				; Send the command size msb
3249   50E7 7D          	ld	a,l
3250   50E8 D3 07       	out	(OUT_TX_PORT),a				; Send the command size lsb
3251   50EA 78          	ld	a,b
3252   50EB D3 07       	out	(OUT_TX_PORT),a				; Send the connection #
3253   50ED D1          	pop	de
3254   50EE E1          	pop	hl
3255   50EF 1A          	ld	a,(de)
3256   50F0 D3 07       	out	(OUT_TX_PORT),a				; Send IP byte 1
3257   50F2 13          	inc	de
3258   50F3 1A          	ld	a,(de)
3259   50F4 D3 07       	out	(OUT_TX_PORT),a				; Send IP byte 2
3260   50F6 13          	inc	de
3261   50F7 1A          	ld	a,(de)
3262   50F8 D3 07       	out	(OUT_TX_PORT),a				; Send IP byte 3
3263   50FA 13          	inc	de
3264   50FB 1A          	ld	a,(de)
3265   50FC D3 07       	out	(OUT_TX_PORT),a				; Send IP byte 4
3266   50FE 13          	inc	de
3267   50FF 1A          	ld	a,(de)
3268   5100 D3 07       	out	(OUT_TX_PORT),a				; Send Port LSB
3269   5102 13          	inc	de
3270   5103 1A          	ld	a,(de)
3271   5104 D3 07       	out	(OUT_TX_PORT),a				; Send Port MSB
3272   5106             	; now oti the data starting at hl, size is in next DE position
3273   5106 13          	inc	de
3274   5107 1A          	ld	a,(de)
3275   5108 47          	ld	b,a							; save lsb in b
3276   5109 13          	inc	de
3277   510A 1A          	ld	a,(de)						; msb
3278   510B 57          	ld	d,a							; put in D, there is no ld d,(de)
3279   510C 58          	ld	e,b							; lsb
3280   510D             	; Grauw Optimized 16 bit loop, handy for us, mostly since we can use outi :-D
3281   510D             	;ld	b,e							; Number of loops originaly in DE, not needed, b already has e
3282   510D 1B          	dec	de
3283   510E 14          	inc	d
3284   510F 0E 07       	ld	c,OUT_TX_PORT
3285   5111             TCPIP_UDP_SEND_R:
3286   5111 ED B3       	otir							; Send until B is 0
3287   5113 15          	dec	d							; decrement secondary counter
3288   5114 20 FB       	jr	nz,TCPIP_UDP_SEND_R			; If still have another round, do it
3289   5116             
3290   5116             	; Now wait up to 600 ticks to get response
3291   5116 21 58 02    	ld	hl,600
3292   5119 CD F4 57    	call	SETCOUNTER
3293   511C             TCPIP_UDP_SEND_ST1:
3294   511C DB 07       	in	a,(IN_STS_PORT)
3295   511E CB 47       	bit	0,a							; if nz has data
3296   5120 20 05       	jr	nz,TCPIP_UDP_SEND_ST1.1
3297   5122 CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
3298   5125 18 F5       	jr	TCPIP_UDP_SEND_ST1
3299   5127             TCPIP_UDP_SEND_ST1.1:
3300   5127             	; nz, check the data
3301   5127 DB 06       	in	a,(IN_DATA_PORT)
3302   5129 FE 0B       	cp	11							; Is response of our command?
3303   512B 20 EF       	jr	nz,TCPIP_UDP_SEND_ST1
3304   512D             	; now get return code, if return code other than 0, it is finished
3305   512D             TCPIP_UDP_SEND_RC:
3306   512D DB 07       	in	a,(IN_STS_PORT)
3307   512F CB 47       	bit	0,a							; if nz has data
3308   5131 20 05       	jr	nz,TCPIP_UDP_SEND_RC.1
3309   5133 CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
3310   5136 18 F5       	jr	TCPIP_UDP_SEND_RC
3311   5138             TCPIP_UDP_SEND_RC.1:
3312   5138             	; nz, discard
3313   5138 DB 06       	in	a,(IN_DATA_PORT)
3314   513A B7          	or	a							; 0?
3315   513B C0          	ret	nz							; if not, done
3316   513C             
3317   513C             	; next two bytes are return code and size bytes, don't care, it is 0
3318   513C 06 02       	ld	b,2
3319   513E             TCPIP_UDP_SEND_ST2:
3320   513E DB 07       	in	a,(IN_STS_PORT)
3321   5140 CB 47       	bit	0,a							; if nz has data
3322   5142 20 05       	jr	nz,TCPIP_UDP_SEND_ST2.1
3323   5144 CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
3324   5147 18 F5       	jr	TCPIP_UDP_SEND_ST2
3325   5149             TCPIP_UDP_SEND_ST2.1:
3326   5149             	; nz, discard
3327   5149 DB 06       	in	a,(IN_DATA_PORT)
3328   514B 05          	dec	b
3329   514C 20 F0       	jr	nz,TCPIP_UDP_SEND_ST2
3330   514E             
3331   514E             	; done, no return data other than return code
3332   514E AF          	xor	a
3333   514F C9          	ret
3334   5150             
3335   5150             ;=======================
3336   5150             ;===  TCPIP_UDP_RCV  ===
3337   5150             ;=======================
3338   5150             ;Retrieve an incoming UDP datagram.
3339   5150             ;
3340   5150             ;Input:  A = 12
3341   5150             ;        B = Connection number
3342   5150             ;        HL = Address for datagram data
3343   5150             ;        DE = Maximum data size to retrieve
3344   5150             ;Output: A = Error code
3345   5150             ;        L.H.E.D = Source IP address
3346   5150             ;        IX = Source port
3347   5150             ;        BC = Actual received data size
3348   5150             
3349   5150             ; Customized TIME OUT routine: If time out receiving data, retry as received data
3350   5150             ; won't be re-sent as host is unaware of this
3351   5150             TCPIP_UDP_RCV_CHECK_TIME_OUT:
3352   5150             	; Save registers other than AF
3353   5150 C5          	push bc
3354   5151 D5          	push de
3355   5152 E5          	push hl
3356   5153 CD E5 57    	call	GETCOUNTER
3357   5156 7D          	ld	a,l
3358   5157 B4          	or	h
3359   5158             	; Restore registers, we are returning
3360   5158 E1          	pop	hl
3361   5159 D1          	pop	de
3362   515A C1          	pop	bc
3363   515B C0          	ret	nz
3364   515C             	; Ok, timeout...
3365   515C F1          	pop	af							; Get return address of who called this out of the stack, we will return from the function or re-start
3366   515D             TCPIP_TCP_UDP_RETRY_QRCV:
3367   515D CD 04 58    	call	GETBYTE
3368   5160 B7          	or	a
3369   5161 28 0B       	jr	z,TCPIP_UDP_RCV_CHECK_TIME_OUT.NORXRETRY
3370   5163             	; Ok, so let's ask ESP to re-send the data and retry receiving it
3371   5163 3D          	dec	a
3372   5164 CD 16 58    	call	SETBYTE					; we are retrying it
3373   5167 3E 72       	ld	a,'r'						; retry transmission command
3374   5169 D3 07       	out	(OUT_TX_PORT),a
3375   516B C3 8D 51    	jp	TCPIP_UDP_RCV.RXRETRY		; and retry it
3376   516E             TCPIP_UDP_RCV_CHECK_TIME_OUT.NORXRETRY:
3377   516E 3E 0F       	ld	a,ERR_INV_OPER
3378   5170 C9          	ret								; and return the function itself
3379   5171             
3380   5171             TCPIP_UDP_RCV:
3381   5171 CD 3D 58    	call	SETWORD					; Save for later the datagram address
3382   5174 3E 0C       	ld	a,12
3383   5176 D3 07       	out	(OUT_TX_PORT),a				; Send the command
3384   5178 AF          	xor	a
3385   5179 D3 07       	out	(OUT_TX_PORT),a				; Send the command size msb
3386   517B 3E 03       	ld	a,3
3387   517D D3 07       	out	(OUT_TX_PORT),a				; Send the command size lsb
3388   517F 78          	ld	a,b
3389   5180 D3 07       	out	(OUT_TX_PORT),a				; Send the connection #
3390   5182 7B          	ld	a,e
3391   5183 D3 07       	out	(OUT_TX_PORT),a				; Send MAX rcv size LSB
3392   5185 7A          	ld	a,d
3393   5186 D3 07       	out	(OUT_TX_PORT),a				; Send MAX rcv size MSB
3394   5188 3E 03       	ld	a,3
3395   518A CD 16 58    	call	SETBYTE					; Ok, retry up to three times
3396   518D             TCPIP_UDP_RCV.RXRETRY:
3397   518D             	; Now wait up to 600 ticks to get response
3398   518D 21 58 02    	ld	hl,600
3399   5190 CD F4 57    	call	SETCOUNTER
3400   5193             TCPIP_UDP_RCV_ST1:
3401   5193 DB 07       	in	a,(IN_STS_PORT)
3402   5195 CB 47       	bit	0,a							; if nz has data
3403   5197 20 05       	jr	nz,TCPIP_UDP_RCV_ST1.1
3404   5199 CD 50 51    	call	TCPIP_UDP_RCV_CHECK_TIME_OUT
3405   519C 18 F5       	jr	TCPIP_UDP_RCV_ST1
3406   519E             TCPIP_UDP_RCV_ST1.1:
3407   519E             	; nz, check the data
3408   519E DB 06       	in	a,(IN_DATA_PORT)
3409   51A0 FE 0C       	cp	12							; Is response of our command?
3410   51A2 20 EF       	jr	nz,TCPIP_UDP_RCV_ST1
3411   51A4             	; At this point, all data is being buffered, so 30 ticks, half second, is more than enough time-out
3412   51A4 F3          	di
3413   51A5 21 1E 00    	ld	hl,30
3414   51A8 CD F4 57    	call	SETCOUNTER
3415   51AB FB          	ei
3416   51AC             	; now get return code, if return code other than 0, it is finished
3417   51AC             TCPIP_UDP_RCV_RC:
3418   51AC DB 07       	in	a,(IN_STS_PORT)
3419   51AE CB 47       	bit	0,a							; if nz has data
3420   51B0 20 05       	jr	nz,TCPIP_UDP_RCV_RC.1
3421   51B2 CD 50 51    	call	TCPIP_UDP_RCV_CHECK_TIME_OUT
3422   51B5 18 F5       	jr	TCPIP_UDP_RCV_RC
3423   51B7             TCPIP_UDP_RCV_RC.1:
3424   51B7             	; nz, discard
3425   51B7 DB 06       	in	a,(IN_DATA_PORT)
3426   51B9 B7          	or	a							; 0?
3427   51BA C0          	ret	nz							; if not, done
3428   51BB             	; next two bytes are return code and size bytes, save it to BC
3429   51BB             TCPIP_UDP_RCV_ST2A:
3430   51BB DB 07       	in	a,(IN_STS_PORT)
3431   51BD CB 47       	bit	0,a							; if nz has data
3432   51BF 20 05       	jr	nz,TCPIP_UDP_RCV_ST2A.1
3433   51C1 CD 50 51    	call	TCPIP_UDP_RCV_CHECK_TIME_OUT
3434   51C4 18 F5       	jr	TCPIP_UDP_RCV_ST2A
3435   51C6             TCPIP_UDP_RCV_ST2A.1:
3436   51C6             	; nz, discard
3437   51C6 DB 06       	in	a,(IN_DATA_PORT)
3438   51C8 67          	ld	h,a
3439   51C9             TCPIP_UDP_RCV_ST2B:
3440   51C9 DB 07       	in	a,(IN_STS_PORT)
3441   51CB CB 47       	bit	0,a							; if nz has data
3442   51CD 20 05       	jr	nz,TCPIP_UDP_RCV_ST2B.1
3443   51CF CD 50 51    	call	TCPIP_UDP_RCV_CHECK_TIME_OUT
3444   51D2 18 F5       	jr	TCPIP_UDP_RCV_ST2B
3445   51D4             TCPIP_UDP_RCV_ST2B.1:
3446   51D4             	; nz, discard
3447   51D4 DB 06       	in	a,(IN_DATA_PORT)
3448   51D6 6F          	ld	l,a
3449   51D7 01 06 00    	ld	bc,6
3450   51DA             	; subtract 6 (IP and PORT)
3451   51DA AF          	xor	a							; zero carry
3452   51DB ED 42       	sbc	hl,bc
3453   51DD 4D          	ld	c,l
3454   51DE 44          	ld	b,h							; BC has effective received data size
3455   51DF             	; now just get the 4 bytes IP and place it in L H E D
3456   51DF             TCPIP_UDP_RCV_IP_ST1:
3457   51DF DB 07       	in	a,(IN_STS_PORT)
3458   51E1 CB 47       	bit	0,a							; if nz has data
3459   51E3 20 05       	jr	nz,TCPIP_UDP_RCV_IP_ST1.1
3460   51E5 CD 50 51    	call	TCPIP_UDP_RCV_CHECK_TIME_OUT
3461   51E8 18 F5       	jr	TCPIP_UDP_RCV_IP_ST1
3462   51EA             TCPIP_UDP_RCV_IP_ST1.1:
3463   51EA             	; nz, get it
3464   51EA DB 06       	in	a,(IN_DATA_PORT)
3465   51EC 6F          	ld	l,a
3466   51ED             TCPIP_UDP_RCV_IP_ST2:
3467   51ED DB 07       	in	a,(IN_STS_PORT)
3468   51EF CB 47       	bit	0,a							; if nz has data
3469   51F1 20 05       	jr	nz,TCPIP_UDP_RCV_IP_ST2.1
3470   51F3 CD 50 51    	call	TCPIP_UDP_RCV_CHECK_TIME_OUT
3471   51F6 18 F5       	jr	TCPIP_UDP_RCV_IP_ST2
3472   51F8             TCPIP_UDP_RCV_IP_ST2.1:
3473   51F8             	; nz, get it
3474   51F8 DB 06       	in	a,(IN_DATA_PORT)
3475   51FA 67          	ld	h,a
3476   51FB             TCPIP_UDP_RCV_IP_ST3:
3477   51FB DB 07       	in	a,(IN_STS_PORT)
3478   51FD CB 47       	bit	0,a							; if nz has data
3479   51FF 20 05       	jr	nz,TCPIP_UDP_RCV_IP_ST3.1
3480   5201 CD 50 51    	call	TCPIP_UDP_RCV_CHECK_TIME_OUT
3481   5204 18 F5       	jr	TCPIP_UDP_RCV_IP_ST3
3482   5206             TCPIP_UDP_RCV_IP_ST3.1:
3483   5206             	; nz, get it
3484   5206 DB 06       	in	a,(IN_DATA_PORT)
3485   5208 5F          	ld	e,a
3486   5209             TCPIP_UDP_RCV_IP_ST4:
3487   5209 DB 07       	in	a,(IN_STS_PORT)
3488   520B CB 47       	bit	0,a							; if nz has data
3489   520D 20 05       	jr	nz,TCPIP_UDP_RCV_IP_ST4.1
3490   520F CD 50 51    	call	TCPIP_UDP_RCV_CHECK_TIME_OUT
3491   5212 18 F5       	jr	TCPIP_UDP_RCV_IP_ST4
3492   5214             TCPIP_UDP_RCV_IP_ST4.1:
3493   5214             	; nz, get it
3494   5214 DB 06       	in	a,(IN_DATA_PORT)
3495   5216 57          	ld	d,a
3496   5217             	; now get the 2 bytes port and place in IXL and IXH
3497   5217             TCPIP_UDP_RCV_PORT_ST1:
3498   5217 DB 07       	in	a,(IN_STS_PORT)
3499   5219 CB 47       	bit	0,a							; if nz has data
3500   521B 20 05       	jr	nz,TCPIP_UDP_RCV_PORT_ST1.1
3501   521D CD 50 51    	call	TCPIP_UDP_RCV_CHECK_TIME_OUT
3502   5220 18 F5       	jr	TCPIP_UDP_RCV_PORT_ST1
3503   5222             TCPIP_UDP_RCV_PORT_ST1.1:
3504   5222             	; nz, get it
3505   5222 DB 06       	in	a,(IN_DATA_PORT)
3506   5224 DD 6F       	ld	ixl,a
3507   5226             TCPIP_UDP_RCV_PORT_ST2:
3508   5226 DB 07       	in	a,(IN_STS_PORT)
3509   5228 CB 47       	bit	0,a							; if nz has data
3510   522A 20 05       	jr	nz,TCPIP_UDP_RCV_PORT_ST2.1
3511   522C CD 50 51    	call	TCPIP_UDP_RCV_CHECK_TIME_OUT
3512   522F 18 F5       	jr	TCPIP_UDP_RCV_PORT_ST2
3513   5231             TCPIP_UDP_RCV_PORT_ST2.1:
3514   5231             	; nz, get it
3515   5231 DB 06       	in	a,(IN_DATA_PORT)
3516   5233 DD 67       	ld	ixh,a
3517   5235             
3518   5235             	; save the received data in memory
3519   5235 CD 69 58    	call	REGBACKUP				; Save the data received so far, registers will change
3520   5238             	; will start moving at RCV_ADDRESS that was stored in our WORD
3521   5238 CD 2A 58    	call	GETWORD
3522   523B             	; size goes to DE
3523   523B 50          	ld	d,b
3524   523C 59          	ld	e,c
3525   523D             	; Grauw Optimized 16 bit loop, handy for us, mostly since we can use ini :-D
3526   523D 43          	ld	b,e							; Number of loops originaly in DE
3527   523E 1B          	dec	de
3528   523F 14          	inc	d
3529   5240 0E 06       	ld	c,IN_DATA_PORT
3530   5242 DB 07       	in	a,(IN_STS_PORT)
3531   5244 CB 5F       	bit	3,a							; Quick Receive Supported?
3532   5246 28 11       	jr	z,TCPIP_UDP_RCV_R_NSF		; If not, go to the old, slower route
3533   5248             	; Otherwise, let's speed it up baby!
3534   5248             TCPIP_UDP_RCV_R:
3535   5248 ED B2       	inir
3536   524A 15          	dec	d
3537   524B 20 FB       	jr	nz,TCPIP_UDP_RCV_R
3538   524D DB 07       	in	a,(IN_STS_PORT)
3539   524F CB 67       	bit	4,a							; Buffer underrun?
3540   5251 C2 5D 51    	jp	nz,TCPIP_TCP_UDP_RETRY_QRCV	; If yes, retry
3541   5254             	; Otherwise, done
3542   5254             	; done, restore return data in DE BC and HL
3543   5254 CD 52 58    	call	REGRESTORE
3544   5257 AF          	xor	a
3545   5258 C9          	ret
3546   5259             	; Slower route if Interface doesn't implement quick receive
3547   5259             TCPIP_UDP_RCV_R_NSF:
3548   5259 DB 07       	in	a,(IN_STS_PORT)
3549   525B CB 47       	bit	0,a							; Do we have data to read?
3550   525D 20 05       	jr	nz,TCPIP_UDP_RCV_R_NSF.1
3551   525F CD 50 51    	call	TCPIP_UDP_RCV_CHECK_TIME_OUT
3552   5262 18 F5       	jr	TCPIP_UDP_RCV_R_NSF
3553   5264             TCPIP_UDP_RCV_R_NSF.1:
3554   5264 ED A2       	ini
3555   5266 20 F1       	jr	nz,TCPIP_UDP_RCV_R_NSF			; We do not use INIR because we don't know if there is more data, avoiding geting a junk 0xFF
3556   5268 15          	dec	d
3557   5269 20 EE       	jr	nz,TCPIP_UDP_RCV_R_NSF
3558   526B             	; done, restore return data in DE BC and HL
3559   526B CD 52 58    	call	REGRESTORE
3560   526E AF          	xor	a
3561   526F C9          	ret
3562   5270             
3563   5270             ;========================
3564   5270             ;===  TCPIP_TCP_OPEN  ===
3565   5270             ;========================
3566   5270             ;Open a TCP connection.
3567   5270             ;
3568   5270             ;Input:  A  = 13
3569   5270             ;        HL = Address of parameters block
3570   5270             ;Output: A = Error code
3571   5270             ;        B = Connection number
3572   5270             ;		 C = Connection not open reason (mostly for TLS)
3573   5270             ;
3574   5270             ;Parameters block format:
3575   5270             ;
3576   5270             ;+0 (4): Remote IP address (0.0.0.0 for unspecified remote socket)
3577   5270             ;+4 (2): Remote port (ignored if unspecified remote socket)
3578   5270             ;+6 (2): Local port, 0FFFFh for a random value
3579   5270             ;+8 (2): Suggestion for user timeout value
3580   5270             ;+10 (1): Flags:
3581   5270             ;         bit 0: Set for passive connection
3582   5270             ;         bit 1: Set for resident connection
3583   5270             ;         bit 2: Set for TLS connection
3584   5270             ;         bit 3: Set for TLS connection validating host certificate
3585   5270             ;+11 (2): If 0000 no host name validation, otherwise the hostname string address (zero terminated)
3586   5270             ;TCP_OPEN_IP1				(ix+0)
3587   5270             ;TCP_OPEN_IP2				(ix+1)
3588   5270             ;TCP_OPEN_IP3				(ix+2)
3589   5270             ;TCP_OPEN_IP4				(ix+3)
3590   5270             ;TCP_OPEN_RP				(ix+4)
3591   5270             ;TCP_OPEN_LP				(ix+6)
3592   5270             ;TCP_OPEN_TO				(ix+8)
3593   5270             ;TCP_OPEN_CMD_FLAGS			(ix+10)
3594   5270             ;TCP_OPEN_CMD_HOST_LSB		(ix+11)
3595   5270             ;TCP_OPEN_CMD_HOST_MSB		(ix+12)
3596   5270             
3597   5270             ; When no connection, let's get the reason and put in register C, as agreed
3598   5270             ; with Nestor this will be the way to go in the next UNAPI revision
3599   5270             TCPIP_TCP_OPEN_ERROR:
3600   5270             	; next two bytes are return code and size bytes, don't care, it is 1, conn close reason
3601   5270 47          	ld	b,a							; save error in b
3602   5271 0E 02       	ld	c,2
3603   5273             TCPIP_TCP_OPEN_ERROR2:
3604   5273 DB 07       	in	a,(IN_STS_PORT)
3605   5275 CB 47       	bit	0,a							; if nz has data
3606   5277 20 05       	jr	nz,TCPIP_TCP_OPEN_ERROR2.1
3607   5279 CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
3608   527C 18 F5       	jr	TCPIP_TCP_OPEN_ERROR2
3609   527E             TCPIP_TCP_OPEN_ERROR2.1:
3610   527E             	; nz, discard
3611   527E DB 06       	in	a,(IN_DATA_PORT)
3612   5280 0D          	dec	c
3613   5281 20 F0       	jr	nz,TCPIP_TCP_OPEN_ERROR2
3614   5283 78          	ld	a,b
3615   5284 FE 0B       	cp	ERR_NO_CONN
3616   5286 20 0E       	jr	nz,TCPIP_TCP_OPEN_ERROR4	; other errors do not have extra bytes as result
3617   5288             ; now just get the 1 byte, close reason, should go to C
3618   5288             TCPIP_TCP_OPEN_ERROR3:
3619   5288 DB 07       	in	a,(IN_STS_PORT)
3620   528A CB 47       	bit	0,a							; if nz has data
3621   528C 20 05       	jr	nz,TCPIP_TCP_OPEN_ERROR3.1
3622   528E CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
3623   5291 18 F5       	jr	TCPIP_TCP_OPEN_ERROR3
3624   5293             TCPIP_TCP_OPEN_ERROR3.1:
3625   5293             	; nz, get it
3626   5293 DB 06       	in	a,(IN_DATA_PORT)
3627   5295 4F          	ld	c,a
3628   5296             TCPIP_TCP_OPEN_ERROR4:
3629   5296             	; now return w/ error that is saved in b
3630   5296 78          	ld	a,b
3631   5297 06 00       	ld	b,0							; no connection, so 0
3632   5299 C9          	ret
3633   529A             
3634   529A             TCPIP_TCP_OPEN:
3635   529A E5          	push	hl						; save param block address
3636   529B 7C          	ld	a,h
3637   529C DD 67       	ld	ixh,a
3638   529E 7D          	ld	a,l
3639   529F DD 6F       	ld	ixl,a
3640   52A1             	; IX now has the parameters area
3641   52A1             	; most times it will be non tls, so this is the first test case
3642   52A1 21 0B 00    	ld	hl,11
3643   52A4 CD 3D 58    	call	SETWORD					; If it is non-TLS, send 11 bytes
3644   52A7 DD 7E 0A    	ld	a,(ix+10)					; TCP_OPEN_CMD_FLAGS
3645   52AA CB 57       	bit	2,a
3646   52AC 28 5A       	jr	z,TCPIP_TCP_OPEN_NO_TLS
3647   52AE             
3648   52AE             	; TLS, but, do we have host name?
3649   52AE 21 0C 00    	ld	hl,12
3650   52B1 CD 3D 58    	call	SETWORD					; If it is TLS without host name, send 12 bytes, one zero as host name suffice
3651   52B4 DD 6E 0B    	ld	l,(ix+11)					; TCP_OPEN_CMD_HOST_LSB
3652   52B7 DD 7E 0C    	ld	a,(ix+12)					; TCP_OPEN_CMD_HOST_MSB
3653   52BA B5          	or	l
3654   52BB             	; if TLS and next two bytes are 00 no host to check
3655   52BB 28 4B       	jr	z,TCPIP_TCP_OPEN_NO_CHECKHOST
3656   52BD             	; we are here, host to check
3657   52BD DD 66 0C    	ld	h,(ix+12)					; TCP_OPEN_CMD_HOST_MSB
3658   52C0 D1          	pop	de							; Retrieve parameters address
3659   52C1 E5          	push	hl						; Save host name address
3660   52C2 D5          	push	de						; Save Parameters address (so it is in the order we are going to need)
3661   52C3             	; let's check how many bytes there are
3662   52C3 11 0B 00    	ld	de,11						; Start with 11, all params except host name
3663   52C6             TCPIP_TCP_OPEN_CHECK_HOSTOF:
3664   52C6 7E          	ld	a,(hl)
3665   52C7 13          	inc	de							; Not zero, so increase size count
3666   52C8 23          	inc	hl							; And next hostname byte
3667   52C9 B7          	or	a							; If zero, hostname terminated
3668   52CA             	; Loop until terminator (0) is found
3669   52CA C2 C6 52    	jp	nz,TCPIP_TCP_OPEN_CHECK_HOSTOF
3670   52CD             
3671   52CD             TCPIP_TCP_OPEN_HOSTNAME_SENDCMDWITHHOSTNAME:
3672   52CD             	; Ok, so, DE has the full hostname size, let's start sending from here
3673   52CD 3E 0D       	ld	a,13						; Function TCP OPEN
3674   52CF D3 07       	out	(OUT_TX_PORT),a				; Send the command
3675   52D1 7A          	ld	a,d
3676   52D2 D3 07       	out	(OUT_TX_PORT),a				; Send the command size msb
3677   52D4 7B          	ld	a,e
3678   52D5 D3 07       	out	(OUT_TX_PORT),a				; Send the command size lsb
3679   52D7 E1          	pop	hl							; Restore the memory address for the parameters
3680   52D8             	; First send the 11 bytes parameters
3681   52D8 0E 07       	ld	c,OUT_TX_PORT
3682   52DA ED A3       	outi
3683   52DC ED A3       	outi
3684   52DE ED A3       	outi
3685   52E0 ED A3       	outi
3686   52E2 ED A3       	outi
3687   52E4 ED A3       	outi
3688   52E6 ED A3       	outi
3689   52E8 ED A3       	outi
3690   52EA ED A3       	outi
3691   52EC ED A3       	outi
3692   52EE ED A3       	outi							; Unrolled outi is a bit faster :)
3693   52F0 EB          	ex	de,hl						; Size in HL
3694   52F1 11 0B 00    	ld	de,11
3695   52F4 B7          	or	a							; zero flag
3696   52F5 ED 52       	sbc	hl,de
3697   52F7 EB          	ex de,hl						; and adjusted size back in de
3698   52F8 E1          	pop	hl							; Restore the memory address for hostname
3699   52F9             ; Grauw Optimized 16 bit loop, handy for us, mostly since we can use outi :-D
3700   52F9 43          	ld	b,e							; Number of loops originaly in DE
3701   52FA 1B          	dec	de
3702   52FB 14          	inc	d
3703   52FC 0E 07       	ld	c,OUT_TX_PORT
3704   52FE             TCPIP_TCP_OPEN_SENDHOSTNAME:
3705   52FE ED A3       	outi
3706   5300 20 FC       	jr	nz,TCPIP_TCP_OPEN_SENDHOSTNAME
3707   5302 15          	dec	d
3708   5303 20 F9       	jr	nz,TCPIP_TCP_OPEN_SENDHOSTNAME
3709   5305 C3 26 53    	jp	TCPIP_TCP_OPEN_WAIT_RESPONSE
3710   5308             
3711   5308             TCPIP_TCP_OPEN_NO_TLS:
3712   5308             TCPIP_TCP_OPEN_NO_CHECKHOST:
3713   5308 3E 0D       	ld	a,13						; Function TCP OPEN
3714   530A D3 07       	out	(OUT_TX_PORT),a				; Send the command
3715   530C CD 2A 58    	call	GETWORD
3716   530F 7C          	ld	a,h
3717   5310 57          	ld	d,a
3718   5311 D3 07       	out	(OUT_TX_PORT),a				; Send the command size msb
3719   5313 7D          	ld	a,l
3720   5314 5F          	ld	e,a
3721   5315 D3 07       	out	(OUT_TX_PORT),a				; Send the command size lsb
3722   5317             
3723   5317 0E 07       	ld	c,OUT_TX_PORT
3724   5319 E1          	pop	hl							; Restore the memory address for the parameters
3725   531A             ; Grauw Optimized 16 bit loop, handy for us, mostly since we can use outi :-D
3726   531A 43          	ld	b,e							; Number of loops originaly in DE
3727   531B 1B          	dec	de
3728   531C 14          	inc	d
3729   531D 0E 07       	ld	c,OUT_TX_PORT
3730   531F             TCPIP_TCP_OPEN_R:
3731   531F ED A3       	outi
3732   5321 20 FC       	jr	nz,TCPIP_TCP_OPEN_R
3733   5323 15          	dec	d
3734   5324 20 F9       	jr	nz,TCPIP_TCP_OPEN_R
3735   5326             
3736   5326             TCPIP_TCP_OPEN_WAIT_RESPONSE:
3737   5326             	; Now wait up to 3600 (1 minute @ 60Hz) ticks to get response
3738   5326             	; TLS Connections might take SEVERAL seconds on TLS Handshake
3739   5326             	; Even more if certificates database is being indexed
3740   5326 21 10 0E    	ld	hl,3600
3741   5329 CD F4 57    	call	SETCOUNTER
3742   532C             TCPIP_TCP_OPEN_ST1:
3743   532C DB 07       	in	a,(IN_STS_PORT)
3744   532E CB 47       	bit	0,a							; if nz has data
3745   5330 20 05       	jr	nz,TCPIP_TCP_OPEN_ST1.1
3746   5332 CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
3747   5335 18 F5       	jr	TCPIP_TCP_OPEN_ST1
3748   5337             TCPIP_TCP_OPEN_ST1.1:
3749   5337             	; nz, check the data
3750   5337 DB 06       	in	a,(IN_DATA_PORT)
3751   5339 FE 0D       	cp	13							; Is response of our command?
3752   533B 20 EF       	jr	nz,TCPIP_TCP_OPEN_ST1
3753   533D             	; now get return code, if return code other than 0, it is finished
3754   533D             TCPIP_TCP_OPEN_RC:
3755   533D DB 07       	in	a,(IN_STS_PORT)
3756   533F CB 47       	bit	0,a							; if nz has data
3757   5341 20 05       	jr	nz,TCPIP_TCP_OPEN_RC.1
3758   5343 CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
3759   5346 18 F5       	jr	TCPIP_TCP_OPEN_RC
3760   5348             TCPIP_TCP_OPEN_RC.1:
3761   5348             	; nz, discard
3762   5348 DB 06       	in	a,(IN_DATA_PORT)
3763   534A B7          	or	a							; 0?
3764   534B C2 70 52    	jp	nz,TCPIP_TCP_OPEN_ERROR
3765   534E             
3766   534E             	; next two bytes are size bytes, don't care, it is 1, conn #
3767   534E 06 02       	ld	b,2
3768   5350             TCPIP_TCP_OPEN_ST2:
3769   5350 DB 07       	in	a,(IN_STS_PORT)
3770   5352 CB 47       	bit	0,a							; if nz has data
3771   5354 20 05       	jr	nz,TCPIP_TCP_OPEN_ST2.1
3772   5356 CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
3773   5359 18 F5       	jr	TCPIP_TCP_OPEN_ST2
3774   535B             TCPIP_TCP_OPEN_ST2.1:
3775   535B             	; nz, discard
3776   535B DB 06       	in	a,(IN_DATA_PORT)
3777   535D 05          	dec	b
3778   535E 20 F0       	jr	nz,TCPIP_TCP_OPEN_ST2
3779   5360             
3780   5360             	; now just get the 1 byte, conn#, should go to B
3781   5360             TCPIP_TCP_OPEN_CONN_ST1:
3782   5360 DB 07       	in	a,(IN_STS_PORT)
3783   5362 CB 47       	bit	0,a							; if nz has data
3784   5364 20 05       	jr	nz,TCPIP_TCP_OPEN_CONN_ST1.1
3785   5366 CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
3786   5369 18 F5       	jr	TCPIP_TCP_OPEN_CONN_ST1
3787   536B             TCPIP_TCP_OPEN_CONN_ST1.1:
3788   536B             	; nz, get it
3789   536B DB 06       	in	a,(IN_DATA_PORT)
3790   536D 47          	ld	b,a
3791   536E             	; done
3792   536E AF          	xor	a
3793   536F C9          	ret
3794   5370             
3795   5370             ;=========================
3796   5370             ;===  TCPIP_TCP_CLOSE  ===
3797   5370             ;=========================
3798   5370             ;Close a TCP connection.
3799   5370             ;
3800   5370             ;Input:  A = 14
3801   5370             ;        B = Connection number
3802   5370             ;            0 to close all open transient UDP connections
3803   5370             ;Output: A = Error code
3804   5370             TCPIP_TCP_CLOSE:
3805   5370 D3 07       	out	(OUT_TX_PORT),a				; Send the command
3806   5372 AF          	xor	a
3807   5373 D3 07       	out	(OUT_TX_PORT),a				; Send the command size msb
3808   5375 3E 01       	ld	a,1
3809   5377 D3 07       	out	(OUT_TX_PORT),a				; Send the command size lsb
3810   5379 78          	ld	a,b
3811   537A D3 07       	out	(OUT_TX_PORT),a				; Send the connection #
3812   537C             	; Now wait up to 180 ticks to get response
3813   537C 21 B4 00    	ld	hl,180
3814   537F CD F4 57    	call	SETCOUNTER
3815   5382             TCPIP_TCP_CLOSE_ST1:
3816   5382 DB 07       	in	a,(IN_STS_PORT)
3817   5384 CB 47       	bit	0,a							; if nz has data
3818   5386 20 05       	jr	nz,TCPIP_TCP_CLOSE_ST1.1
3819   5388 CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
3820   538B 18 F5       	jr	TCPIP_TCP_CLOSE_ST1
3821   538D             TCPIP_TCP_CLOSE_ST1.1:
3822   538D             	; nz, check the data
3823   538D DB 06       	in	a,(IN_DATA_PORT)
3824   538F FE 0E       	cp	14							; Is response of our command?
3825   5391 20 EF       	jr	nz,TCPIP_TCP_CLOSE_ST1
3826   5393             	; now get return code, if return code other than 0, it is finished
3827   5393             TCPIP_TCP_CLOSE_RC:
3828   5393 DB 07       	in	a,(IN_STS_PORT)
3829   5395 CB 47       	bit	0,a							; if nz has data
3830   5397 20 05       	jr	nz,TCPIP_TCP_CLOSE_RC.1
3831   5399 CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
3832   539C 18 F5       	jr	TCPIP_TCP_CLOSE_RC
3833   539E             TCPIP_TCP_CLOSE_RC.1:
3834   539E             	; nz, discard
3835   539E DB 06       	in	a,(IN_DATA_PORT)
3836   53A0 B7          	or	a							; 0?
3837   53A1 C0          	ret	nz							; if not, done
3838   53A2             
3839   53A2             	; next two bytes are return code and size bytes, don't care, it is 0
3840   53A2 06 02       	ld	b,2
3841   53A4             TCPIP_TCP_CLOSE_ST2:
3842   53A4 DB 07       	in	a,(IN_STS_PORT)
3843   53A6 CB 47       	bit	0,a							; if nz has data
3844   53A8 20 05       	jr	nz,TCPIP_TCP_CLOSE_ST2.1
3845   53AA CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
3846   53AD 18 F5       	jr	TCPIP_TCP_CLOSE_ST2
3847   53AF             TCPIP_TCP_CLOSE_ST2.1:
3848   53AF             	; nz, discard
3849   53AF DB 06       	in	a,(IN_DATA_PORT)
3850   53B1 05          	dec	b
3851   53B2 20 F0       	jr	nz,TCPIP_TCP_CLOSE_ST2
3852   53B4             
3853   53B4             	; done, no return data other than return code
3854   53B4 AF          	xor a
3855   53B5 C9          	ret
3856   53B6             
3857   53B6             ;=========================
3858   53B6             ;===  TCPIP_TCP_ABORT  ===
3859   53B6             ;=========================
3860   53B6             ;Abort a TCP connection.
3861   53B6             ;Input:  A  = 15
3862   53B6             ;        B = Connection number
3863   53B6             ;            0 to abort all open transient TCP connections
3864   53B6             ;Output: A = Error code
3865   53B6             
3866   53B6             TCPIP_TCP_ABORT:
3867   53B6 D3 07       	out	(OUT_TX_PORT),a				; Send the command
3868   53B8 AF          	xor	a
3869   53B9 D3 07       	out	(OUT_TX_PORT),a				; Send the command size msb
3870   53BB 3E 01       	ld	a,1
3871   53BD D3 07       	out	(OUT_TX_PORT),a				; Send the command size lsb
3872   53BF 78          	ld	a,b
3873   53C0 D3 07       	out	(OUT_TX_PORT),a				; Send the connection #
3874   53C2             	; Now wait up to 180 ticks to get response
3875   53C2 21 B4 00    	ld	hl,180
3876   53C5 CD F4 57    	call	SETCOUNTER
3877   53C8             TCPIP_TCP_ABORT_ST1:
3878   53C8 DB 07       	in	a,(IN_STS_PORT)
3879   53CA CB 47       	bit	0,a							; if nz has data
3880   53CC 20 05       	jr	nz,TCPIP_TCP_ABORT_ST1.1
3881   53CE CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
3882   53D1 18 F5       	jr	TCPIP_TCP_ABORT_ST1
3883   53D3             TCPIP_TCP_ABORT_ST1.1:
3884   53D3             	; nz, check the data
3885   53D3 DB 06       	in	a,(IN_DATA_PORT)
3886   53D5 FE 0F       	cp	15							; Is response of our command?
3887   53D7 20 EF       	jr	nz,TCPIP_TCP_ABORT_ST1
3888   53D9             	; now get return code, if return code other than 0, it is finished
3889   53D9             TCPIP_TCP_ABORT_RC:
3890   53D9 DB 07       	in	a,(IN_STS_PORT)
3891   53DB CB 47       	bit	0,a							; if nz has data
3892   53DD 20 05       	jr	nz,TCPIP_TCP_ABORT_RC.1
3893   53DF CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
3894   53E2 18 F5       	jr	TCPIP_TCP_ABORT_RC
3895   53E4             TCPIP_TCP_ABORT_RC.1:
3896   53E4             	; nz, discard
3897   53E4 DB 06       	in	a,(IN_DATA_PORT)
3898   53E6 B7          	or	a							; 0?
3899   53E7 C0          	ret	nz							; if not, done
3900   53E8             
3901   53E8             	; next two bytes are return code and size bytes, don't care, it is 0
3902   53E8 06 02       	ld	b,2
3903   53EA             TCPIP_TCP_ABORT_ST2:
3904   53EA DB 07       	in	a,(IN_STS_PORT)
3905   53EC CB 47       	bit	0,a							; if nz has data
3906   53EE 20 05       	jr	nz,TCPIP_TCP_ABORT_ST2.1
3907   53F0 CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
3908   53F3 18 F5       	jr	TCPIP_TCP_ABORT_ST2
3909   53F5             TCPIP_TCP_ABORT_ST2.1:
3910   53F5             	; nz, discard
3911   53F5 DB 06       	in	a,(IN_DATA_PORT)
3912   53F7 05          	dec	b
3913   53F8 20 F0       	jr	nz,TCPIP_TCP_ABORT_ST2
3914   53FA             
3915   53FA             	; done, no return data other than return code
3916   53FA AF          	xor	a
3917   53FB C9          	ret
3918   53FC             
3919   53FC             ;=========================
3920   53FC             ;===  TCPIP_TCP_STATE  ===
3921   53FC             ;=========================
3922   53FC             ;Get the state of a TCP connection.
3923   53FC             ;
3924   53FC             ;Input:  A = 16
3925   53FC             ;        B = Connection number
3926   53FC             ;        HL = Pointer in TPA for connection information block
3927   53FC             ;             (0 if not needed)
3928   53FC             ;Output: A  = Error code
3929   53FC             ;        B  = Connection state
3930   53FC             ;        C  = Close reason (only if ERR_NO_CONN is returned)
3931   53FC             ;        HL = Number of total available incoming bytes
3932   53FC             ;        DE = Number of urgent available incoming bytes
3933   53FC             ;        IX = Available free space in the output buffer
3934   53FC             ;             (0FFFFh = infinite)
3935   53FC             ;
3936   53FC             ;Connection information block consists of:
3937   53FC             ;
3938   53FC             ;    +0 (4): Remote IP address
3939   53FC             ;    +4 (2): Remote port
3940   53FC             ;    +6 (2): Local port
3941   53FC             TCPIP_TCP_STATE_ERROR:
3942   53FC             	; next two bytes are size bytes, don't care
3943   53FC 47          	ld	b,a							; save error in b
3944   53FD 0E 02       	ld	c,2
3945   53FF             TCPIP_TCP_STATE_ERROR2:
3946   53FF DB 07       	in	a,(IN_STS_PORT)
3947   5401 CB 47       	bit	0,a							; if nz has data
3948   5403 20 05       	jr	nz,TCPIP_TCP_STATE_ERROR2.1
3949   5405 CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
3950   5408 18 F5       	jr	TCPIP_TCP_STATE_ERROR2
3951   540A             TCPIP_TCP_STATE_ERROR2.1:
3952   540A             	; nz, discard
3953   540A DB 06       	in	a,(IN_DATA_PORT)
3954   540C 0D          	dec	c
3955   540D 20 F0       	jr	nz,TCPIP_TCP_STATE_ERROR2
3956   540F             
3957   540F             	; now return w/ error that is saved in b
3958   540F 78          	ld	a,b
3959   5410 06 00       	ld	b,0
3960   5412 0E 07       	ld	c,7
3961   5414 21 00 00    	ld	hl,0
3962   5417 11 00 00    	ld	de,0
3963   541A DD 21 00 00 	ld	ix,0
3964   541E C9          	ret
3965   541F             
3966   541F             TCPIP_TCP_STATE:
3967   541F CD 3D 58    	call	SETWORD					; Save HL pointer in our memory
3968   5422 7C          	ld	a,h
3969   5423 B5          	or	l							; Information block required?
3970   5424 3E 00       	ld	a,0							; do not want to mess with flags, let's say no need
3971   5426 28 01       	jr	z,TCPIP_TCP_STATE_NOINFOBLOCK
3972   5428 3C          	inc	a							; otherwise there is a need
3973   5429             TCPIP_TCP_STATE_NOINFOBLOCK:
3974   5429 CD 16 58    	call	SETBYTE					; Save for later
3975   542C 3E 10       	ld	a,16						; Our command
3976   542E D3 07       	out	(OUT_TX_PORT),a				; Send the command
3977   5430 AF          	xor	a
3978   5431 D3 07       	out	(OUT_TX_PORT),a				; Send the command size msb
3979   5433 3C          	inc	a
3980   5434 D3 07       	out	(OUT_TX_PORT),a				; Send the command size lsb
3981   5436 78          	ld	a,b
3982   5437 D3 07       	out	(OUT_TX_PORT),a				; Send the parameter
3983   5439             
3984   5439             	; Now wait up to 180 ticks to get response
3985   5439 21 B4 00    	ld	hl,180
3986   543C CD F4 57    	call	SETCOUNTER
3987   543F             TCPIP_TCP_STATE_ST1:
3988   543F DB 07       	in	a,(IN_STS_PORT)
3989   5441 CB 47       	bit	0,a							; if nz has data
3990   5443 20 05       	jr	nz,TCPIP_TCP_STATE_ST1.1
3991   5445 CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
3992   5448 18 F5       	jr	TCPIP_TCP_STATE_ST1
3993   544A             TCPIP_TCP_STATE_ST1.1:
3994   544A             	; nz, check the data
3995   544A DB 06       	in	a,(IN_DATA_PORT)
3996   544C FE 10       	cp	16							; Is response of our command?
3997   544E 20 EF       	jr	nz,TCPIP_TCP_STATE_ST1
3998   5450             	; now get return code, if return code other than 0, it is finished
3999   5450             TCPIP_TCP_STATE_RC:
4000   5450 DB 07       	in	a,(IN_STS_PORT)
4001   5452 CB 47       	bit	0,a							; if nz has data
4002   5454 20 05       	jr	nz,TCPIP_TCP_STATE_RC.1
4003   5456 CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
4004   5459 18 F5       	jr	TCPIP_TCP_STATE_RC
4005   545B             TCPIP_TCP_STATE_RC.1:
4006   545B             	; nz, discard
4007   545B DB 06       	in	a,(IN_DATA_PORT)
4008   545D B7          	or	a							; 0?
4009   545E 20 9C       	jr	nz,TCPIP_TCP_STATE_ERROR	; if not, done
4010   5460             
4011   5460             	; next two bytes are return code and size bytes, don't care, it is 16
4012   5460 06 02       	ld	b,2
4013   5462             TCPIP_TCP_STATE_ST2:
4014   5462 DB 07       	in	a,(IN_STS_PORT)
4015   5464 CB 47       	bit	0,a							; if nz has data
4016   5466 20 05       	jr	nz,TCPIP_TCP_STATE_ST2.1
4017   5468 CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
4018   546B 18 F5       	jr	TCPIP_TCP_STATE_ST2
4019   546D             TCPIP_TCP_STATE_ST2.1:
4020   546D             	; nz, discard
4021   546D DB 06       	in	a,(IN_DATA_PORT)
4022   546F 05          	dec	b
4023   5470 20 F0       	jr	nz,TCPIP_TCP_STATE_ST2
4024   5472             
4025   5472             	; now just get the 16 bytes (Port LSB then MSB, # of packets, packet size LSB then MSB) and order it in C, B, L, H, E, D, IXL and IXH.
4026   5472             	; Remaining 8 bytes go to TCP_STATE_INFORMATION_BLOCK if its value is other than 0
4027   5472             TCPIP_TCP_STATE_RESP_ST1:
4028   5472 DB 07       	in	a,(IN_STS_PORT)
4029   5474 CB 47       	bit	0,a							; if nz has data
4030   5476 20 05       	jr	nz,TCPIP_TCP_STATE_RESP_ST1.1
4031   5478 CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
4032   547B 18 F5       	jr	TCPIP_TCP_STATE_RESP_ST1
4033   547D             TCPIP_TCP_STATE_RESP_ST1.1:
4034   547D             	; nz, get it
4035   547D DB 06       	in	a,(IN_DATA_PORT)
4036   547F 4F          	ld	c,a
4037   5480             TCPIP_TCP_STATE_RESP_ST2:
4038   5480 DB 07       	in	a,(IN_STS_PORT)
4039   5482 CB 47       	bit	0,a							; if nz has data
4040   5484 20 05       	jr	nz,TCPIP_TCP_STATE_RESP_ST2.1
4041   5486 CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
4042   5489 18 F5       	jr	TCPIP_TCP_STATE_RESP_ST2
4043   548B             TCPIP_TCP_STATE_RESP_ST2.1:
4044   548B             	; nz, get it
4045   548B DB 06       	in	a,(IN_DATA_PORT)
4046   548D 47          	ld	b,a
4047   548E             TCPIP_TCP_STATE_RESP_ST3:
4048   548E DB 07       	in	a,(IN_STS_PORT)
4049   5490 CB 47       	bit	0,a							; if nz has data
4050   5492 20 05       	jr	nz,TCPIP_TCP_STATE_RESP_ST3.1
4051   5494 CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
4052   5497 18 F5       	jr	TCPIP_TCP_STATE_RESP_ST3
4053   5499             TCPIP_TCP_STATE_RESP_ST3.1:
4054   5499             	; nz, get it
4055   5499 DB 06       	in	a,(IN_DATA_PORT)
4056   549B 6F          	ld	l,a
4057   549C             TCPIP_TCP_STATE_RESP_ST4:
4058   549C DB 07       	in	a,(IN_STS_PORT)
4059   549E CB 47       	bit	0,a							; if nz has data
4060   54A0 20 05       	jr	nz,TCPIP_TCP_STATE_RESP_ST4.1
4061   54A2 CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
4062   54A5 18 F5       	jr	TCPIP_TCP_STATE_RESP_ST4
4063   54A7             TCPIP_TCP_STATE_RESP_ST4.1:
4064   54A7             	; nz, get it
4065   54A7 DB 06       	in	a,(IN_DATA_PORT)
4066   54A9 67          	ld	h,a
4067   54AA             TCPIP_TCP_STATE_RESP_ST5:
4068   54AA DB 07       	in	a,(IN_STS_PORT)
4069   54AC CB 47       	bit	0,a							; if nz has data
4070   54AE 20 05       	jr	nz,TCPIP_TCP_STATE_RESP_ST5.1
4071   54B0 CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
4072   54B3 18 F5       	jr	TCPIP_TCP_STATE_RESP_ST5
4073   54B5             TCPIP_TCP_STATE_RESP_ST5.1:
4074   54B5             	; nz, get it
4075   54B5 DB 06       	in	a,(IN_DATA_PORT)
4076   54B7 5F          	ld	e,a
4077   54B8             TCPIP_TCP_STATE_RESP_ST6:
4078   54B8 DB 07       	in	a,(IN_STS_PORT)
4079   54BA CB 47       	bit	0,a							; if nz has data
4080   54BC 20 05       	jr	nz,TCPIP_TCP_STATE_RESP_ST6.1
4081   54BE CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
4082   54C1 18 F5       	jr	TCPIP_TCP_STATE_RESP_ST6
4083   54C3             TCPIP_TCP_STATE_RESP_ST6.1:
4084   54C3             	; nz, get it
4085   54C3 DB 06       	in	a,(IN_DATA_PORT)
4086   54C5 57          	ld	d,a
4087   54C6             TCPIP_TCP_STATE_RESP_ST7:
4088   54C6 DB 07       	in	a,(IN_STS_PORT)
4089   54C8 CB 47       	bit	0,a							; if nz has data
4090   54CA 20 05       	jr	nz,TCPIP_TCP_STATE_RESP_ST7.1
4091   54CC CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
4092   54CF 18 F5       	jr	TCPIP_TCP_STATE_RESP_ST7
4093   54D1             TCPIP_TCP_STATE_RESP_ST7.1:
4094   54D1             	; nz, get it
4095   54D1 DB 06       	in	a,(IN_DATA_PORT)
4096   54D3 DD 6F       	ld	ixl,a
4097   54D5             TCPIP_TCP_STATE_RESP_ST8:
4098   54D5 DB 07       	in	a,(IN_STS_PORT)
4099   54D7 CB 47       	bit	0,a							; if nz has data
4100   54D9 20 05       	jr	nz,TCPIP_TCP_STATE_RESP_ST8.1
4101   54DB CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
4102   54DE 18 F5       	jr	TCPIP_TCP_STATE_RESP_ST8
4103   54E0             TCPIP_TCP_STATE_RESP_ST8.1:
4104   54E0             	; nz, get it
4105   54E0 DB 06       	in	a,(IN_DATA_PORT)
4106   54E2 DD 67       	ld	ixh,a
4107   54E4             
4108   54E4             ; Check if there is an information block
4109   54E4 CD 9D 58    	call	BCBACKUP				; Save BC, we gonna use it
4110   54E7 06 08       	ld	b,8							; prepare in advance for 8 bytes being transferred
4111   54E9 CD 04 58    	call	GETBYTE					; Let's check if we have flagged need for INFOBLOCK
4112   54EC B7          	or	a
4113   54ED 20 15       	jr	nz,TCPIP_TCP_STATE_GET_IBLOCK
4114   54EF             
4115   54EF             ; If here, just discard Information Block (next 8 bytes)
4116   54EF             TCPIP_TCP_STATE_DISCARD_IBLOCK:
4117   54EF DB 07       	in	a,(IN_STS_PORT)
4118   54F1 CB 47       	bit	0,a							; if nz has data
4119   54F3 20 05       	jr	nz,TCPIP_TCP_STATE_DISCARD_IBLOCK.1
4120   54F5 CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
4121   54F8 18 F5       	jr	TCPIP_TCP_STATE_DISCARD_IBLOCK
4122   54FA             TCPIP_TCP_STATE_DISCARD_IBLOCK.1:
4123   54FA             	; nz, discard
4124   54FA DB 06       	in	a,(IN_DATA_PORT)
4125   54FC 05          	dec	b
4126   54FD 20 F0       	jr	nz,TCPIP_TCP_STATE_DISCARD_IBLOCK
4127   54FF             	; done
4128   54FF CD 8B 58    	call	BCRESTORE
4129   5502 AF          	xor	a
4130   5503 C9          	ret
4131   5504             
4132   5504             ; If here, save Information Block (next 8 bytes)
4133   5504             TCPIP_TCP_STATE_GET_IBLOCK:
4134   5504 CD C4 58    	call	HLBACKUP				; Save HL
4135   5507 CD 2A 58    	call	GETWORD					; Restore address for IB on HL
4136   550A             TCPIP_TCP_STATE_SAVE_IBLOCK:
4137   550A DB 07       	in	a,(IN_STS_PORT)
4138   550C CB 47       	bit	0,a							; if nz has data
4139   550E 20 05       	jr	nz,TCPIP_TCP_STATE_SAVE_IBLOCK.1
4140   5510 CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
4141   5513 18 F5       	jr	TCPIP_TCP_STATE_SAVE_IBLOCK
4142   5515             TCPIP_TCP_STATE_SAVE_IBLOCK.1:
4143   5515             	; nz, save
4144   5515 DB 06       	in	a,(IN_DATA_PORT)
4145   5517 77          	ld	(hl),a
4146   5518 23          	inc	hl
4147   5519 05          	dec	b
4148   551A 20 EE       	jr	nz,TCPIP_TCP_STATE_SAVE_IBLOCK
4149   551C             	; done
4150   551C CD B1 58    	call	HLRESTORE
4151   551F CD 8B 58    	call	BCRESTORE
4152   5522 AF          	xor	a
4153   5523 C9          	ret
4154   5524             
4155   5524             ;========================
4156   5524             ;===  TCPIP_TCP_SEND  ===
4157   5524             ;========================
4158   5524             ;Send data to a TCP connection.
4159   5524             ;
4160   5524             ;Input:  A  = 17
4161   5524             ;        B  = Connection number
4162   5524             ;        DE = Address of the data to be sent
4163   5524             ;        HL = Length of the data to be sent
4164   5524             ;        C  = Flags:
4165   5524             ;             bit 0: Send the data PUSHed
4166   5524             ;             bit 1: The data is urgent
4167   5524             ;Output: A = Error code
4168   5524             TCPIP_TCP_SEND_ERROR:
4169   5524             	; next two bytes are size bytes, don't care
4170   5524 47          	ld	b,a							; save error in b
4171   5525 0E 02       	ld	c,2
4172   5527             TCPIP_TCP_SEND_ERROR2:
4173   5527 DB 07       	in	a,(IN_STS_PORT)
4174   5529 CB 47       	bit	0,a							; if nz has data
4175   552B 20 05       	jr	nz,TCPIP_TCP_SEND_ERROR2.1
4176   552D CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
4177   5530 18 F5       	jr	TCPIP_TCP_SEND_ERROR2
4178   5532             TCPIP_TCP_SEND_ERROR2.1:
4179   5532             	; nz, discard
4180   5532 DB 06       	in	a,(IN_DATA_PORT)
4181   5534 0D          	dec	c
4182   5535 20 F0       	jr	nz,TCPIP_TCP_SEND_ERROR2
4183   5537             	; now return w/ error that is saved in b
4184   5537 78          	ld	a,b
4185   5538 C9          	ret
4186   5539             
4187   5539             TCPIP_TCP_SEND:
4188   5539 E5          	push	hl
4189   553A D5          	push	de
4190   553B D3 07       	out	(OUT_TX_PORT),a				; Send the command
4191   553D             	; prepare new data size, adding our 2 bytes overhead
4192   553D 11 02 00    	ld	de,2
4193   5540 19          	add	hl,de
4194   5541 7C          	ld	a,h
4195   5542 D3 07       	out	(OUT_TX_PORT),a				; Send the command size msb
4196   5544 7D          	ld	a,l
4197   5545 D3 07       	out	(OUT_TX_PORT),a				; Send the command size lsb
4198   5547 78          	ld	a,b
4199   5548 D3 07       	out	(OUT_TX_PORT),a				; Send the connection #
4200   554A 79          	ld	a,c
4201   554B D3 07       	out	(OUT_TX_PORT),a				; Send the connection flags
4202   554D E1          	pop	hl
4203   554E D1          	pop	de
4204   554F             	; now oti the data starting at hl, size is in DE
4205   554F             	; Grauw Optimized 16 bit loop, handy for us, mostly since we can use outi :-D
4206   554F 43          	ld	b,e							;Number of loops originaly in DE
4207   5550 1B          	dec	de
4208   5551 14          	inc	d
4209   5552 0E 07       	ld	c,OUT_TX_PORT
4210   5554             TCPIP_TCP_SEND_R:
4211   5554 ED A3       	outi
4212   5556 20 FC       	jr	nz,TCPIP_TCP_SEND_R
4213   5558 15          	dec	d
4214   5559 20 F9       	jr	nz,TCPIP_TCP_SEND_R
4215   555B             
4216   555B             	; Now wait up to 600 ticks to get response
4217   555B 21 58 02    	ld	hl,600
4218   555E CD F4 57    	call	SETCOUNTER
4219   5561             TCPIP_TCP_SEND_ST1:
4220   5561 DB 07       	in	a,(IN_STS_PORT)
4221   5563 CB 47       	bit	0,a							; if nz has data
4222   5565 20 05       	jr	nz,TCPIP_TCP_SEND_R.1
4223   5567 CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
4224   556A 18 F5       	jr	TCPIP_TCP_SEND_ST1
4225   556C             TCPIP_TCP_SEND_R.1:
4226   556C             	; nz, check the data
4227   556C DB 06       	in	a,(IN_DATA_PORT)
4228   556E FE 11       	cp	17							; Is response of our command?
4229   5570 20 EF       	jr	nz,TCPIP_TCP_SEND_ST1
4230   5572             	; now get return code, if return code other than 0, it is finished
4231   5572             TCPIP_TCP_SEND_RC:
4232   5572 DB 07       	in	a,(IN_STS_PORT)
4233   5574 CB 47       	bit	0,a							; if nz has data
4234   5576 20 05       	jr	nz,TCPIP_TCP_SEND_RC.1
4235   5578 CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
4236   557B 18 F5       	jr	TCPIP_TCP_SEND_RC
4237   557D             TCPIP_TCP_SEND_RC.1:
4238   557D             	; nz, discard
4239   557D DB 06       	in	a,(IN_DATA_PORT)
4240   557F B7          	or	a							; 0?
4241   5580 C0          	ret	nz							; if not, done
4242   5581             
4243   5581             	; next two bytes are return code and size bytes, don't care, it is 0
4244   5581 06 02       	ld	b,2
4245   5583             TCPIP_TCP_SEND_ST2:
4246   5583 DB 07       	in	a,(IN_STS_PORT)
4247   5585 CB 47       	bit	0,a							; if nz has data
4248   5587 20 05       	jr	nz,TCPIP_TCP_SEND_ST2.1
4249   5589 CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
4250   558C 18 F5       	jr	TCPIP_TCP_SEND_ST2
4251   558E             TCPIP_TCP_SEND_ST2.1:
4252   558E             	; nz, discard
4253   558E DB 06       	in	a,(IN_DATA_PORT)
4254   5590 05          	dec	b
4255   5591 20 F0       	jr	nz,TCPIP_TCP_SEND_ST2
4256   5593             
4257   5593             	; done, no return data other than return code
4258   5593 AF          	xor	a
4259   5594 C9          	ret
4260   5595             
4261   5595             ;=======================
4262   5595             ;===  TCPIP_TCP_RCV  ===
4263   5595             ;=======================
4264   5595             ;Receive data from a TCP connection.
4265   5595             ;
4266   5595             ;Input:   A  = 18
4267   5595             ;         B  = Connection number
4268   5595             ;         DE = Address for the retrieved data
4269   5595             ;         HL = Length of the data to be obtained
4270   5595             ;Output:  A  = Error code
4271   5595             ;         BC = Total number of bytes that have been actually retrieved
4272   5595             ;         HL = Number of urgent data bytes that have been retrieved
4273   5595             ;              (placed at the beginning of the received data block)
4274   5595             ; Save registers other than AF
4275   5595             TCPIP_TCP_RCV_CHECK_TIME_OUT:
4276   5595 C5          	push bc
4277   5596 D5          	push de
4278   5597 E5          	push hl
4279   5598 CD E5 57    	call	GETCOUNTER
4280   559B 7D          	ld	a,l
4281   559C B4          	or	h
4282   559D             	; Restore registers, we are returning
4283   559D E1          	pop	hl
4284   559E D1          	pop	de
4285   559F C1          	pop	bc
4286   55A0 C0          	ret	nz
4287   55A1             	; Ok, timeout...
4288   55A1 F1          	pop	af							; Get return address of who called this out of the stack, we will return from the function or re-start
4289   55A2             TCPIP_TCP_RCV_RETRY_QRCV:
4290   55A2 CD 04 58    	call	GETBYTE
4291   55A5 B7          	or	a
4292   55A6 28 0B       	jr	z,TCPIP_TCP_RCV_CHECK_TIME_OUT.NORXRETRY
4293   55A8             	; Ok, so let's ask ESP to re-send the data and retry receiving it
4294   55A8 3D          	dec	a
4295   55A9 CD 16 58    	call	SETBYTE					; we are retrying it
4296   55AC 3E 72       	ld	a,'r'						; retry transmission command
4297   55AE D3 07       	out	(OUT_TX_PORT),a
4298   55B0 C3 EF 55    	jp	TCPIP_TCP_RCV.RXRETRY		; and retry it
4299   55B3             TCPIP_TCP_RCV_CHECK_TIME_OUT.NORXRETRY:
4300   55B3 3E 0F       	ld	a,ERR_INV_OPER
4301   55B5 C9          	ret								; and return the function itself
4302   55B6             
4303   55B6             TCPIP_TCP_RCV_RET_ERR:
4304   55B6             	; next two bytes are size bytes, don't care
4305   55B6 47          	ld	b,a							; save error in b
4306   55B7 0E 02       	ld	c,2
4307   55B9             TCPIP_TCP_RCV_RET_ERR2:
4308   55B9 DB 07       	in	a,(IN_STS_PORT)
4309   55BB CB 47       	bit	0,a							; if nz has data
4310   55BD 20 05       	jr	nz,TCPIP_TCP_RCV_RET_ERR2.1
4311   55BF CD 95 55    	call	TCPIP_TCP_RCV_CHECK_TIME_OUT
4312   55C2 18 F5       	jr	TCPIP_TCP_RCV_RET_ERR2
4313   55C4             TCPIP_TCP_RCV_RET_ERR2.1:
4314   55C4             	; nz, discard
4315   55C4 DB 06       	in	a,(IN_DATA_PORT)
4316   55C6 0D          	dec	c
4317   55C7 20 F0       	jr	nz,TCPIP_TCP_RCV_RET_ERR2
4318   55C9             	; now return w/ error that is saved in b
4319   55C9 78          	ld	a,b
4320   55CA             TCPIP_TCP_RCV_RET_NODATA:
4321   55CA 21 00 00    	ld	hl,0
4322   55CD 01 00 00    	ld	bc,0
4323   55D0 C9          	ret
4324   55D1             
4325   55D1             TCPIP_TCP_RCV:
4326   55D1 EB          	ex	de,hl
4327   55D2 CD 3D 58    	call	SETWORD
4328   55D5 EB          	ex	de,hl
4329   55D6 3E 12       	ld	a,18
4330   55D8 D3 07       	out	(OUT_TX_PORT),a				; Send the command
4331   55DA AF          	xor	a
4332   55DB D3 07       	out	(OUT_TX_PORT),a				; Send the command size msb
4333   55DD 3E 03       	ld	a,3
4334   55DF D3 07       	out	(OUT_TX_PORT),a				; Send the command size lsb
4335   55E1 78          	ld	a,b
4336   55E2 D3 07       	out	(OUT_TX_PORT),a				; Send the connection #
4337   55E4 7D          	ld	a,l
4338   55E5 D3 07       	out	(OUT_TX_PORT),a				; Send MAX rcv size LSB
4339   55E7 7C          	ld	a,h
4340   55E8 D3 07       	out	(OUT_TX_PORT),a				; Send MAX rcv size MSB
4341   55EA 3E 03       	ld	a,3
4342   55EC CD 16 58    	call	SETBYTE					; Ok, retry up to three times
4343   55EF             TCPIP_TCP_RCV.RXRETRY:
4344   55EF             	; Now wait up to 600 ticks to get response
4345   55EF 21 58 02    	ld	hl,600
4346   55F2 CD F4 57    	call	SETCOUNTER
4347   55F5             TCPIP_TCP_RCV_ST1:
4348   55F5 DB 07       	in	a,(IN_STS_PORT)
4349   55F7 CB 47       	bit	0,a							; if nz has data
4350   55F9 20 05       	jr	nz,TCPIP_TCP_RCV_ST1.1
4351   55FB CD 95 55    	call	TCPIP_TCP_RCV_CHECK_TIME_OUT
4352   55FE 18 F5       	jr	TCPIP_TCP_RCV_ST1
4353   5600             TCPIP_TCP_RCV_ST1.1:
4354   5600             	; nz, check the data
4355   5600 DB 06       	in	a,(IN_DATA_PORT)
4356   5602 FE 12       	cp 18							; Is response of our command?
4357   5604 20 EF       	jr	nz,TCPIP_TCP_RCV_ST1
4358   5606             	; At this point, all data is being buffered, so 15 ticks, quarter second, is more than enough time-out
4359   5606 F3          	di
4360   5607 21 1E 00    	ld	hl,30
4361   560A CD F4 57    	call	SETCOUNTER
4362   560D FB          	ei
4363   560E             	; now get return code, if return code other than 0, it is finished
4364   560E             TCPIP_TCP_RCV_RC:
4365   560E DB 07       	in	a,(IN_STS_PORT)
4366   5610 CB 47       	bit	0,a							; if nz has data
4367   5612 20 05       	jr	nz,TCPIP_TCP_RCV_RC.1
4368   5614 CD 95 55    	call	TCPIP_TCP_RCV_CHECK_TIME_OUT
4369   5617 18 F5       	jr	TCPIP_TCP_RCV_RC
4370   5619             TCPIP_TCP_RCV_RC.1:
4371   5619             	; nz, discard
4372   5619 DB 06       	in	a,(IN_DATA_PORT)
4373   561B B7          	or	a							; 0?
4374   561C 20 98       	jr	nz,TCPIP_TCP_RCV_RET_ERR	; if not, done
4375   561E             	; next two bytes are response size bytes (UB count two bytes, always 0, and data read), save it -2 to BC
4376   561E             TCPIP_TCP_RCV_ST2A:
4377   561E DB 07       	in	a,(IN_STS_PORT)
4378   5620 CB 47       	bit	0,a							; if nz has data
4379   5622 20 05       	jr	nz,TCPIP_TCP_RCV_ST2A.1
4380   5624 CD 95 55    	call	TCPIP_TCP_RCV_CHECK_TIME_OUT
4381   5627 18 F5       	jr	TCPIP_TCP_RCV_ST2A
4382   5629             TCPIP_TCP_RCV_ST2A.1:
4383   5629             	; nz, high byte count of bytes to receive
4384   5629 DB 06       	in	a,(IN_DATA_PORT)
4385   562B 67          	ld h,a
4386   562C             TCPIP_TCP_RCV_ST2B:
4387   562C DB 07       	in	a,(IN_STS_PORT)
4388   562E CB 47       	bit	0,a							; if nz has data
4389   5630 20 05       	jr	nz,TCPIP_TCP_RCV_ST2B.1
4390   5632 CD 95 55    	call	TCPIP_TCP_RCV_CHECK_TIME_OUT
4391   5635 18 F5       	jr	TCPIP_TCP_RCV_ST2B
4392   5637             TCPIP_TCP_RCV_ST2B.1:
4393   5637             	; nz, low byte count of bytes to receive
4394   5637 DB 06       	in	a,(IN_DATA_PORT)
4395   5639 6F          	ld	l,a
4396   563A 01 02 00    	ld	bc,2
4397   563D             	; subtract 2 (Urgent data count, not used)
4398   563D AF          	xor	a							; zero carry
4399   563E ED 42       	sbc	hl,bc
4400   5640             	; if it was 0, will carry
4401   5640 38 88       	jr	c,TCPIP_TCP_RCV_RET_NODATA
4402   5642 4D          	ld	c,l
4403   5643 44          	ld	b,h							; BC has effective received data size, as well as HL
4404   5644             
4405   5644             	; now just discard 2 bytes urgent data
4406   5644             TCPIP_TCP_RCV_UDC_ST1:
4407   5644 DB 07       	in	a,(IN_STS_PORT)
4408   5646 CB 47       	bit	0,a							; if nz has data
4409   5648 20 05       	jr	nz,TCPIP_TCP_RCV_UDC_ST1.1
4410   564A CD 95 55    	call	TCPIP_TCP_RCV_CHECK_TIME_OUT
4411   564D 18 F5       	jr	TCPIP_TCP_RCV_UDC_ST1
4412   564F             TCPIP_TCP_RCV_UDC_ST1.1:
4413   564F             	; nz, get it
4414   564F DB 06       	in	a,(IN_DATA_PORT)
4415   5651             TCPIP_TCP_RCV_UDC_ST2:
4416   5651 DB 07       	in	a,(IN_STS_PORT)
4417   5653 CB 47       	bit	0,a							; if nz has data
4418   5655 20 05       	jr	nz,TCPIP_TCP_RCV_UDC_ST2.1
4419   5657 CD 95 55    	call	TCPIP_TCP_RCV_CHECK_TIME_OUT
4420   565A 18 F5       	jr	TCPIP_TCP_RCV_UDC_ST2
4421   565C             TCPIP_TCP_RCV_UDC_ST2.1
4422   565C             	; nz, get it
4423   565C DB 06       	in	a,(IN_DATA_PORT)
4424   565E             
4425   565E             	; put effective data size in de
4426   565E EB          	ex	de,hl
4427   565F             	; will start moving at address in stack (we've pushed the adress in WORD)
4428   565F CD 2A 58    	call	GETWORD
4429   5662 CD 9D 58    	call	BCBACKUP				; save count (BC)
4430   5665             
4431   5665             	; Grauw Optimized 16 bit loop, handy for us, mostly since we can use ini :-D
4432   5665 43          	ld	b,e							; Number of loops originaly in DE
4433   5666 1B          	dec	de
4434   5667 14          	inc	d
4435   5668 0E 06       	ld	c,IN_DATA_PORT
4436   566A DB 07       	in	a,(IN_STS_PORT)
4437   566C CB 5F       	bit	3,a							; Quick Receive Supported?
4438   566E 28 14       	jr	z,TCPIP_TCP_RCV_R_NSF		; If not, go to the old, slower route
4439   5670             	; Otherwise, let's speed it up baby!
4440   5670             TCPIP_TCP_RCV_R:
4441   5670 ED B2       	inir
4442   5672 15          	dec	d
4443   5673 20 FB       	jr nz,TCPIP_TCP_RCV_R
4444   5675 DB 07       	in	a,(IN_STS_PORT)
4445   5677 CB 67       	bit	4,a							; Buffer underrun?
4446   5679 C2 A2 55    	jp	nz,TCPIP_TCP_RCV_RETRY_QRCV	; If yes, retry
4447   567C             	; Otherwise, done
4448   567C CD 8B 58    	call	BCRESTORE				; done, restore return data in BC
4449   567F             	; no urgent data support
4450   567F 21 00 00    	ld	hl,0
4451   5682 AF          	xor	a
4452   5683 C9          	ret
4453   5684             TCPIP_TCP_RCV_R_NSF:
4454   5684 DB 07       	in	a,(IN_STS_PORT)
4455   5686 CB 47       	bit	0,a							; Do we have data to read?
4456   5688 20 05       	jr	nz,TCPIP_TCP_RCV_R_NSF.1
4457   568A CD 95 55    	call	TCPIP_TCP_RCV_CHECK_TIME_OUT
4458   568D 18 F5       	jr	TCPIP_TCP_RCV_R_NSF
4459   568F             TCPIP_TCP_RCV_R_NSF.1:
4460   568F ED A2       	ini
4461   5691 20 F1       	jr	nz,TCPIP_TCP_RCV_R_NSF
4462   5693 15          	dec	d
4463   5694 20 EE       	jr nz,TCPIP_TCP_RCV_R_NSF
4464   5696 CD 8B 58    	call	BCRESTORE				; done, restore return data in BC
4465   5699             	; no urgent data support
4466   5699 21 00 00    	ld	hl,0
4467   569C AF          	xor	a
4468   569D C9          	ret
4469   569E             
4470   569E             ;=============================
4471   569E             ;===  TCPIP_CONFIG_AUTOIP  ===
4472   569E             ;=============================
4473   569E             ;Enable or disable the automatic IP addresses retrieval.
4474   569E             ;
4475   569E             ;Input:  A = 25
4476   569E             ;        B = 0: Get current configuration
4477   569E             ;            1: Set configuration
4478   569E             ;        C = Configuration to set (only if B=1):
4479   569E             ;            bit 0: Set to automatically retrieve
4480   569E             ;                   local IP address, subnet mask and default gateway
4481   569E             ;            bit 1: Set to automatically retrieve DNS servers addresses
4482   569E             ;            bits 2-7: Unused, must be zero
4483   569E             ;Output: A = Error code
4484   569E             ;        C = Configuration after the routine execution
4485   569E             ;            (same format as C at input)
4486   569E             TCPIP_CONFIG_AUTOIP:
4487   569E D3 07       	out	(OUT_TX_PORT),a				; Send the command
4488   56A0 AF          	xor	a
4489   56A1 D3 07       	out	(OUT_TX_PORT),a				; Send the command size msb
4490   56A3 3E 02       	ld	a,2
4491   56A5 D3 07       	out	(OUT_TX_PORT),a				; Send the command size lsb
4492   56A7 78          	ld	a,b
4493   56A8 D3 07       	out	(OUT_TX_PORT),a				; Send the command
4494   56AA 79          	ld	a,c
4495   56AB D3 07       	out	(OUT_TX_PORT),a				; Send the command parameter
4496   56AD             
4497   56AD             	; Now wait up to 180 ticks to get response
4498   56AD 21 B4 00    	ld hl,180
4499   56B0 CD F4 57    	call	SETCOUNTER
4500   56B3             TCPIP_CONFIG_AUTOIP_ST1:
4501   56B3 DB 07       	in	a,(IN_STS_PORT)
4502   56B5 CB 47       	bit	0,a							; if nz has data
4503   56B7 20 05       	jr	nz,TCPIP_CONFIG_AUTOIP_ST1.1
4504   56B9 CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
4505   56BC 18 F5       	jr	TCPIP_CONFIG_AUTOIP_ST1
4506   56BE             TCPIP_CONFIG_AUTOIP_ST1.1:
4507   56BE             	; nz, check the data
4508   56BE DB 06       	in	a,(IN_DATA_PORT)
4509   56C0 FE 19       	cp	25							; Is response of our command?
4510   56C2 20 EF       	jr	nz,TCPIP_CONFIG_AUTOIP_ST1
4511   56C4             	; now get return code, if return code other than 0, it is finished
4512   56C4             TCPIP_CONFIG_AUTOIP_RC:
4513   56C4 DB 07       	in	a,(IN_STS_PORT)
4514   56C6 CB 47       	bit	0,a							; if nz has data
4515   56C8 20 05       	jr	nz,TCPIP_CONFIG_AUTOIP_RC.1
4516   56CA CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
4517   56CD 18 F5       	jr	TCPIP_CONFIG_AUTOIP_RC
4518   56CF             TCPIP_CONFIG_AUTOIP_RC.1:
4519   56CF             	;nz, discard
4520   56CF DB 06       	in	a,(IN_DATA_PORT)
4521   56D1 B7          	or	a							; 0?
4522   56D2 C0          	ret	nz							; if not, done
4523   56D3             
4524   56D3             	; next two bytes are return code and size bytes, don't care, it is 1, configuration
4525   56D3 06 02       	ld	b,2
4526   56D5             TCPIP_CONFIG_AUTOIP_ST2:
4527   56D5 DB 07       	in	a,(IN_STS_PORT)
4528   56D7 CB 47       	bit	0,a							; if nz has data
4529   56D9 20 05       	jr	nz,TCPIP_CONFIG_AUTOIP_ST2.1
4530   56DB CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
4531   56DE 18 F5       	jr	TCPIP_CONFIG_AUTOIP_ST2
4532   56E0             TCPIP_CONFIG_AUTOIP_ST2.1:
4533   56E0             	; nz, discard
4534   56E0 DB 06       	in	a,(IN_DATA_PORT)
4535   56E2 05          	dec	b
4536   56E3 20 F0       	jr	nz,TCPIP_CONFIG_AUTOIP_ST2
4537   56E5             
4538   56E5             	; now just get the 1 byte, configuration, should go to C
4539   56E5             TCPIP_CONFIG_AUTOIP_CONF_ST1:
4540   56E5 DB 07       	in	a,(IN_STS_PORT)
4541   56E7 CB 47       	bit	0,a							; if nz has data
4542   56E9 20 05       	jr	nz,TCPIP_CONFIG_AUTOIP_CONF_ST1.1
4543   56EB CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
4544   56EE 18 F5       	jr	TCPIP_CONFIG_AUTOIP_CONF_ST1
4545   56F0             TCPIP_CONFIG_AUTOIP_CONF_ST1.1:
4546   56F0             	; nz, get it
4547   56F0 DB 06       	in	a,(IN_DATA_PORT)
4548   56F2 4F          	ld	c,a
4549   56F3             	; done
4550   56F3 AF          	xor	a
4551   56F4 C9          	ret
4552   56F5             
4553   56F5             ;=========================
4554   56F5             ;===  TCPIP_CONFIG_IP  ===
4555   56F5             ;=========================
4556   56F5             ;Manually configure an IP address.
4557   56F5             ;
4558   56F5             ;Input:  A = 26
4559   56F5             ;        B = Index of address to set:
4560   56F5             ;            1: Local IP address
4561   56F5             ;            2: Peer IP address
4562   56F5             ;            3: Subnet mask
4563   56F5             ;            4: Default gateway
4564   56F5             ;            5: Primary DNS server IP address
4565   56F5             ;            6: Secondary DNS server IP address
4566   56F5             ;        L.H.E.D = Address value
4567   56F5             ;Output: A = Error code
4568   56F5             TCPIP_CONFIG_IP:
4569   56F5 D3 07       	out	(OUT_TX_PORT),a				; Send the command
4570   56F7 AF          	xor	a
4571   56F8 D3 07       	out	(OUT_TX_PORT),a				; Send the command size msb
4572   56FA 3E 05       	ld	a,5
4573   56FC D3 07       	out	(OUT_TX_PORT),a				; Send the command size lsb
4574   56FE 78          	ld	a,b
4575   56FF D3 07       	out	(OUT_TX_PORT),a				; Send the address to set
4576   5701 7D          	ld	a,l
4577   5702 D3 07       	out	(OUT_TX_PORT),a				; Send the IP first byte
4578   5704 7C          	ld	a,h
4579   5705 D3 07       	out	(OUT_TX_PORT),a				; Send the IP second byte
4580   5707 7B          	ld	a,e
4581   5708 D3 07       	out	(OUT_TX_PORT),a				; Send the IP third byte
4582   570A 7A          	ld	a,d
4583   570B D3 07       	out	(OUT_TX_PORT),a				; Send the IP fourth byte
4584   570D             
4585   570D             	; Now wait up to 180 ticks to get response
4586   570D 21 B4 00    	ld	hl,180
4587   5710 CD F4 57    	call	SETCOUNTER
4588   5713             TCPIP_CONFIG_IP_ST1:
4589   5713 DB 07       	in	a,(IN_STS_PORT)
4590   5715 CB 47       	bit	0,a							; if nz has data
4591   5717 20 05       	jr	nz,TCPIP_CONFIG_IP_ST1.1
4592   5719 CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
4593   571C 18 F5       	jr	TCPIP_CONFIG_IP_ST1
4594   571E             TCPIP_CONFIG_IP_ST1.1:
4595   571E             	; nz, check the data
4596   571E DB 06       	in	a,(IN_DATA_PORT)
4597   5720 FE 1A       	cp	26							; Is response of our command?
4598   5722 20 EF       	jr	nz,TCPIP_CONFIG_IP_ST1
4599   5724             	; now get return code, and that is it
4600   5724             TCPIP_CONFIG_IP_RC:
4601   5724 DB 07       	in	a,(IN_STS_PORT)
4602   5726 CB 47       	bit	0,a							; if nz has data
4603   5728 20 05       	jr	nz,TCPIP_CONFIG_IP_RC.1
4604   572A CD B4 4C    	call	TCPIP_GENERIC_CHECK_TIME_OUT
4605   572D 18 F5       	jr	TCPIP_CONFIG_IP_RC
4606   572F             TCPIP_CONFIG_IP_RC.1:
4607   572F             	; nz, discard
4608   572F DB 06       	in	a,(IN_DATA_PORT)
4609   5731 C9          	ret								; done
4610   5732             
4611   5732             ;==========================
4612   5732             ;===  TCPIP_CONFIG_TTL  ===
4613   5732             ;==========================
4614   5732             ;Get/set the value of TTL and TOS for outgoing datagrams.
4615   5732             ;
4616   5732             ;Input:  A = 27
4617   5732             ;        B = 0: Get current values (just return 255 for TTL and 0 for TOS
4618   5732             ;				as ESP do not expose or allow configurations of it)
4619   5732             ;            1: Set values
4620   5732             ;        D = New value for TTL (only if B=1)
4621   5732             ;        E = New value for ToS (only if B=1)
4622   5732             ;Output: A = Error code
4623   5732             ;        D = Value of TTL after the routine execution
4624   5732             ;        E = Value of ToS after the routine execution
4625   5732             TCPIP_CONFIG_TTL:
4626   5732 78          	ld	a,b
4627   5733 E6 FE       	and	%11111110
4628   5735 B7          	or	a
4629   5736 3E 04       	ld	a,ERR_INV_PARAM
4630   5738 C0          	ret	nz
4631   5739 78          	ld	a,b
4632   573A B7          	or	a
4633   573B             	; Cant set, so NOT IMP
4634   573B 3E 01       	ld	a,ERR_NOT_IMP
4635   573D C0          	ret	nz							; if not get, not implemented
4636   573E             	; get, so just return D = #FF, A = OK = 0 and E = 0
4637   573E AF          	xor	a
4638   573F 1E 00       	ld	e,0
4639   5741 16 FF       	ld	d,#FF
4640   5743 C9          	ret
4641   5744             
4642   5744             ;===========================
4643   5744             ;===  TCPIP_CONFIG_PING  ===
4644   5744             ;===========================
4645   5744             ;Get/set the automatic PING reply flag.
4646   5744             ;
4647   5744             ;Input:  A = 28
4648   5744             ;        B = 0: Get current flag value
4649   5744             ;            1: Set flag value (ERR_NOT_IMP)
4650   5744             ;        C = New flag value (only if B=1):
4651   5744             ;            0: Off
4652   5744             ;            1: On
4653   5744             ;Output: A = Error code
4654   5744             ;        C = Flag value after the routine execution
4655   5744             TCPIP_CONFIG_PING:
4656   5744 78          	ld	a,b
4657   5745 E6 FE       	and	%11111110
4658   5747 B7          	or	a
4659   5748 3E 04       	ld	a,ERR_INV_PARAM
4660   574A C0          	ret	nz
4661   574B 78          	ld	a,b
4662   574C B7          	or	a
4663   574D             	; Cant set, so NOT IMP
4664   574D 3E 01       	ld	a,ERR_NOT_IMP
4665   574F C0          	ret	nz							; if not get, not implemented
4666   5750             	; get, so just return C = 1, A = OK = 0
4667   5750 AF          	xor	a
4668   5751 0E 01       	ld	c,1
4669   5753 C9          	ret
4670   5754             
4671   5754             ;============================
4672   5754             ;===  Auxiliary routines  ===
4673   5754             ;============================
4674   5754             
4675   5754             ;--- Get slot connected on page 1
4676   5754             ;    Input:  -
4677   5754             ;    Output: A = Slot number
4678   5754             ;    Modifies: AF, HL, E, BC
4679   5754             
4680   5754             GETSLT:
4681   5754 DB A8       	in	a,(#A8)
4682   5756 0F          	rrca
4683   5757 0F          	rrca
4684   5758 E6 03       	and	3
4685   575A 4F          	ld	c,a							;C = Slot
4686   575B 06 00       	ld	b,0
4687   575D 21 C1 FC    	ld	hl,EXPTBL
4688   5760 09          	add	hl,bc
4689   5761 7E          	ld	a,(hl)
4690   5762 E6 80       	and	#80
4691   5764 B1          	or	c
4692   5765 4F          	ld	c,a
4693   5766 23          	inc	hl
4694   5767 23          	inc	hl
4695   5768 23          	inc	hl
4696   5769 23          	inc	hl
4697   576A 7E          	ld	a,(hl)
4698   576B E6 0C       	and	#0C
4699   576D B1          	or	c
4700   576E CB 7F       	bit	7,a
4701   5770 C0          	ret	nz
4702   5771 E6 03       	and	%11
4703   5773 C9          	ret
4704   5774             
4705   5774             ;--- Get slot connected on page 1 and test if work area has been created, if not, create it
4706   5774             ;    Input:  -
4707   5774             ;    Output: A = Slot number
4708   5774             ;    Modifies: AF, HL, E, BC
4709   5774             
4710   5774             GETSLTT:
4711   5774 DB A8       	in	a,(#A8)
4712   5776 0F          	rrca
4713   5777 0F          	rrca
4714   5778 E6 03       	and	3
4715   577A 4F          	ld	c,a							;C = Slot
4716   577B 06 00       	ld	b,0
4717   577D 21 C1 FC    	ld	hl,EXPTBL
4718   5780 09          	add	hl,bc
4719   5781 7E          	ld	a,(hl)
4720   5782 E6 80       	and	#80
4721   5784 B1          	or	c
4722   5785 4F          	ld	c,a
4723   5786 23          	inc	hl
4724   5787 23          	inc	hl
4725   5788 23          	inc	hl
4726   5789 23          	inc	hl
4727   578A 7E          	ld	a,(hl)
4728   578B E6 0C       	and	#0C
4729   578D B1          	or	c
4730   578E CB 7F       	bit	7,a
4731   5790 C2 95 57    	jp	nz,GETSLTT1
4732   5793 E6 03       	and	%11
4733   5795             GETSLTT1:
4734   5795 F5          	push	af
4735   5796 C5          	push	bc
4736   5797 E5          	push	hl
4737   5798 CD AD 57    	call	GETWRK
4738   579B 01 05 00    	ld	bc,5
4739   579E 09          	add	hl,bc
4740   579F 7E          	ld	a,(hl)
4741   57A0 B7          	or	a
4742   57A1 C2 A9 57    	jp	nz,GETSLTTRET
4743   57A4 3C          	inc	a
4744   57A5 77          	ld	(hl),a
4745   57A6 CD 92 41    	call	HIMEM_ALLOC
4746   57A9             GETSLTTRET:
4747   57A9 E1          	pop	hl
4748   57AA C1          	pop	bc
4749   57AB F1          	pop	af
4750   57AC C9          	ret
4751   57AD             
4752   57AD             ;--- Obtain slot work area (8 bytes) on SLTWRK
4753   57AD             ;    Input:  A  = Slot number
4754   57AD             ;    Output: HL = Work area address
4755   57AD             ;    Modifies: AF, BC
4756   57AD             
4757   57AD             GETWRK:
4758   57AD 47          	ld	b,a
4759   57AE 0F          	rrca
4760   57AF 0F          	rrca
4761   57B0 0F          	rrca
4762   57B1 E6 60       	and	%01100000
4763   57B3 4F          	ld	c,a							;C = Slot * 32
4764   57B4 78          	ld	a,b
4765   57B5 07          	rlca
4766   57B6 E6 18       	and	%00011000					;A = Subslot * 8
4767   57B8 B1          	or	c
4768   57B9 4F          	ld	c,a
4769   57BA 06 00       	ld	b,0
4770   57BC 21 09 FD    	ld	hl,SLTWRK
4771   57BF 09          	add	hl,bc
4772   57C0 C9          	ret
4773   57C1             
4774   57C1             ;--- Obtain the address where our memory area address in high memory is stored
4775   57C1             ;    Input:  A  = Slot number
4776   57C1             ;    Output: HL = High memory area address
4777   57C1             ;    Modifies: AF, BC
4778   57C1             
4779   57C1             GETMEMPOINTERADDR:
4780   57C1 47          	ld	b,a
4781   57C2 0F          	rrca
4782   57C3 0F          	rrca
4783   57C4 0F          	rrca
4784   57C5 E6 60       	and	%01100000
4785   57C7 4F          	ld	c,a							; C = Slot * 32
4786   57C8 78          	ld	a,b
4787   57C9 07          	rlca
4788   57CA E6 18       	and	%00011000					; A = Subslot * 8
4789   57CC B1          	or	c
4790   57CD 4F          	ld	c,a
4791   57CE 06 00       	ld	b,0
4792   57D0 D2 D4 57    	jp	nc,GETMEM_1
4793   57D3 04          	inc b
4794   57D4             GETMEM_1:
4795   57D4 21 09 FD    	ld	hl,SLTWRK
4796   57D7 09          	add	hl,bc
4797   57D8 01 05 00    	ld	bc,5
4798   57DB 09          	add	hl,bc
4799   57DC C9          	ret
4800   57DD             
4801   57DD             ;--- Obtain the address where our memory area address in high memory is stored
4802   57DD             ;    Input:  A  = Slot number
4803   57DD             ;    Output: HL = High memory area address
4804   57DD             ;    Modifies: AF, BC
4805   57DD             
4806   57DD             GETMEMPOINTER:
4807   57DD CD C1 57    	call	GETMEMPOINTERADDR
4808   57E0 4E          	ld	c,(hl)
4809   57E1 23          	inc	hl
4810   57E2 66          	ld	h,(hl)
4811   57E3 69          	ld	l,c
4812   57E4 C9          	ret
4813   57E5             
4814   57E5             ;--- Obtain our HTIM_I driven counter value in high memory
4815   57E5             ;    Input:  none
4816   57E5             ;    Output: HL = counter value
4817   57E5             ;    Modifies: AF, HL, DE, BC
4818   57E5             
4819   57E5             GETCOUNTER:
4820   57E5 CD 54 57    	call	GETSLT
4821   57E8             	; Slot in A, now get the address of our counter
4822   57E8 CD DD 57    	call	GETMEMPOINTER
4823   57EB             	; HL has the address of our memory area, counter is 5 bytes after start
4824   57EB 11 05 00    	ld	de,MEMORY_COUNTER_OFFSET
4825   57EE 19          	add	hl,de
4826   57EF             	; Ok, this is where our counter is so get it
4827   57EF 5E          	ld	e,(hl)
4828   57F0 23          	inc	hl
4829   57F1 56          	ld	d,(hl)
4830   57F2             	; DE has the counter value
4831   57F2 EB          	ex	de,hl						; Counter value in HL
4832   57F3 C9          	ret
4833   57F4             
4834   57F4             ;--- Set our HTIM_I driven counter value in high memory
4835   57F4             ;    Input:  HL = new counter value
4836   57F4             ;    Output: none
4837   57F4             ;    Modifies: AF, HL, DE, BC
4838   57F4             
4839   57F4             SETCOUNTER:
4840   57F4 E5          	push	hl						; Save parameter
4841   57F5 CD 54 57    	call	GETSLT
4842   57F8             	; Slot in A, now get the address of our counter
4843   57F8 CD DD 57    	call	GETMEMPOINTER
4844   57FB             	; HL has the address of our memory area, counter is 5 bytes after start
4845   57FB 11 05 00    	ld	de,MEMORY_COUNTER_OFFSET
4846   57FE 19          	add	hl,de
4847   57FF             	; Ok, this is where our counter is so get it
4848   57FF             	; HL has the address of counter
4849   57FF D1          	pop	de							; Restore parameter in DE
4850   5800 73          	ld	(hl),e
4851   5801 23          	inc	hl
4852   5802 72          	ld	(hl),d
4853   5803 C9          	ret
4854   5804             
4855   5804             ;--- Obtain a one byte param saved in high memory
4856   5804             ;    Input:  none
4857   5804             ;    Output: A = param
4858   5804             ;    Modifies: AF
4859   5804             
4860   5804             GETBYTE:
4861   5804 C5          	push	bc
4862   5805 D5          	push	de
4863   5806 E5          	push	hl
4864   5807 CD 54 57    	call	GETSLT
4865   580A             	; Slot in A, now get the address of our counter
4866   580A CD DD 57    	call	GETMEMPOINTER
4867   580D             	; HL has the address of our memory area, param is 7 bytes after start
4868   580D 11 07 00    	ld	de,MEMORY_SB_VAR_OFFSET
4869   5810 19          	add	hl,de
4870   5811             	; Ok, this is where our param is so get it
4871   5811 7E          	ld	a,(hl)
4872   5812 E1          	pop	hl
4873   5813 D1          	pop	de
4874   5814 C1          	pop	bc
4875   5815 C9          	ret
4876   5816             
4877   5816             ;--- Set a one byte param value in high memory
4878   5816             ;    Input:  A = new counter value
4879   5816             ;    Output: none
4880   5816             ;    Modifies: AF
4881   5816             
4882   5816             SETBYTE:
4883   5816 C5          	push	bc
4884   5817 D5          	push	de
4885   5818 E5          	push	hl
4886   5819 F5          	push	af						; Save parameter
4887   581A CD 54 57    	call	GETSLT
4888   581D             	; Slot in A, now get the address
4889   581D CD DD 57    	call	GETMEMPOINTER
4890   5820             	; HL has the address of our memory area, byte param is 7 bytes after start
4891   5820 11 07 00    	ld	de,MEMORY_SB_VAR_OFFSET
4892   5823 19          	add	hl,de
4893   5824             	; HL has the address of param
4894   5824 F1          	pop	af							; Restore parameter
4895   5825 77          	ld	(hl),a
4896   5826 E1          	pop	hl
4897   5827 D1          	pop	de
4898   5828 C1          	pop	bc
4899   5829 C9          	ret
4900   582A             
4901   582A             ;--- Obtain a two bytes param saved in high memory
4902   582A             ;    Input:  none
4903   582A             ;    Output: HL = param
4904   582A             ;    Modifies: AF, HL
4905   582A             
4906   582A             GETWORD:
4907   582A C5          	push	bc
4908   582B D5          	push	de
4909   582C CD 54 57    	call	GETSLT
4910   582F             	; Slot in A, now get the address of our counter
4911   582F CD DD 57    	call	GETMEMPOINTER
4912   5832             	; HL has the address of our memory area, param is 7 bytes after start
4913   5832 11 0B 00    	ld	de,MEMORY_DB_VAR_OFFSET
4914   5835 19          	add	hl,de
4915   5836             	; Ok, this is where our param is so get it
4916   5836 5E          	ld	e,(hl)
4917   5837 23          	inc	hl
4918   5838 56          	ld	d,(hl)
4919   5839 EB          	ex	de,hl						; Return in HL
4920   583A D1          	pop	de
4921   583B C1          	pop	bc
4922   583C C9          	ret
4923   583D             
4924   583D             ;--- Set a two bytes param value in high memory
4925   583D             ;    Input:  HL = new counter value
4926   583D             ;    Output: none
4927   583D             ;    Modifies: AF
4928   583D             
4929   583D             SETWORD:
4930   583D C5          	push	bc
4931   583E D5          	push	de
4932   583F E5          	push	hl
4933   5840 CD 54 57    	call	GETSLT
4934   5843             	; Slot in A, now get the address
4935   5843 CD DD 57    	call	GETMEMPOINTER
4936   5846             	; HL has the address of our memory area, byte param is 7 bytes after start
4937   5846 11 0B 00    	ld	de,MEMORY_DB_VAR_OFFSET
4938   5849 19          	add	hl,de
4939   584A             	; HL has the address of param
4940   584A D1          	pop	de							; Restore parameter in DE
4941   584B 73          	ld	(hl),e
4942   584C 23          	inc	hl
4943   584D 72          	ld	(hl),d
4944   584E EB          	ex	de,hl						; Restore HL original value
4945   584F D1          	pop	de
4946   5850 C1          	pop	bc
4947   5851 C9          	ret
4948   5852             
4949   5852             ;--- Restores BC / DE / HL copy saved in high memory
4950   5852             ;    Input:  none
4951   5852             ;    Output: BC / DE / HL
4952   5852             ;    Modifies: AF
4953   5852             
4954   5852             REGRESTORE:
4955   5852 CD 54 57    	call	GETSLT
4956   5855             	; Slot in A, now get the address of our counter
4957   5855 CD DD 57    	call	GETMEMPOINTER
4958   5858             	; HL has the address of our memory area, param is 7 bytes after start
4959   5858 11 0D 00    	ld	de,MEMORY_REGBACKUP_OFFSET
4960   585B 19          	add	hl,de
4961   585C             	; Ok, this is where our param is so get it
4962   585C 4E          	ld	c,(hl)
4963   585D 23          	inc	hl
4964   585E 46          	ld	b,(hl)
4965   585F 23          	inc	hl
4966   5860 5E          	ld	e,(hl)
4967   5861 23          	inc	hl
4968   5862 56          	ld	d,(hl)
4969   5863 23          	inc	hl
4970   5864 7E          	ld	a,(hl)
4971   5865 23          	inc	hl
4972   5866 66          	ld	h,(hl)
4973   5867 6F          	ld	l,a
4974   5868 C9          	ret
4975   5869             
4976   5869             ;--- Backups BC / DE /HL in high memory
4977   5869             ;    Input:  BC / DE / HL
4978   5869             ;    Output: none
4979   5869             ;    Modifies: AF
4980   5869             
4981   5869             REGBACKUP:
4982   5869 E5          	push	hl
4983   586A D5          	push	de
4984   586B C5          	push	bc
4985   586C CD 54 57    	call	GETSLT
4986   586F             	; Slot in A, now get the address
4987   586F CD DD 57    	call	GETMEMPOINTER
4988   5872             	; HL has the address of our memory area, byte param is 7 bytes after start
4989   5872 11 0D 00    	ld	de,MEMORY_REGBACKUP_OFFSET
4990   5875 19          	add	hl,de
4991   5876             	; HL has the address of param
4992   5876 C1          	pop	bc							; Restore BC
4993   5877 71          	ld	(hl),c
4994   5878 23          	inc	hl
4995   5879 70          	ld	(hl),b
4996   587A 23          	inc	hl
4997   587B D1          	pop	de							; Restore DE
4998   587C 73          	ld	(hl),e
4999   587D 23          	inc	hl
5000   587E 72          	ld	(hl),d
5001   587F 23          	inc	hl
5002   5880 E3          	ex (sp),hl						; backup the address and get HL value
5003   5881 7D          	ld	a,l
5004   5882 E3          	ex (sp),hl						; return it to the stack and get back the pointer
5005   5883 77          	ld	(hl),a						; save l
5006   5884 23          	inc	hl
5007   5885 E3          	ex (sp),hl						; backup the address and get HL value
5008   5886 7C          	ld	a,h
5009   5887 E3          	ex (sp),hl						; return it to the stack and get back the pointer
5010   5888 77          	ld	(hl),a						; save h
5011   5889 E1          	pop	hl							; Restore HL original value
5012   588A C9          	ret
5013   588B             
5014   588B             ;--- Restores BC copy saved in high memory
5015   588B             ;    Input:  none
5016   588B             ;    Output: BC
5017   588B             ;    Modifies: AF
5018   588B             
5019   588B             BCRESTORE:
5020   588B E5          	push	hl
5021   588C D5          	push	de
5022   588D CD 54 57    	call	GETSLT
5023   5890             	; Slot in A, now get the address of our counter
5024   5890 CD DD 57    	call	GETMEMPOINTER
5025   5893             	; HL has the address of our memory area, param is 7 bytes after start
5026   5893 11 0D 00    	ld	de,MEMORY_BCBACKUP_OFFSET
5027   5896 19          	add	hl,de
5028   5897             	; Ok, this is where our param is so get it
5029   5897 4E          	ld	c,(hl)
5030   5898 23          	inc	hl
5031   5899 46          	ld	b,(hl)
5032   589A D1          	pop	de
5033   589B E1          	pop	hl
5034   589C C9          	ret
5035   589D             
5036   589D             ;--- Backups BC in high memory
5037   589D             ;    Input:  BC
5038   589D             ;    Output: none
5039   589D             ;    Modifies: AF
5040   589D             
5041   589D             BCBACKUP:
5042   589D D5          	push	de
5043   589E E5          	push	hl
5044   589F C5          	push	bc
5045   58A0 CD 54 57    	call	GETSLT
5046   58A3             	; Slot in A, now get the address
5047   58A3 CD DD 57    	call	GETMEMPOINTER
5048   58A6             	; HL has the address of our memory area, byte param is 7 bytes after start
5049   58A6 11 0D 00    	ld	de,MEMORY_BCBACKUP_OFFSET
5050   58A9 19          	add	hl,de
5051   58AA             	; HL has the address of param
5052   58AA C1          	pop	bc							; Restore BC
5053   58AB 71          	ld	(hl),c
5054   58AC 23          	inc	hl
5055   58AD 70          	ld	(hl),b
5056   58AE E1          	pop	hl							; Restore HL original value
5057   58AF D1          	pop	de							; Restore DE
5058   58B0 C9          	ret
5059   58B1             
5060   58B1             ;--- Restores HL copy saved in high memory
5061   58B1             ;    Input:  none
5062   58B1             ;    Output: HL
5063   58B1             ;    Modifies: AF
5064   58B1             
5065   58B1             HLRESTORE:
5066   58B1 C5          	push	bc
5067   58B2 D5          	push	de
5068   58B3 CD 54 57    	call	GETSLT
5069   58B6             	; Slot in A, now get the address of our counter
5070   58B6 CD DD 57    	call	GETMEMPOINTER
5071   58B9             	; HL has the address of our memory area, param is 7 bytes after start
5072   58B9 11 11 00    	ld	de,MEMORY_HLBACKUP_OFFSET
5073   58BC 19          	add	hl,de
5074   58BD             	; Ok, this is where our param is so get it
5075   58BD 5E          	ld	e,(hl)
5076   58BE 23          	inc	hl
5077   58BF 56          	ld	d,(hl)
5078   58C0 EB          	ex	de,hl
5079   58C1 D1          	pop	de
5080   58C2 C1          	pop	bc
5081   58C3 C9          	ret
5082   58C4             
5083   58C4             ;--- Backups HL in high memory
5084   58C4             ;    Input:  HL
5085   58C4             ;    Output: none
5086   58C4             ;    Modifies: AF
5087   58C4             
5088   58C4             HLBACKUP:
5089   58C4 D5          	push	de
5090   58C5 C5          	push	bc
5091   58C6 E5          	push	hl
5092   58C7 CD 54 57    	call	GETSLT
5093   58CA             	; Slot in A, now get the address
5094   58CA CD DD 57    	call	GETMEMPOINTER
5095   58CD             	; HL has the address of our memory area, byte param is 7 bytes after start
5096   58CD 11 11 00    	ld	de,MEMORY_HLBACKUP_OFFSET
5097   58D0 19          	add	hl,de
5098   58D1             	; HL has the address of param
5099   58D1 D1          	pop	de							; Restore HL in de
5100   58D2 73          	ld	(hl),e
5101   58D3 23          	inc	hl
5102   58D4 72          	ld	(hl),d
5103   58D5 EB          	ex	de,hl						; Restore HL
5104   58D6 C1          	pop	bc							; Restore BC
5105   58D7 D1          	pop	de							; Restore DE
5106   58D8 C9          	ret
5107   58D9             
5108   58D9             ;--- Obtain if DNS is ready saved in high memory
5109   58D9             ;    Input:  none
5110   58D9             ;    Output: A = DNS ready value
5111   58D9             ;    Modifies: AF
5112   58D9             
5113   58D9             GETDNSREADY:
5114   58D9 C5          	push	bc
5115   58DA D5          	push	de
5116   58DB E5          	push	hl
5117   58DC CD 54 57    	call	GETSLT
5118   58DF             	; Slot in A, now get the address
5119   58DF CD DD 57    	call	GETMEMPOINTER
5120   58E2             	; HL has the address of our memory area, DNS ready is 8 bytes after start
5121   58E2 11 08 00    	ld	de,MEMORY_DNS_READY_OFFSET
5122   58E5 19          	add	hl,de
5123   58E6             	; Ok, get it
5124   58E6 7E          	ld	a,(hl)
5125   58E7 E1          	pop	hl
5126   58E8 D1          	pop	de
5127   58E9 C1          	pop	bc
5128   58EA C9          	ret
5129   58EB             
5130   58EB             ;--- Set DNS redy in high memory
5131   58EB             ;    Input:  A = new value
5132   58EB             ;    Output: none
5133   58EB             ;    Modifies: AF
5134   58EB             
5135   58EB             SETDNSREADY:
5136   58EB C5          	push	bc
5137   58EC D5          	push	de
5138   58ED E5          	push	hl
5139   58EE F5          	push	af						; Save parameter
5140   58EF CD 54 57    	call	GETSLT
5141   58F2             	; Slot in A, now get the address
5142   58F2 CD DD 57    	call	GETMEMPOINTER
5143   58F5             	; HL has the address of our memory area, DNS ready is 8 bytes after start
5144   58F5 11 08 00    	ld	de,MEMORY_DNS_READY_OFFSET
5145   58F8 19          	add	hl,de
5146   58F9             	; HL has the address of DNS ready
5147   58F9 F1          	pop	af							; Restore parameter
5148   58FA 77          	ld	(hl),a
5149   58FB E1          	pop	hl
5150   58FC D1          	pop	de
5151   58FD C1          	pop	bc
5152   58FE C9          	ret
5153   58FF             
5154   58FF             ;--- Obtain DNS result saved in high memory
5155   58FF             ;    Input:  none
5156   58FF             ;    Output: HL DE = DNS result
5157   58FF             ;    Modifies: AF
5158   58FF             
5159   58FF             GETDNSRESULT:
5160   58FF C5          	push	bc
5161   5900 CD 54 57    	call	GETSLT
5162   5903             	; Slot in A, now get the address
5163   5903 CD DD 57    	call	GETMEMPOINTER
5164   5906             	; HL has the address of our memory area, DNS result is 9 bytes after start
5165   5906 11 09 00    	ld	de,MEMORY_DNS_RES_OFFSET
5166   5909 19          	add	hl,de
5167   590A             	; Ok, get it, first bytes are hl
5168   590A 5E          	ld	e,(hl)
5169   590B 23          	inc	hl
5170   590C 56          	ld	d,(hl)
5171   590D D5          	push	de						; for now, save in stack, so we can restore to HL later
5172   590E 23          	inc	hl
5173   590F 5E          	ld	e,(hl)
5174   5910 23          	inc	hl
5175   5911 56          	ld	d,(hl)
5176   5912 E1          	pop	hl							; and now restore HL value from stack
5177   5913 C1          	pop	bc
5178   5914 C9          	ret
5179   5915             
5180   5915             ;--- Set DNS result in high memory
5181   5915             ;    Input:  HL DE = new value
5182   5915             ;    Output: none
5183   5915             ;    Modifies: AF
5184   5915             
5185   5915             SETDNSRESULT:
5186   5915 C5          	push	bc
5187   5916 D5          	push	de
5188   5917 E5          	push	hl
5189   5918 CD 54 57    	call	GETSLT
5190   591B             	; Slot in A, now get the address
5191   591B CD DD 57    	call	GETMEMPOINTER
5192   591E             	; HL has the address of our memory area, DNS result is 9 bytes after start
5193   591E 11 09 00    	ld	de,MEMORY_DNS_RES_OFFSET
5194   5921 19          	add	hl,de
5195   5922             	; HL has the address of DNS result
5196   5922 C1          	pop	bc							; Restore parameter HL in BC
5197   5923 71          	ld	(hl),c
5198   5924 23          	inc	hl
5199   5925 70          	ld	(hl),b
5200   5926 D1          	pop	de							; Restore parameter DE in DE
5201   5927 23          	inc	hl
5202   5928 73          	ld	(hl),e
5203   5929 23          	inc	hl
5204   592A 72          	ld	(hl),d
5205   592B 69          	ld	l,c
5206   592C 60          	ld	h,b							; And HL is restored
5207   592D C1          	pop	bc							; Restore BC
5208   592E C9          	ret
5209   592F             
5210   592F             ;--- Convert a character to upper-case if it is a lower-case letter
5211   592F             TOUPPER:
5212   592F FE 61       	cp	"a"
5213   5931 D8          	ret	c
5214   5932 FE 7B       	cp	"z"+1
5215   5934 D0          	ret	nc
5216   5935 E6 DF       	and	#DF
5217   5937 C9          	ret
5218   5938             
5219   5938             ;*********************************************
5220   5938             ;***       WAIT_RESPONSE_FROM_ESP          ***
5221   5938             ;*** Will wait ESP to send a response,     ***
5222   5938             ;*** discarding all data until it is found.***
5223   5938             ;***                                       ***
5224   5938             ;*** Inputs:                               ***
5225   5938             ;*** HL - Expected response string         ***
5226   5938             ;*** A - Response Size                     ***
5227   5938             ;*** DE - TimeOut in ticks                 ***
5228   5938             ;***                                       ***
5229   5938             ;*** Output:                               ***
5230   5938             ;*** A - 0 if response received 		   ***
5231   5938             ;*** otherwise response not received and   ***
5232   5938             ;*** timed-out.                            ***
5233   5938             ;***                                       ***
5234   5938             ;*** Changes HL, BC, AF, DE, IX            ***
5235   5938             ;*********************************************
5236   5938             WRFE_WAIT_DATA:
5237   5938 DB 07       	in	a,(IN_STS_PORT)
5238   593A CB 47       	bit	0,a							; if nz has data
5239   593C C0          	ret	nz
5240   593D 1B          	dec	de
5241   593E 76          	halt
5242   593F C9          	ret
5243   5940             
5244   5940             WRFE_COMPARE:
5245   5940 47          	ld	b,a
5246   5941 7E          	ld	a,(hl)
5247   5942 B8          	cp	b
5248   5943 C0          	ret	nz
5249   5944 23          	inc	hl
5250   5945 C9          	ret
5251   5946             
5252   5946             WAIT_RESPONSE_FROM_ESP:
5253   5946 4F          	ld	c,a							; Response size in C
5254   5947 E5          	push	hl						; Save HL
5255   5948 AF          	xor a
5256   5949             WRFE_ST1:
5257   5949 DD 67       	ld	ixh,a						; We start at index 0
5258   594B             
5259   594B             WRFE_LOOP:
5260   594B CD 38 59    	call	WRFE_WAIT_DATA
5261   594E 20 07       	jr	nz,WRFE_LOOP.1
5262   5950 7B          	ld	a,e
5263   5951 B2          	or	d
5264   5952 CA 71 59    	jp	z,WRFE_RET_ERROR
5265   5955 18 F4       	jr	WRFE_LOOP
5266   5957             WRFE_LOOP.1:
5267   5957             	; nz, check the data
5268   5957 DB 06       	in	a,(IN_DATA_PORT)
5269   5959             	; Ok, now the byte is in A, let's compare
5270   5959             WRFE_IDXCMD:
5271   5959 CD 40 59    	call WRFE_COMPARE
5272   595C             	; if match
5273   595C 28 07       	jr	z,WRFE_RSP_MATCH
5274   595E             	; did not match, let's zero the rsp index
5275   595E AF          	xor	a
5276   595F DD 67       	ld	ixh,a						; re-start at index 0
5277   5961 E1          	pop	hl							; restore the response index
5278   5962 E5          	push	hl						; and keep it in stack
5279   5963             	; back to get another byte
5280   5963 18 E6       	jr	WRFE_LOOP
5281   5965             WRFE_RSP_MATCH:
5282   5965             	; match
5283   5965 DD 24       	inc	ixh
5284   5967 DD 7C       	ld	a,ixh
5285   5969 B9          	cp	c
5286   596A             	; if a = c done and response is success
5287   596A 28 02       	jr	z,WRFE_RET_OK
5288   596C             	; not done, back to get more bytes
5289   596C 18 DD       	jr	WRFE_LOOP
5290   596E             WRFE_RET_OK:
5291   596E E1          	pop	hl
5292   596F AF          	xor	a
5293   5970 C9          	ret
5294   5971             WRFE_RET_ERROR:
5295   5971 E1          	pop	hl
5296   5972 3E 01       	ld	a,1
5297   5974 C9          	ret
5298   5975             
5299   5975             ;*********************************************
5300   5975             ;***              RESET ESP                ***
5301   5975             ;*** If RESET ok, A will be 0, otherwise   ***
5302   5975             ;*** failure							   ***
5303   5975             ;*********************************************
5304   5975             RESET_ESP:
5305   5975 06 0A       	ld	b,10						; Retry up to 10 times
5306   5977             RESET_ESP_LOOP:
5307   5977 3E 14       	ld	a,20
5308   5979 D3 06       	out	(OUT_CMD_PORT),a			; Clear UART
5309   597B AF          	xor	a
5310   597C D3 06       	out	(OUT_CMD_PORT),a			; Send the command to change the speed of interface
5311   597E 76          	halt
5312   597F 76          	halt							; Wait a little to make sure speed is adjusted
5313   5980 3E 57       	ld	a,CMD_WRESET_ESP
5314   5982 D3 07       	out	(OUT_TX_PORT),a
5315   5984 21 78 5A    	ld	hl,RSP_CMD_RESET_ESP		; Expected response
5316   5987 11 5A 00    	ld	de,90						; Up to 1.5s @ 60Hz
5317   598A 3E 05       	ld	a,RSP_CMD_RESET_ESP_SIZE	; Size of response
5318   598C C5          	push	bc						; Save retry counter
5319   598D CD 46 59    	call	WAIT_RESPONSE_FROM_ESP
5320   5990 C1          	pop	bc							; restore retry counter
5321   5991 B7          	or	a							; Did WAIT RESPONSE return zero?
5322   5992 C8          	ret	z							; Yes, Warm Reset Ok and ESP Found
5323   5993 10 E2       	djnz RESET_ESP_LOOP				; No, decrement retry counter and let the loop check
5324   5995             	; No more retries? Then check if it is old ESP FW
5325   5995             RESET_CHK_IF_INSTALLED:
5326   5995             	; Ok, Warm Reset did not work, is ESP installed?
5327   5995 3E 14       	ld	a,20
5328   5997 D3 06       	out	(OUT_CMD_PORT),a			; Clear UART
5329   5999 3E 3F       	ld	a,CMD_QUERY_ESP
5330   599B D3 07       	out	(OUT_TX_PORT),a
5331   599D 21 7D 5A    	ld	hl,RSP_CMD_QUERY_ESP		; Expected response
5332   59A0 11 B4 00    	ld	de,180						; Up to 3s @ 60Hz
5333   59A3 3E 02       	ld	a,RSP_CMD_QUERY_ESP_SIZE	; Size of response
5334   59A5 CD 46 59    	call	WAIT_RESPONSE_FROM_ESP
5335   59A8 B7          	or	a
5336   59A9 3E 01       	ld	a,1
5337   59AB 06 01       	ld	b,1							; 1 if response, then it is old firmware
5338   59AD C8          	ret	z
5339   59AE 06 00       	ld	b,0							; 0 if no response
5340   59B0 C9          	ret
5341   59B1             
5342   59B1             ;*********************************************
5343   59B1             ;***              SET TIME                 ***
5344   59B1             ;*** H - Hour                              ***
5345   59B1             ;*** L - Minutes                           ***
5346   59B1             ;*** D - Seconds                           ***
5347   59B1             ;***                                       ***
5348   59B1             ;*** A - 0 if Ok otherwise invalid time    ***
5349   59B1             ;*********************************************
5350   59B1             SET_TIME:
5351   59B1 7C          	ld	a,h							; Hour in A
5352   59B2 FE 18       	cp	24							; Compare to 24
5353   59B4 30 12       	jr	nc,SET_TIME_ERR				; If 24 or more, invalid
5354   59B6 7D          	ld	a,l							; Minutes in A
5355   59B7 FE 3C       	cp	60							; Compare to 60
5356   59B9 30 0D       	jr	nc,SET_TIME_ERR				; If 60 or more, invalid
5357   59BB 7A          	LD	a,d							; Seconds in D
5358   59BC FE 3C       	cp	60							; Compare to 60
5359   59BE 30 08       	jr	nc,SET_TIME_ERR				; If 60 or more invalid
5360   59C0 44          	ld	b,h							; Hour in B
5361   59C1 4D          	ld	c,l							; Minutes in C
5362   59C2 5A          	ld	e,d							; Seconds in E
5363   59C3 CD CB 59    	call	SET_RTC_TIME			; Set time in RTC
5364   59C6 AF          	xor	a							; 0 in A
5365   59C7 C9          	ret								; Return
5366   59C8             ;	Invalid parameter
5367   59C8             SET_TIME_ERR:
5368   59C8 3E 01       	ld	a,1							; Invalid Time
5369   59CA C9          	ret								; Return
5370   59CB             
5371   59CB             SET_RTC_TIME:
5372   59CB 6B          	ld	l,e							; Seconds in L
5373   59CC 61          	ld	h,c							; Minutes in H
5374   59CD 50          	ld	d,b							; Hour in D
5375   59CE CD 26 5A    	call	STOP_RTC_COUNT_SET_MODE0; Select RTC Register 13, and set Mode / Page 0
5376   59D1 3E 0F       	ld	a,#F						; Register F
5377   59D3 D3 B4       	out	(#B4),a
5378   59D5 3E 02       	ld	a,2
5379   59D7 D3 B5       	out	(#B5),a						; Timer reset seconds and on both clock pulses
5380   59D9 1E 00       	ld	e,0							; Start at register 0
5381   59DB C3 61 5A    	jp	SET_RTC_DATE.1				; And save L, H and D, function will return from there
5382   59DE             
5383   59DE             ;*********************************************
5384   59DE             ;***              SET DATE                 ***
5385   59DE             ;*** HL - Year from 1980 to 2079           ***
5386   59DE             ;*** D - Month from 1 to 12                ***
5387   59DE             ;*** E - Day from 1 to 31                  ***
5388   59DE             ;***                                       ***
5389   59DE             ;*** A - 0 if Ok otherwise invalid Date    ***
5390   59DE             ;*********************************************
5391   59DE             SET_DATE:
5392   59DE 01 44 F8    	ld	bc,#F844
5393   59E1 09          	add	hl,bc
5394   59E2 30 32       	jr	nc,SET_DATE_ERR				; No carry -> Year is less than 1980, invalid date
5395   59E4 7C          	ld	a,h
5396   59E5 B7          	or	a
5397   59E6 20 2E       	jr	nz,SET_DATE_ERR				; If H is set, means year is greater than 2235 ,invalid
5398   59E8 7D          	ld	a,l
5399   59E9 FE 64       	cp	100
5400   59EB 30 29       	jr	nc,SET_DATE_ERR				; If L >= 100 year is greater than 2079, invalid
5401   59ED 47          	ld	b,a							; Year - 1980 in B
5402   59EE 7A          	ld	a,d							; Now test month
5403   59EF 3D          	dec	a
5404   59F0 FE 0C       	cp	12							; If 12 or less this should carry
5405   59F2 30 22       	jr	nc,SET_DATE_ERR				; otherwise invalid
5406   59F4 21 19 5A    	ld	hl,DAYS_IN_MONTH			; Days in Month table
5407   59F7 85          	add	a,l							; add our month
5408   59F8 6F          	ld	l,a							; back in L
5409   59F9 30 01       	jr	nc,SET_DATE1				; no carry done
5410   59FB 24          	inc	h							; otherwise increase H
5411   59FC             SET_DATE1:
5412   59FC 3E 1C       	ld	a,28						; 28 days
5413   59FE BE          	cp	(hl)						; If month is 28 days, February, need to check if leap and limit is 29 in this year
5414   59FF 20 08       	jr	nz,SET_DATE2				; if not, skip below code , so probably above check is if month is february
5415   5A01 78          	ld	a,b							; Year - 1980 in A again
5416   5A02 E6 03       	and	3							; if other than 0, non divisible per 4, so not a leap year
5417   5A04 20 03       	jr	nz,SET_DATE2				; Regular year
5418   5A06 21 25 5A    	ld	hl,DAYS_IN_FEBRUARY_LEAP	; HL has address of 29 days, maximum number of days for february in leap year
5419   5A09             SET_DATE2:
5420   5A09 7B          	ld	a,e							; Day of month in A
5421   5A0A 3D          	dec	a							; Decrement
5422   5A0B BE          	cp	(hl)						; Compare with Days in month
5423   5A0C 30 08       	jr	nc,SET_DATE_ERR				; If day is greater than how many days in month, invalid
5424   5A0E 6B          	ld	l,e							; Day of month in L
5425   5A0F 62          	ld	h,d							; Month in H
5426   5A10 50          	ld	d,b							; Year - 1980 in D
5427   5A11 CD 4B 5A    	call	SET_RTC_DATE			; Set date in RTC
5428   5A14 AF          	xor	a							; A = 0
5429   5A15 C9          	ret								; Success
5430   5A16             ;	Invalid parameter
5431   5A16             SET_DATE_ERR:
5432   5A16 3E 01       	ld	a,1
5433   5A18 C9          	ret
5434   5A19             
5435   5A19             ; Table of top day value for each month
5436   5A19             DAYS_IN_MONTH:			db	31,28,31,30,31,30,31,31,30,31,30,31
5436   5A19 1F1C1F1E1F1E1F1F1E1F1E1F
5437   5A25             ; And top day value in February when Leap Year
5438   5A25 1D          DAYS_IN_FEBRUARY_LEAP:	db	29
5439   5A26             
5440   5A26             ; Will select Mode 00 (Date and Time page) and stop clock counting
5441   5A26             ; Register D value will be left in A
5442   5A26             STOP_RTC_COUNT_SET_MODE0:
5443   5A26 3E 0D       	ld	a,#D
5444   5A28 D3 B4       	out	(#B4),a						; Select RTC register D (mode)
5445   5A2A DB B5       	in	a,(#B5)						; read register D
5446   5A2C E6 04       	and	4							; Save Alarm EN setting, and mode register is 00 and stop counting time
5447   5A2E D3 B5       	out	(#B5),a						; And save
5448   5A30 C9          	ret
5449   5A31             
5450   5A31             ; Will get a non BCD value in A, convert it to BCD and then save it in
5451   5A31             ; a register pair that starts in the register indicated in E
5452   5A31             ; Register E will have the next register after that register pair
5453   5A31             RTC_SAVE_REGISTERPAIR:
5454   5A31 4F          	ld	c,a							; Save A in C
5455   5A32 AF          	xor	a							; 0 in A
5456   5A33 06 08       	ld	b,8							; 8 in B, number of bits for conversion
5457   5A35             RTC_SAVE_REGISTERPAIR.1:
5458   5A35 CB 01       	rlc	c							; Leftmost bit in Carry
5459   5A37 8F          	adc	a,a							; A = (A * 2) + Carry
5460   5A38 27          	daa								; decimal adjust A, shift = BCD x 2 + carry
5461   5A39 10 FA       	djnz	RTC_SAVE_REGISTERPAIR.1	; Repeat for 8 bits
5462   5A3B CD 42 5A    	call	SET_RTC_REG				; Save LSB in register and increase register address
5463   5A3E 0F          	rrca
5464   5A3F 0F          	rrca
5465   5A40 0F          	rrca
5466   5A41 0F          	rrca							; now MSB is in LSB position
5467   5A42             SET_RTC_REG:
5468   5A42 47          	ld	b,a							; save value to set in B
5469   5A43 7B          	ld	a,e							; and now register address in A
5470   5A44 D3 B4       	out	(#B4),a						; The register we want to set
5471   5A46 78          	ld	a,b							; restore value
5472   5A47 D3 B5       	out	(#B5),a						; save it
5473   5A49 1C          	inc	e							; increase register address, as this usually is done in pairs
5474   5A4A C9          	ret
5475   5A4B             
5476   5A4B             ; Auxiliary function for SET_DATE and SET_TIME
5477   5A4B             ; SET_RTC_DATE will save date, parameters:
5478   5A4B             ; L - Day
5479   5A4B             ; H - Month
5480   5A4B             ; D - Years since 1980
5481   5A4B             ; All values are regular values, this function will properly convert them
5482   5A4B             ;
5483   5A4B             ; SET_RTC_DATE.1 is used by SET_TIME as well
5484   5A4B             ; It will save three register pairs, starting with the register in E
5485   5A4B             ; First pair is updated with value in L
5486   5A4B             ; Second pair is updated with value in H
5487   5A4B             ; Third pair is updated with value in D
5488   5A4B             SET_RTC_DATE:
5489   5A4B CD 26 5A    	call	STOP_RTC_COUNT_SET_MODE0; Select RTC Register 13, and set Mode / Page 0
5490   5A4E F6 01       	or	1							; Set Bit 0, so Mode / Page 1
5491   5A50 D3 B5       	out	(#B5),a						; save it in register 13, now page 1 selected
5492   5A52 3E 0B       	ld	a,#B						; Leap Year Counter Register
5493   5A54 D3 B4       	out	(#B4),a						; Select it
5494   5A56 7A          	ld	a,d							; Load Years in leap year counter
5495   5A57 D3 B5       	out	(#B5),a						; So it has count of leap years (0 is 1980, leap, and every time it is 4, leap year again)
5496   5A59 CD 26 5A    	call	STOP_RTC_COUNT_SET_MODE0; Select RTC Register 13 and set mode / page 0
5497   5A5C CD 26 5A    	call	STOP_RTC_COUNT_SET_MODE0; do it a second time... DOS does it, don't want to JYNX it :P
5498   5A5F 1E 07       	ld	e,7							; Register 7
5499   5A61             SET_RTC_DATE.1:
5500   5A61 7D          	ld	a,l							; A has day
5501   5A62 CD 31 5A    	call	RTC_SAVE_REGISTERPAIR	; Will convert day to BCD and save in registers 7 and 8
5502   5A65 7C          	ld	a,h							; A has month
5503   5A66 CD 31 5A    	call	RTC_SAVE_REGISTERPAIR	; Will convert month to BCD and save in register 9 and A
5504   5A69 7A          	ld	a,d							; A has how many years since 1980
5505   5A6A CD 31 5A    	call	RTC_SAVE_REGISTERPAIR	; Will convert to BCD and save in register B and C
5506   5A6D 3E 0D       	ld	a,#D						; Register D
5507   5A6F D3 B4       	out	(#B4),a						; Send it
5508   5A71 DB B5       	in	a,(#B5)						; Read its value
5509   5A73 F6 08       	or	8							; Start counting time again
5510   5A75 D3 B5       	out	(#B5),a						; Send
5511   5A77 C9          	ret
5512   5A78             
5513   5A78             ;*********************************************
5514   5A78             ;***    ESP Specific Commands/Responses    ***
5515   5A78             ;*********************************************
5516   5A78             ; Cold reset of ESP firmware
5517   5A78             CMD_RESET_ESP			equ	'R'
5518   5A78             ; Warm reset of ESP firmware
5519   5A78             CMD_WRESET_ESP			equ	'W'
5520   5A78             ; Hold Wi-Fi Connection On
5521   5A78             CMD_WIFIHOLD_ESP		equ	'H'
5522   5A78             ; Release Wi-Fi Connection Hold
5523   5A78             CMD_WIFIRELEASE_ESP		equ	'h'
5524   5A78             ; Get Updated time and date from internet
5525   5A78             CMD_GET_TIME			equ	'G'
5526   5A78             ; Query Auto Clock settings
5527   5A78             CMD_QUERY_ACLK_SETTINGS	equ	'c'
5528   5A78             ; Set Auto Clock settings
5529   5A78             CMD_SET_ACLK_SETTINGS	equ	'C'
5530   5A78             ; Query ESP settings
5531   5A78             CMD_QUERY_ESP_SETTINGS	equ	'Q'
5532   5A78             ; Set Timer Value
5533   5A78             CMD_TIMER_SET			equ	'T'
5534   5A78             ; Turn Nagle On
5535   5A78             CMD_NAGLE_ON			equ	'D'
5536   5A78             ; Turn Nagle Off
5537   5A78             CMD_NAGLE_OFF			equ	'N'
5538   5A78             ; Turn Wi-Fi Off
5539   5A78             CMD_WIFI_OFF			equ	'O'
5540   5A78             ; Request to connect to a network
5541   5A78             CMD_WIFI_CONNECT		equ	'A'
5542   5A78             ; Request to start network scan
5543   5A78             CMD_SCAN_START			equ	'S'
5544   5A78             ; Request network scan result
5545   5A78             CMD_SCAN_RESULTS		equ	's'
5546   5A78             ; Request AP Status
5547   5A78             CMD_AP_STS				equ	'g'
5548   5A78             ; Get ESP firmware version
5549   5A78             CMD_GET_ESP_VER			equ	'V'
5550   5A78             ; After finishing Warm reset, ESP returns ready
5551   5A78 5265616479  RSP_CMD_RESET_ESP		db	"Ready"
5552   5A7D             RSP_CMD_RESET_ESP_SIZE	equ	5
5553   5A7D             ; Query ESP Presence
5554   5A7D             CMD_QUERY_ESP			equ	'?'
5555   5A7D             ; Query response
5556   5A7D 4F 4B       RSP_CMD_QUERY_ESP		db	"OK"
5557   5A7F             RSP_CMD_QUERY_ESP_SIZE	equ	2
5558   5A7F             
5559   5A7F             ;--- Strings
5560   5A7F             ; Special thanks to KdL
5561   5A7F             ; He has contributed a lot to make the menus and strings
5562   5A7F             ; concise and much easier to read and understand!
5563   5A7F             STTERMINATOR			equ	0
5564   5A7F             LF						equ	10
5565   5A7F             HOME					equ	11
5566   5A7F             CLS						equ	12
5567   5A7F             CR						equ	13
5568   5A7F             GOLEFT					equ	29
5569   5A7F             
5570   5A7F             ENTERING_WIFI_SETUP:
5571   5A7F 0C          	db	CLS
5572   5A80             	db	"Entering Wi-Fi Setup..."		,CR,LF,LF,STTERMINATOR
5572   5A80 456E746572696E672057692D46692053657475702E2E2E0D0A0A00
5573   5A9B             ;---
5574   5A9B             
5575   5A9B             WELCOME:
5576   5A9B 0C          	db	CLS
5577   5A9C             	db  "ObsoNET Wireless by" 		,CR,LF
5577   5A9C 4F62736F4E455420576972656C6573732062790D0A
5578   5AB1             	db  "The Retro Hacker"				,CR,LF,LF
5578   5AB1 54686520526574726F204861636B65720D0A0A
5579   5AC4             	db	"ESP8266 TCP/IP UNAPI 1.2 by"	,CR,LF
5579   5AC4 45535038323636205443502F495020554E41504920312E322062790D0A
5580   5AE1             	db	"(c)2020 Oduvaldo Pavan Jr"		,CR,LF
5580   5AE1 28632932303230204F647576616C646F20506176616E204A720D0A
5581   5AFC             	db	"ducasp@gmail.com"				,CR,LF,LF,STTERMINATOR
5581   5AFC 64756361737040676D61696C2E636F6D0D0A0A00
5582   5B10             ;---
5583   5B10             
5584   5B10             WELCOME_S:
5585   5B10             	db	"Quick Receive not supported."	,CR,LF
5585   5B10 517569636B2052656365697665206E6F7420737570706F727465642E0D0A
5586   5B2E             	db	"Machine FW Update Suggested!"	,CR,LF,LF,STTERMINATOR
5586   5B2E 4D616368696E652046572055706461746520537567676573746564210D0A0A00
5587   5B4E             ;---
5588   5B4E             
5589   5B4E             WELCOME_SF:
5590   5B4E             	db	"Quick Receive supported."		,CR,LF,LF,STTERMINATOR
5590   5B4E 517569636B205265636569766520737570706F727465642E0D0A0A00
5591   5B6A             ;---
5592   5B6A             
5593   5B6A             WELCOME_CS0:
5594   5B6A             	db	"Wi-Fi is Idle, AP configured:"	,GOLEFT,CR,LF,STTERMINATOR
5594   5B6A 57692D46692069732049646C652C20415020636F6E666967757265643A1D0D0A
5594   5B8A 00
5595   5B8B             
5596   5B8B             WELCOME_CS1:
5597   5B8B             	db	"Wi-Fi Connecting to AP:"		,CR,LF,STTERMINATOR
5597   5B8B 57692D466920436F6E6E656374696E6720746F2041503A0D0A00
5598   5BA5             
5599   5BA5             WELCOME_CS2:
5600   5BA5             	db	"Wi-Fi Wrong Password for AP:"	,CR,LF,STTERMINATOR
5600   5BA5 57692D46692057726F6E672050617373776F726420666F722041503A0D0A00
5601   5BC4             
5602   5BC4             WELCOME_CS3:
5603   5BC4             	db	"Wi-Fi Did not find AP:"		,CR,LF,STTERMINATOR
5603   5BC4 57692D466920446964206E6F742066696E642041503A0D0A00
5604   5BDD             
5605   5BDD             WELCOME_CS4:
5606   5BDD             	db	"Wi-Fi Failed to connect to:"	,CR,LF,STTERMINATOR
5606   5BDD 57692D4669204661696C656420746F20636F6E6E65637420746F3A0D0A00
5607   5BFB             
5608   5BFB             WELCOME_CS5:
5609   5BFB             	db	"Wi-Fi Connected to:"			,CR,LF,STTERMINATOR
5609   5BFB 57692D466920436F6E6E656374656420746F3A0D0A00
5610   5C11             
5611   5C11             MMENU_S:
5612   5C11             	db	"1 - Set Nagle Algorithm"		,CR,LF
5612   5C11 31202D20536574204E61676C6520416C676F726974686D0D0A
5613   5C2A             	db	"2 - Set Wi-Fi On Period"		,CR,LF
5613   5C2A 32202D205365742057692D4669204F6E20506572696F640D0A
5614   5C43             	db	"3 - Scan/Join Access Points"	,CR,LF
5614   5C43 33202D205363616E2F4A6F696E2041636365737320506F696E74730D0A
5615   5C60             	db	"4 - Wi-Fi and Clock Settings"	,CR,LF,LF
5615   5C60 34202D2057692D466920616E6420436C6F636B2053657474696E67730D0A0A
5616   5C7F             ;---
5617   5C7F             	db	"ESC to exit setup."			,CR,LF,LF
5617   5C7F 45534320746F20657869742073657475702E0D0A0A
5618   5C94             ;---
5619   5C94             	db	"Option: "						,STTERMINATOR
5619   5C94 4F7074696F6E3A2000
5620   5C9D             
5621   5C9D             MMENU_CLOCK_MSX2:
5622   5C9D 0C          	db	CLS
5623   5C9E             	db	"[ Wi-Fi and Clock Settings ]"	,CR,LF,LF
5623   5C9E 5B2057692D466920616E6420436C6F636B2053657474696E6773205D0D0A0A
5624   5CBD             ;---
5625   5CBD             	db	"0 - Wi-Fi & UNAPI are online"	,CR,LF
5625   5CBD 30202D2057692D4669202620554E41504920617265206F6E6C696E650D0A
5626   5CDB             	db	"1 - Also wait up to 10s for"	,CR,LF
5626   5CDB 31202D20416C736F207761697420757020746F2031307320666F720D0A
5627   5CF8             	db	"    internet availability and"	,GOLEFT,CR,LF
5627   5CF8 20202020696E7465726E657420617661696C6162696C69747920616E641D0D0A
5628   5D18             	db	"    get time from SNTP server"	,GOLEFT,CR,LF
5628   5D18 202020206765742074696D652066726F6D20534E5450207365727665721D0D0A
5629   5D38             	db	"    adjusting the time zone"	,CR,LF
5629   5D38 2020202061646A757374696E67207468652074696D65207A6F6E650D0A
5630   5D55             	db	"2 - The same as option 1 but"	,CR,LF
5630   5D55 32202D205468652073616D65206173206F7074696F6E2031206275740D0A
5631   5D73             	db	"    also will turn off Wi-Fi"	,CR,LF
5631   5D73 20202020616C736F2077696C6C207475726E206F66662057692D46690D0A
5632   5D91             	db	"    when done"					,CR,LF
5632   5D91 202020207768656E20646F6E650D0A
5633   5DA0             	db	"3 - Wi-Fi & UNAPI are offline"	,GOLEFT,CR,LF,LF
5633   5DA0 33202D2057692D4669202620554E41504920617265206F66666C696E651D0D0A
5633   5DC0 0A
5634   5DC1             ;---
5635   5DC1             	db	"MSX boot will take longer if"	,CR,LF
5635   5DC1 4D535820626F6F742077696C6C2074616B65206C6F6E6765722069660D0A
5636   5DDF             	db	"options 1 or 2 are active."	,CR,LF,LF,STTERMINATOR
5636   5DDF 6F7074696F6E732031206F72203220617265206163746976652E0D0A0A00
5637   5DFD             ;---
5638   5DFD             
5639   5DFD             MMENU_CLOCK_MSX1:
5640   5DFD 0C          	db	CLS
5641   5DFE             	db	"[ Wi-Fi and Clock Settings ]"	,CR,LF,LF
5641   5DFE 5B2057692D466920616E6420436C6F636B2053657474696E6773205D0D0A0A
5642   5E1D             ;---
5643   5E1D             	db	"0 - Wi-Fi & UNAPI are online"	,CR,LF
5643   5E1D 30202D2057692D4669202620554E41504920617265206F6E6C696E650D0A
5644   5E3B             	db	"1 - Unavailable for MSX1"		,CR,LF
5644   5E3B 31202D20556E617661696C61626C6520666F72204D5358310D0A
5645   5E55             	db	"2 - Unavailable for MSX1"		,CR,LF
5645   5E55 32202D20556E617661696C61626C6520666F72204D5358310D0A
5646   5E6F             	db	"3 - Wi-Fi & UNAPI are offline"	,GOLEFT,CR,LF,LF,STTERMINATOR
5646   5E6F 33202D2057692D4669202620554E41504920617265206F66666C696E651D0D0A
5646   5E8F 0A00
5647   5E91             ;---
5648   5E91             
5649   5E91             MMENU_CLOCK_0:
5650   5E91             	db	"Currently: ONLINE"				,STTERMINATOR
5650   5E91 43757272656E746C793A204F4E4C494E4500
5651   5EA3             
5652   5EA3             MMENU_CLOCK_1:
5653   5EA3             	db	"Currently: TIME-OPT1, GMT"		,STTERMINATOR
5653   5EA3 43757272656E746C793A2054494D452D4F5054312C20474D5400
5654   5EBD             
5655   5EBD             MMENU_CLOCK_2:
5656   5EBD             	db	"Currently: TIME-OPT2, GMT"		,STTERMINATOR
5656   5EBD 43757272656E746C793A2054494D452D4F5054322C20474D5400
5657   5ED7             
5658   5ED7             MMENU_CLOCK_3:
5659   5ED7             	db	"Currently: OFFLINE"			,STTERMINATOR
5659   5ED7 43757272656E746C793A204F46464C494E4500
5660   5EEA             
5661   5EEA             MMENU_CLOCK_OPT:
5662   5EEA 0D 0A 0A    	db	CR,LF,LF
5663   5EED             ;---
5664   5EED             	db	"ESC to return to main menu."	,CR,LF,LF
5664   5EED 45534320746F2072657475726E20746F206D61696E206D656E752E0D0A0A
5665   5F0B             ;---
5666   5F0B             	db	"Option: "						,STTERMINATOR
5666   5F0B 4F7074696F6E3A2000
5667   5F14             
5668   5F14             MMENU_GMT_OPT:
5669   5F14 0D 0A       	db	CR,LF
5670   5F16             	db	"Time Zone adjustment: "		,STTERMINATOR
5670   5F16 54696D65205A6F6E652061646A7573746D656E743A2000
5671   5F2D             
5672   5F2D             MMENU_MANUALENTRY:
5673   5F2D 0C          	db	CLS
5674   5F2E             	db	"[ Scan/Join Access Points ]"	,CR,LF,LF
5674   5F2E 5B205363616E2F4A6F696E2041636365737320506F696E7473205D0D0A0A
5675   5F4C             ;---
5676   5F4C             	db	"ESC to return to main menu."	,CR,LF
5676   5F4C 45534320746F2072657475726E20746F206D61696E206D656E752E0D0A
5677   5F69             	db	"Manual entry, type SSID:"		,CR,LF,STTERMINATOR
5677   5F69 4D616E75616C20656E7472792C207479706520535349443A0D0A00
5678   5F84             
5679   5F84             MENU_MANUALENTRY_PWD:
5680   5F84 0D 0A 0A    	db	CR,LF,LF
5681   5F87             ;---
5682   5F87             	db	"Password needed? "				,STTERMINATOR
5682   5F87 50617373776F7264206E65656465643F2000
5683   5F99             
5684   5F99             MMENU_SCAN:
5685   5F99 0C          	db	CLS
5686   5F9A             	db	"[ Scan/Join Access Points ]"	,CR,LF,LF
5686   5F9A 5B205363616E2F4A6F696E2041636365737320506F696E7473205D0D0A0A
5687   5FB8             ;---
5688   5FB8             	db	"Up to ",SCAN_MAX_PAGE_SIZE+48," APs per page."	,CR,LF,LF
5688   5FB8 557020746F2038204150732070657220706167652E0D0A0A
5689   5FD0             ;---
5690   5FD0             	db	"Scanning networks..."			,CR,LF,STTERMINATOR
5690   5FD0 5363616E6E696E67206E6574776F726B732E2E2E0D0A00
5691   5FE7             
5692   5FE7             MMENU_SCANF:
5693   5FE7 0D 0A       	db	CR,LF
5694   5FE9             	db	"Error or no networks found!"	,CR,LF,STTERMINATOR
5694   5FE9 4572726F72206F72206E6F206E6574776F726B7320666F756E64210D0A00
5695   6007             
5696   6007             MMENU_SCANN:
5697   6007 0D 0A       	db	CR,LF
5698   6009             	db	"No networks found!"			,CR,LF,STTERMINATOR
5698   6009 4E6F206E6574776F726B7320666F756E64210D0A00
5699   601E             
5700   601E             MMENU_SCANS:
5701   601E 0C          	db	CLS
5702   601F             	db	"[ Scan/Join Access Points ]"	,CR,LF,LF
5702   601F 5B205363616E2F4A6F696E2041636365737320506F696E7473205D0D0A0A
5703   603D             ;---
5704   603D             	db	"Networks available:"			,CR,LF,LF,STTERMINATOR
5704   603D 4E6574776F726B7320617661696C61626C653A0D0A0A00
5705   6054             ;---
5706   6054             
5707   6054             MMENU_CONNECTING:
5708   6054 0C          	db	CLS
5709   6055             	db	"[ Scan/Join Access Points ]"	,CR,LF,LF
5709   6055 5B205363616E2F4A6F696E2041636365737320506F696E7473205D0D0A0A
5710   6073             ;---
5711   6073             	db	"Requesting connection to:"		,CR,LF,LF,STTERMINATOR
5711   6073 52657175657374696E6720636F6E6E656374696F6E20746F3A0D0A0A00
5712   6090             ;---
5713   6090             
5714   6090             MMENU_ASKPWD:
5715   6090 0D 0A       	db	CR,LF
5716   6092             	db	"Hit DEL as first character"	,CR,LF
5716   6092 4869742044454C206173206669727374206368617261637465720D0A
5717   60AE             	db	"to hide/show the typing."		,CR,LF
5717   60AE 746F20686964652F73686F772074686520747970696E672E0D0A
5718   60C8             	db	"Password: "					,STTERMINATOR
5718   60C8 50617373776F72643A2000
5719   60D3             
5720   60D3             MMENU_SCANQ:
5721   60D3 0D 0A       	db	CR,LF
5722   60D5             	db	"ESC to return to main menu."	,CR,LF
5722   60D5 45534320746F2072657475726E20746F206D61696E206D656E752E0D0A
5723   60F2             	db	"SPACE BAR to scan again."	,CR,LF
5723   60F2 53504143452042415220746F207363616E20616761696E2E0D0A
5724   610C             	db	"ENTER to type SSID/AP name."	,CR,LF,LF
5724   610C 454E54455220746F207479706520535349442F4150206E616D652E0D0A0A
5725   612A             ;---
5726   612A             	db	"Number to connect: "		,STTERMINATOR
5726   612A 4E756D62657220746F20636F6E6E6563743A2000
5727   613E             
5728   613E             MMENU_SCANQM:
5729   613E 0D 0A       	db	CR,LF
5730   6140             	db	"ESC to return to main menu."	,CR,LF
5730   6140 45534320746F2072657475726E20746F206D61696E206D656E752E0D0A
5731   615D             	db	"SPACE BAR to show next page."	,CR,LF
5731   615D 53504143452042415220746F2073686F77206E65787420706167652E0D0A
5732   617B             	db	"ENTER to type SSID/AP name."	,CR,LF,LF
5732   617B 454E54455220746F207479706520535349442F4150206E616D652E0D0A0A
5733   6199             ;---
5734   6199             	db	"Number to connect: "		,STTERMINATOR
5734   6199 4E756D62657220746F20636F6E6E6563743A2000
5735   61AD             
5736   61AD             SCAN_TERMINATOR_CUT:
5737   61AD             	db	GOLEFT,GOLEFT,GOLEFT,".. ",GOLEFT,STTERMINATOR
5737   61AD 1D1D1D2E2E201D00
5738   61B5             
5739   61B5             SCAN_TERMINATOR_ENC:
5740   61B5 20 2A 1D    	db	" *"							,GOLEFT
5741   61B8             
5742   61B8             SCAN_TERMINATOR_OPEN:
5743   61B8 0D 0A 00    	db	CR,LF,STTERMINATOR
5744   61BB             
5745   61BB             MMENU_TIMEOUT:
5746   61BB 0C          	db	CLS
5747   61BC             	db	"   [ Set Wi-Fi On Period ]"	,CR,LF,LF
5747   61BC 2020205B205365742057692D4669204F6E20506572696F64205D0D0A0A
5748   61D9             ;---
5749   61D9             	db	"Wi-Fi On Period allows to set"	,GOLEFT,CR,LF
5749   61D9 57692D4669204F6E20506572696F6420616C6C6F777320746F207365741D0D0A
5750   61F9             	db	"a given period of time of"		,CR,LF
5750   61F9 6120676976656E20706572696F64206F662074696D65206F660D0A
5751   6214             	db	"inactivity to turn off Wi-Fi"	,CR,LF
5751   6214 696E616374697669747920746F207475726E206F66662057692D46690D0A
5752   6232             	db	"automatically."				,CR,LF,LF
5752   6232 6175746F6D61746963616C6C792E0D0A0A
5753   6243             ;---
5754   6243             	db	"0         - Always on"			,CR,LF
5754   6243 302020202020202020202D20416C77617973206F6E0D0A
5755   625A             	db	"1 to 30   - 30s"				,CR,LF
5755   625A 3120746F2033302020202D203330730D0A
5756   626B             	db	"31 to 600 - Use given period"	,CR,LF
5756   626B 333120746F20363030202D2055736520676976656E20706572696F640D0A
5757   6289             	db	"> 600     - 600s"				,CR,LF,LF,STTERMINATOR
5757   6289 3E2036303020202020202D20363030730D0A0A00
5758   629D             ;---
5759   629D             
5760   629D             MMENU_TIMEOUT_ALWAYSON:
5761   629D             	db	"Wi-Fi is currently: ALWAYS ON"	,GOLEFT,CR,LF,LF
5761   629D 57692D46692069732063757272656E746C793A20414C57415953204F4E1D0D0A
5761   62BD 0A
5762   62BE             ;---
5763   62BE             	db	"ESC to return to main menu."	,CR,LF,LF
5763   62BE 45534320746F2072657475726E20746F206D61696E206D656E752E0D0A0A
5764   62DC             ;---
5765   62DC             	db	"Type desired period: "			,STTERMINATOR
5765   62DC 54797065206465736972656420706572696F643A2000
5766   62F2             
5767   62F2             MMENU_TIMEOUT_NOTALWAYSON1:
5768   62F2             	db	"Wi-Fi period set to: "			,STTERMINATOR
5768   62F2 57692D466920706572696F642073657420746F3A2000
5769   6308             
5770   6308             MMENU_TIMEOUT_NOTALWAYSON2:
5771   6308 73 0D 0A 0A 	db	"s"								,CR,LF,LF
5772   630C             ;---
5773   630C             	db	"ESC to return to main menu."	,CR,LF,LF
5773   630C 45534320746F2072657475726E20746F206D61696E206D656E752E0D0A0A
5774   632A             ;---
5775   632A             	db	"Type desired period: "			,STTERMINATOR
5775   632A 54797065206465736972656420706572696F643A2000
5776   6340             
5777   6340             MMENU_NAGLE:
5778   6340 0C          	db	CLS
5779   6341             	db	"   [ Set Nagle Algorithm ]"	,CR,LF,LF
5779   6341 2020205B20536574204E61676C6520416C676F726974686D205D0D0A0A
5780   635E             ;---
5781   635E             	db	"Nagle Algorithm might lower"	,CR,LF
5781   635E 4E61676C6520416C676F726974686D206D69676874206C6F7765720D0A
5782   637B             	db	"performance but create less"	,CR,LF
5782   637B 706572666F726D616E63652062757420637265617465206C6573730D0A
5783   6398             	db	"network congestion."			,CR,LF
5783   6398 6E6574776F726B20636F6E67657374696F6E2E0D0A
5784   63AD             	db	"Nowadays it is mostly not"		,CR,LF
5784   63AD 4E6F776164617973206974206973206D6F73746C79206E6F740D0A
5785   63C8             	db	"needed and is the cause of"	,CR,LF
5785   63C8 6E656564656420616E6420697320746865206361757365206F660D0A
5786   63E4             	db	"latency and low performance"	,CR,LF
5786   63E4 6C6174656E637920616E64206C6F7720706572666F726D616E63650D0A
5787   6401             	db	"on packet-driven protocols."	,CR,LF,LF
5787   6401 6F6E207061636B65742D64726976656E2070726F746F636F6C732E0D0A0A
5788   641F             ;---
5789   641F             	db	"O - Turn it on/off"			,CR,LF,LF,STTERMINATOR
5789   641F 4F202D205475726E206974206F6E2F6F66660D0A0A00
5790   6435             ;---
5791   6435             
5792   6435             MMENU_NAGLE_ON:
5793   6435             	db	"Nagle is currently: ON"		,CR,LF,LF
5793   6435 4E61676C652069732063757272656E746C793A204F4E0D0A0A
5794   644E             ;---
5795   644E             	db	"ESC to return to main menu."	,CR,LF,LF
5795   644E 45534320746F2072657475726E20746F206D61696E206D656E752E0D0A0A
5796   646C             ;---
5797   646C             	db	"Option: "						,STTERMINATOR
5797   646C 4F7074696F6E3A2000
5798   6475             
5799   6475             MMENU_NAGLE_OFF:
5800   6475             	db	"Nagle is currently: OFF"		,CR,LF,LF
5800   6475 4E61676C652069732063757272656E746C793A204F46460D0A0A
5801   648F             ;---
5802   648F             	db	"ESC to return to main menu."	,CR,LF,LF
5802   648F 45534320746F2072657475726E20746F206D61696E206D656E752E0D0A0A
5803   64AD             ;---
5804   64AD             	db	"Option: "						,STTERMINATOR
5804   64AD 4F7074696F6E3A2000
5805   64B6             
5806   64B6             STR_SENDING:
5807   64B6             	db	"Sending command, wait..."		,CR,LF,STTERMINATOR
5807   64B6 53656E64696E6720636F6D6D616E642C20776169742E2E2E0D0A00
5808   64D1             
5809   64D1             STR_SENDING_OK:
5810   64D1             	db	"Command sent Ok, done!"		,CR,LF,STTERMINATOR
5810   64D1 436F6D6D616E642073656E74204F6B2C20646F6E65210D0A00
5811   64EA             
5812   64EA             STR_SENDING_OK_JN:
5813   64EA             	db	"Successfully connected!"		,CR,LF,STTERMINATOR
5813   64EA 5375636365737366756C6C7920636F6E6E6563746564210D0A00
5814   6504             
5815   6504             STR_SENDING_NOK_JN:
5816   6504             	db	"Fail to connect, if protected"	,GOLEFT,CR,LF
5816   6504 4661696C20746F20636F6E6E6563742C2069662070726F7465637465641D0D0A
5817   6524             	db	"network check password!"		,CR,LF,STTERMINATOR
5817   6524 6E6574776F726B20636865636B2070617373776F7264210D0A00
5818   653E             
5819   653E             STR_SENDING_FAIL:
5820   653E             	db	"Command failure..."			,CR,LF,STTERMINATOR
5820   653E 436F6D6D616E64206661696C7572652E2E2E0D0A00
5821   6553             
5822   6553             STR_CLKUPDT_FAIL:
5823   6553             	db	"Failure retrieving date and"	,CR,LF
5823   6553 4661696C7572652072657472696576696E67206461746520616E640D0A
5824   6570             	db	"time from SNTP server!"		,CR,LF,LF
5824   6570 74696D652066726F6D20534E545020736572766572210D0A0A
5825   6589             ;---
5826   6589             	db	"Press and hold F1 during"		,CR,LF
5826   6589 507265737320616E6420686F6C6420463120647572696E670D0A
5827   65A3             	db	"system boot to enter setup."	,CR,LF,STTERMINATOR
5827   65A3 73797374656D20626F6F7420746F20656E7465722073657475702E0D0A00
5828   65C1             
5829   65C1             OK_S:
5830   65C1             	db	"Installed successfully!"		,CR,LF,LF,STTERMINATOR
5830   65C1 496E7374616C6C6564207375636365737366756C6C79210D0A0A00
5831   65DC             ;---
5832   65DC             
5833   65DC             FAIL_S:
5834   65DC 0C          	db	CLS
5835   65DD             	db	"ESP8266 Not Found!"			,CR,LF,LF
5835   65DD 45535038323636204E6F7420466F756E64210D0A0A
5836   65F2             ;---
5837   65F2             	db	"Check that it is properly"		,CR,LF
5837   65F2 436865636B20746861742069742069732070726F7065726C790D0A
5838   660D             	db	"inserted in its connector."	,CR,LF,STTERMINATOR
5838   660D 696E73657274656420696E2069747320636F6E6E6563746F722E0D0A00
5839   662A             
5840   662A             FAIL_F:
5841   662A             	db	"ESP8266 FW Update Required!"	,CR,LF,STTERMINATOR
5841   662A 4553503832363620465720557064617465205265717569726564210D0A00
5842   6648             
5843   6648             STR_WAITING:
5844   6648 0B          	db	HOME
5845   6649             	db	"Waiting for connection..."		,CR,LF,LF,LF,STTERMINATOR
5845   6649 57616974696E6720666F7220636F6E6E656374696F6E2E2E2E0D0A0A0A00
5846   6667             ;---
5847   6667             ;---
5848   6667             
5849   6667             STR_OOPS:
5850   6667 0C          	db	CLS
5851   6668             	db	"Oops! An unexpected error"		,CR,LF
5851   6668 4F6F70732120416E20756E6578706563746564206572726F720D0A
5852   6683             	db	"occurred on the last reboot."	,CR,LF,STTERMINATOR
5852   6683 6F63637572726564206F6E20746865206C617374207265626F6F742E0D0A00
5853   66A2             
5854   66A2             ;============================
5855   66A2             ;===  UNAPI related data  ===
5856   66A2             ;============================
5857   66A2             
5858   66A2             ;--- Specification identifier (up to 15 chars)
5859   66A2             
5860   66A2             UNAPI_ID:				db	"TCP/IP",0
5860   66A2 5443502F495000
5861   66A9             UNAPI_ID_END:
5862   66A9             
5863   66A9             ;--- Implementation name (up to 63 chars and zero terminated)
5864   66A9             
5865   66A9             APIINFO:				db	"ESP8266 Wi-Fi UNAPI",0
5865   66A9 455350383236362057692D466920554E41504900
5866   66BD             
5867   66BD             	if	CHECK_OCM_HW = 1
5868   66BD~            		if	TURBO_R_LOGO = 0
5869   66BD~            ID_END:	ds	#7FE0-ID_END,#C9
5870   66BD~            ;--- FS-A1GT compliant BIOS without logo (not for FS-A1ST BIOS)
5871   66BD~            BUILD_NAME:				db	"[ ESP8266E.ROM ]"
5872   66BD~            		else
5873   66BD~            ID_END:	ds	#7900-ID_END,#FF
5874   66BD~            ;--- FS-A1GT compliant BIOS with logo (not for FS-A1ST BIOS)
5875   66BD~            	db	#CD,#0E,#79,#F3,#CD,#7D,#7A,#CD,#17,#79,#CD,#12,#79,#C9,#3E,#01
5876   66BD~            	db	#18,#01,#AF,#CD,#80,#01,#C9,#21,#FF,#00,#22,#5E,#F5,#21,#5E,#F5
5877   66BD~            	db	#11,#60,#F5,#01,#A8,#00,#ED,#B0,#21,#FF,#00,#CD,#54,#7A,#5C,#16
5878   66BD~            	db	#1A,#CD,#4C,#7B,#5D,#16,#1B,#CD,#4C,#7B,#CD,#38,#7A,#11,#63,#01
5879   66BD~            	db	#CD,#4C,#7B,#06,#15,#C5,#CD,#F8,#79,#DD,#21,#5E,#F5,#FD,#21,#A2
5880   66BD~            	db	#79,#06,#2B,#16,#00,#DD,#6E,#00,#DD,#66,#01,#FD,#5E,#00,#B7,#ED
5881   66BD~            	db	#52,#30,#03,#21,#00,#00,#DD,#75,#00,#DD,#74,#01,#DD,#23,#DD,#23
5882   66BD~            	db	#FD,#23,#DD,#6E,#00,#DD,#66,#01,#FD,#5E,#00,#19,#7C,#FE,#02,#38
5883   66BD~            	db	#03,#21,#00,#02,#DD,#75,#00,#DD,#74,#01,#DD,#23,#DD,#23,#FD,#23
5884   66BD~            	db	#10,#C3,#C1,#10,#B0,#11,#00,#19,#CD,#4C,#7B,#11,#1F,#02,#CD,#4C
5885   66BD~            	db	#7B,#C9,#13,#0D,#15,#12,#14,#0E,#10,#17,#13,#11,#15,#11,#0E,#0D
5886   66BD~            	db	#11,#15,#0C,#11,#13,#11,#15,#15,#12,#0C,#0F,#10,#0E,#0E,#15,#0D
5887   66BD~            	db	#0F,#11,#11,#11,#17,#14,#0D,#0D,#0C,#0C,#0D,#10,#15,#12,#17,#10
5888   66BD~            	db	#0E,#17,#11,#0C,#12,#13,#17,#0E,#16,#14,#14,#0E,#14,#15,#0E,#0E
5889   66BD~            	db	#13,#0F,#11,#13,#13,#0F,#17,#15,#0D,#15,#0F,#17,#0C,#0D,#16,#0C
5890   66BD~            	db	#11,#0E,#12,#14,#0D,#11,#17,#0D,#21,#5E,#F5,#01,#9B,#55,#5E,#23
5891   66BD~            	db	#56,#23,#1B,#7B,#CB,#3A,#1F,#0F,#0F,#3C,#E6,#3F,#57,#1C,#7B,#ED
5892   66BD~            	db	#44,#E6,#07,#5F,#3E,#1A,#D3,#99,#3E,#91,#D3,#99,#DB,#99,#DB,#99
5893   66BD~            	db	#E6,#20,#CA,#1E,#7A,#ED,#51,#ED,#59,#10,#D3,#11,#00,#1A,#CD,#4C
5894   66BD~            	db	#7B,#11,#00,#1B,#CD,#4C,#7B,#C9,#3E,#02,#D3,#99,#3E,#8F,#D3,#99
5895   66BD~            	db	#DB,#99,#E6,#40,#28,#FA,#DB,#99,#E6,#40,#20,#FA,#AF,#D3,#99,#3E
5896   66BD~            	db	#8F,#D3,#99,#C9,#C9,#1C,#E8,#00,#00,#1C,#E8,#00,#00,#3C,#E8,#00
5897   66BD~            	db	#00,#3C,#E8,#00,#00,#5C,#E8,#00,#00,#5C,#E8,#00,#00,#1C,#00,#04
5898   66BD~            	db	#00,#3C,#00,#04,#00,#5C,#00,#04,#00,#D8,#00,#00,#00,#CD,#38,#7A
5899   66BD~            	db	#11,#23,#01,#CD,#4C,#7B,#CD,#28,#7C,#3E,#55,#21,#00,#00,#4D,#45
5900   66BD~            	db	#CD,#75,#7B,#CD,#E1,#7B,#11,#05,#07,#CD,#4C,#7B,#21,#00,#78,#01
5901   66BD~            	db	#30,#00,#3E,#FF,#CD,#75,#7B,#21,#30,#78,#01,#10,#00,#3E,#F0,#CD
5902   66BD~            	db	#75,#7B,#21,#00,#74,#3E,#05,#01,#00,#02,#CD,#75,#7B,#21,#55,#7A
5903   66BD~            	db	#11,#00,#76,#01,#28,#00,#CD,#88,#7B,#11,#03,#19,#CD,#4C,#7B,#11
5904   66BD~            	db	#3F,#02,#CD,#4C,#7B,#11,#00,#2D,#CD,#4C,#7B,#16,#2A,#CD,#4C,#7B
5905   66BD~            	db	#14,#CD,#4C,#7B,#16,#27,#CD,#4C,#7B,#1E,#20,#21,#DE,#7C,#D9,#21
5906   66BD~            	db	#57,#7C,#D9,#3E,#03,#F5,#01,#2D,#00,#16,#26,#CD,#4C,#7B,#D9,#06
5907   66BD~            	db	#08,#4E,#23,#D9,#CD,#BB,#7B,#7E,#23,#FE,#FE,#28,#37,#E5,#C5,#01
5908   66BD~            	db	#A6,#01,#30,#03,#06,#00,#4F,#CD,#B7,#7B,#E1,#09,#4D,#44,#E1,#F1
5909   66BD~            	db	#EE,#03,#CD,#C6,#7B,#F5,#CD,#CF,#7B,#D9,#CB,#21,#10,#04,#06,#08
5910   66BD~            	db	#4E,#23,#D9,#30,#CF,#0B,#CD,#BB,#7B,#03,#3E,#02,#CD,#C6,#7B,#CD
5911   66BD~            	db	#DC,#7B,#18,#C0,#1C,#F1,#7E,#FE,#FE,#20,#A8,#C9,#F5,#7B,#D3,#99
5912   66BD~            	db	#7A,#F6,#80,#D3,#99,#F1,#C9,#3E,#02,#CD,#61,#7B,#0F,#38,#F8,#07
5913   66BD~            	db	#C9,#D3,#99,#3E,#8F,#D3,#99,#E5,#E1,#DB,#99,#F5,#AF,#D3,#99,#3E
5914   66BD~            	db	#8F,#D3,#99,#F1,#C9,#F5,#CD,#9D,#7B,#79,#B7,#28,#01,#04,#F1,#D3
5915   66BD~            	db	#98,#0D,#C2,#7F,#7B,#10,#F8,#C9,#EB,#CD,#9D,#7B,#EB,#79,#B7,#78
5916   66BD~            	db	#41,#0E,#98,#28,#01,#3C,#ED,#B3,#3D,#20,#FB,#EB,#C9,#7C,#E6,#3F
5917   66BD~            	db	#F6,#40,#08,#7C,#E6,#C0,#07,#07,#D3,#99,#3E,#8E,#D3,#99,#7D,#D3
5918   66BD~            	db	#99,#08,#D3,#99,#E3,#E3,#C9,#16,#28,#18,#02,#16,#24,#D5,#59,#CD
5919   66BD~            	db	#4C,#7B,#58,#14,#18,#04,#D5,#5F,#16,#2C,#CD,#4C,#7B,#D1,#C9,#D5
5920   66BD~            	db	#1E,#70,#16,#2E,#CD,#4C,#7B,#CD,#57,#7B,#D1,#C9,#D5,#1E,#50,#18
5921   66BD~            	db	#F1,#3E,#0D,#D3,#B4,#DB,#B5,#E6,#0C,#F6,#02,#D3,#B5,#3E,#0B,#D3
5922   66BD~            	db	#B4,#DB,#B5,#07,#07,#E6,#0C,#4F,#06,#00,#21,#47,#7C,#09,#4E,#23
5923   66BD~            	db	#46,#C5,#23,#5E,#23,#56,#EB,#11,#00,#10,#CD,#4C,#7B,#CD,#1D,#7C
5924   66BD~            	db	#E1,#CD,#1D,#7C,#21,#44,#04,#CD,#1D,#7C,#21,#77,#07,#C5,#0E,#9A
5925   66BD~            	db	#ED,#69,#E3,#E3,#ED,#61,#C1,#C9,#06,#08,#21,#37,#7C,#56,#23,#5E
5926   66BD~            	db	#23,#CD,#4C,#7B,#10,#F7,#C9,#00,#08,#01,#23,#08,#28,#09,#00,#02
5927   66BD~            	db	#1F,#05,#EF,#0B,#00,#06,#0F,#07,#00,#00,#00,#20,#04,#27,#02,#72
5928   66BD~            	db	#02,#56,#00,#70,#05,#70,#00,#00,#00,#00,#00,#00,#00,#00,#00,#00
5929   66BD~            	db	#6E,#00,#9F,#00,#6F,#00,#9F,#00,#6F,#00,#9F,#00,#6F,#00,#9F,#00
5930   66BD~            	db	#6F,#00,#9F,#00,#6F,#00,#9F,#00,#6F,#00,#FF,#00,#07,#00,#FC,#07
5931   66BD~            	db	#00,#F7,#00,#07,#00,#F3,#00,#07,#00,#F7,#00,#07,#00,#FF,#00,#07
5932   66BD~            	db	#00,#FF,#00,#0F,#00,#FC,#3C,#FC,#3C,#FC,#3C,#87,#C0,#7B,#C0,#87
5933   66BD~            	db	#C0,#7B,#C0,#86,#C0,#7B,#C0,#86,#C0,#7A,#C0,#86,#C0,#78,#C0,#86
5934   66BD~            	db	#90,#7A,#F0,#86,#F0,#7F,#C0,#83,#C0,#7F,#C0,#D7,#C0,#2F,#C0,#D7
5935   66BD~            	db	#C0,#2F,#C0,#D7,#C0,#2F,#C0,#D7,#C0,#2F,#C0,#D7,#C0,#2F,#C0,#D7
5936   66BD~            	db	#C0,#2F,#C0,#D5,#80,#00,#00,#00,#00,#00,#00,#00,#00,#00,#FF,#FE
5937   66BD~            	db	#FF,#FE,#FF,#FE,#FF,#FE,#FF,#FE,#FF,#FE,#FF,#FE,#FF,#FE,#FF,#FE
5938   66BD~            	db	#44,#1D,#1D,#1C,#30,#67,#2B,#28,#22,#FE,#44,#1D,#1C,#1E,#2A,#6D
5939   66BD~            	db	#29,#29,#22,#FE,#43,#1F,#1B,#1E,#26,#73,#25,#29,#24,#FE,#43,#1F
5940   66BD~            	db	#1A,#20,#22,#77,#23,#29,#25,#FE,#42,#21,#19,#20,#1F,#7C,#1F,#29
5941   66BD~            	db	#27,#FE,#42,#21,#18,#22,#1B,#80,#1D,#29,#28,#FE,#41,#23,#17,#22
5942   66BD~            	db	#19,#84,#1A,#28,#2A,#FE,#41,#23,#16,#24,#17,#86,#17,#29,#2B,#FE
5943   66BD~            	db	#40,#25,#15,#24,#15,#8A,#14,#28,#2D,#FE,#40,#25,#14,#26,#13,#8C
5944   66BD~            	db	#11,#29,#2E,#FE,#3F,#27,#13,#26,#12,#8F,#0E,#29,#2F,#FE,#3F,#27
5945   66BD~            	db	#12,#28,#10,#91,#0C,#28,#31,#FE,#3E,#29,#11,#28,#0F,#94,#08,#29
5946   66BD~            	db	#32,#FE,#3E,#2A,#0F,#2A,#0D,#96,#06,#28,#34,#FE,#3D,#2B,#0E,#2B
5947   66BD~            	db	#0C,#99,#02,#29,#35,#FE,#3D,#2C,#0D,#2C,#0B,#C2,#37,#FE,#3C,#2D
5948   66BD~            	db	#0C,#2D,#0A,#26,#4C,#50,#38,#FE,#3C,#2E,#0B,#2E,#09,#23,#51,#4C
5949   66BD~            	db	#3A,#FE,#3B,#2F,#0A,#2F,#09,#21,#54,#4A,#3B,#FE,#3B,#30,#09,#30
5950   66BD~            	db	#08,#20,#57,#46,#3D,#FE,#3A,#31,#08,#31,#08,#21,#57,#44,#3E,#FE
5951   66BD~            	db	#3A,#32,#07,#32,#07,#23,#57,#41,#3F,#FE,#39,#33,#06,#33,#07,#26
5952   66BD~            	db	#55,#3E,#41,#FE,#39,#34,#05,#34,#07,#46,#36,#3B,#42,#FE,#38,#35
5953   66BD~            	db	#04,#35,#07,#4B,#32,#38,#44,#FE,#38,#36,#03,#36,#07,#4E,#30,#35
5954   66BD~            	db	#45,#FE,#37,#37,#02,#37,#08,#50,#2E,#32,#47,#FE,#37,#71,#08,#52
5955   66BD~            	db	#2D,#2F,#48,#FE,#36,#72,#09,#54,#2B,#2C,#4A,#FE,#36,#73,#09,#55
5956   66BD~            	db	#2B,#29,#4B,#FE,#35,#74,#0A,#55,#29,#2A,#4B,#FE,#35,#75,#0B,#55
5957   66BD~            	db	#25,#2D,#4A,#FE,#34,#76,#0C,#55,#23,#30,#48,#FE,#34,#1F,#01,#37
5958   66BD~            	db	#01,#1F,#0D,#54,#20,#33,#47,#FE,#33,#20,#02,#36,#02,#1E,#10,#52
5959   66BD~            	db	#1E,#36,#45,#FE,#33,#1F,#03,#35,#03,#1F,#12,#50,#1B,#39,#44,#FE
5960   66BD~            	db	#32,#20,#04,#34,#04,#1E,#15,#4E,#19,#3C,#42,#FE,#32,#1F,#05,#33
5961   66BD~            	db	#05,#1F,#18,#4A,#18,#3E,#41,#FE,#31,#20,#06,#32,#06,#1E,#1D,#46
5962   66BD~            	db	#15,#42,#3F,#FE,#31,#1F,#07,#31,#07,#1F,#3C,#26,#14,#44,#3E,#FE
5963   66BD~            	db	#30,#20,#08,#30,#08,#1E,#40,#22,#12,#48,#3C,#FE,#30,#1F,#09,#2F
5964   66BD~            	db	#09,#1F,#41,#20,#11,#4A,#3B,#FE,#2F,#20,#0A,#2E,#0A,#1E,#41,#20
5965   66BD~            	db	#0F,#4E,#39,#FE,#2F,#1F,#0B,#2D,#0B,#1F,#40,#20,#0E,#28,#01,#27
5966   66BD~            	db	#38,#FE,#2E,#20,#0C,#2C,#0C,#1E,#3E,#22,#0C,#29,#04,#27,#36,#FE
5967   66BD~            	db	#2E,#1F,#0D,#2B,#0D,#1F,#39,#26,#0B,#29,#06,#27,#35,#FE,#2D,#20
5968   66BD~            	db	#0E,#2A,#0E,#7D,#0A,#28,#0A,#27,#33,#FE,#2D,#1F,#0F,#29,#0F,#7C
5969   66BD~            	db	#09,#29,#0C,#27,#32,#FE,#2C,#20,#10,#28,#10,#7B,#08,#28,#10,#27
5970   66BD~            	db	#30,#FE,#2C,#1F,#11,#27,#11,#7A,#07,#29,#12,#27,#2F,#FE,#2B,#1F
5971   66BD~            	db	#13,#25,#13,#78,#07,#28,#16,#27,#2D,#FE,#2B,#1F,#13,#25,#13,#77
5972   66BD~            	db	#06,#29,#18,#27,#2C,#FE,#2A,#1F,#15,#23,#15,#75,#06,#28,#1C,#27
5973   66BD~            	db	#2A,#FE,#2A,#1F,#15,#23,#15,#74,#06,#27,#1F,#27,#29,#FE,#29,#1F
5974   66BD~            	db	#17,#21,#17,#71,#06,#28,#22,#27,#27,#FE,#29,#1F,#17,#21,#17,#70
5975   66BD~            	db	#06,#27,#25,#27,#26,#FE,#28,#1F,#19,#1F,#19,#6D,#06,#28,#28,#27
5976   66BD~            	db	#24,#FE,#28,#1F,#19,#1F,#19,#6A,#08,#27,#2B,#27,#23,#FE,#27,#1F
5977   66BD~            	db	#1B,#1D,#1B,#66,#09,#28,#2E,#27,#21,#FE,#27,#1F,#1B,#1D,#1B,#63
5978   66BD~            	db	#0B,#27,#31,#27,#20,#FE,#26,#1F,#1D,#1B,#1D,#5F,#0C,#28,#34,#27
5979   66BD~            	db	#1E,#FE,#26,#1F,#1D,#1B,#1D,#5A,#0F,#28,#37,#27,#1D,#FE,#FF,#FE
5980   66BD~            	db	#FF,#FE,#FF,#FE,#FF,#FE,#FF,#FE,#FF,#FE,#FF,#FE,#FF,#FE,#FF,#FE
5981   66BD~            	db	#FE,#FF,#FF,#FF,#FF,#FF,#FF,#FF,#FF,#FF,#FF,#FF,#FF,#FF,#FF,#FF
5982   66BD~            	db	#FF,#FF,#FF,#FF,#FF,#FF,#FF,#FF,#FF,#FF,#FF,#FF,#FF,#FF,#FF,#FF
5983   66BD~            	db	#FF,#FF,#FF,#FF,#FF,#FF,#FF,#FF,#FF,#FF,#FF,#FF,#FF,#FF,#FF,#FF
5984   66BD~            	db	#FF,#FF,#FF,#FF,#FF,#FF,#FF,#FF,#FF,#FF,#FF,#FF,#FF,#FF,#FF,#FF
5985   66BD~            BUILD_NAME:				db	"[ ESP8266M.ROM ]"
5986   66BD~            		endif
5987   66BD             	else
5988   66BD FF          ID_END:	ds	#7FE0-ID_END,#FF
5989   7FE0             BUILD_NAME:				db	"[ ESP8266 .ROM ]"
5989   7FE0 5B2045535038323636202E524F4D205D
5990   7FF0             	endif
5991   7FF0             ;--- Build date to be viewed via Hex Editor (16 bytes)
5992   7FF0             
5993   7FF0             BUILD_DATE:				db	"BUILD 2020/08/04"
5993   7FF0 4255494C4420323032302F30382F3034
5994   8000             
5995   8000             SEG_CODE_END:
5996   8000             ; Final size must be 16384 bytes
